<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构与算法3-简单排序（冒泡、选择、插入）</title>
      <link href="/Data-Structure-and-Algorithms-3-Sorting-algorithm.html"/>
      <url>/Data-Structure-and-Algorithms-3-Sorting-algorithm.html</url>
      
        <content type="html"><![CDATA[<p>一旦建立了一个重要的数据库后，就可能根据某些需求对数据进行不同方式的排序。比如对姓名按字母顺序排序，对学生按年级排序，对顾客按照邮政编码排序，对国内销售品按价格排序等等。</p><p>由于排序非常重要而且可能非常耗时，所以它已经成为计算机可选中广泛研究的课题，而且人们的确已经研究出一些非常成熟的方法。本章里可以看到一些比较简单的算法:冒泡排序、选择排序和插入排序。</p><a id="more"></a><p>计算机程序通常不能像人的大脑一样一下就看到全景，一下就能几个队员进行高低排序，它只能一步一步地解决具体问题和遵循一些简单的规则。但这种方式的好处是，对海量的数据进行处理时候要远远效率高过人类。可能对5个人进行排序时候，人类的速度要块，可是如果对于5000万数据，人脑就无法应付过来了。</p><p>下面介绍的三种算法都包括如下两个步骤，这两步循环执行，直到全部数据有序为止:</p><ol><li>比较两个数据项</li><li>交换两个数据项，或复制其中一项<br>但是，每种算法具体实现的细节有所不同。</li></ol><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序算法运行起来非常慢，但在概念上它是排序算法中最简单的，因此冒泡排序算法在刚开始研究排序技术时是一个非常好的算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class BubbleSort &#123;</span><br><span class="line">    public void display(int[] arr)&#123;</span><br><span class="line">        for(int i:arr)&#123;</span><br><span class="line">            System.out.print(i + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void bubbleSort(int[] arr)&#123;</span><br><span class="line">        int i,j;</span><br><span class="line">        for(i = arr.length -1; i &gt; 0; i--)&#123;</span><br><span class="line">            for(j = 0; j &lt; i; j++)&#123;</span><br><span class="line">                if(arr[j] &gt; arr[j + 1])&#123;</span><br><span class="line">                    int tmp;</span><br><span class="line">                    tmp = arr[j];</span><br><span class="line">                    arr[j] = arr[j+1];</span><br><span class="line">                    arr[j+1] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        BubbleSort bs = new BubbleSort();</span><br><span class="line">        int [] arr = &#123;2,4,1,3,5,8,2,7,6,9&#125;;</span><br><span class="line">        System.out.println(&quot;排序前:&quot;);</span><br><span class="line">        bs.display(arr);</span><br><span class="line">        System.out.println(&quot; &quot;);</span><br><span class="line">        bs.bubbleSort(arr);</span><br><span class="line">        System.out.println(&quot;排序后:&quot;);</span><br><span class="line">        bs.display(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">排序前:</span><br><span class="line">2 4 1 3 5 8 2 7 6 9  </span><br><span class="line">排序后:</span><br><span class="line">1 2 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>冒泡排序从结果来看，一种是从小到大，一种是从大到小，两种原理是一样的，这里说的是从小到大。程序第5行定义了一个数组，这个数组就是我们要排序的对象。接着就是冒泡排序法。冒泡排序的原理是：首先进行相邻两个元素大小比较，如果左边的比右边的大，则进行左右交换，把大的放在右边，把小的放左边，然后再用上次比较的结果的靠右的更大的数，再次与右边的数进行比较，按此循环。在本例中第7行程序，调用了arr的length方法，也就是取得数组的长度，由于数组索引从0开始，因此，最后一个元素的索引是arr.length-1，本例中也就是10。当i=10时，进行内部循环，j=0,从第一个和第二个元素开始比较，也就是2和4比较，显然2小于4，所以不用交换，然后对j进行自加1，也就是j=1，再进行条件判断j=1&lt;i=10，所以继续循环，此时a[1]=4,a[2]=1,显然，a[1]&gt;a[2]，所以，进行交换，这样交换后变成2,1,4,3,5,8,2,7,6,9,重复上面的步骤，这样第一趟下来交换后的结果是2,1,3,4,5,2,7,6,8,9。我们注意到i这个变量，这个变量很多书上说它是趟的循环，比如第一趟循环，第二趟循环，其实质是将最大的数移到当前i所能达到的最大索引的位置，也就是说每一趟都是将当前索引范围内的数移到最大位置，如此循环，第10个位置，是1——10索引元素范围内的最大数，第9个位置是1——9索引元素范围内的最大数，类推，第2个位置是1——2最大数，第一个位置也就是本身。这样就能排序完毕。我们注意到理想情况下，这个排序需要10趟。所以这个排序效率是比较低的。</p><h3 id="冒泡排序的效率"><a href="#冒泡排序的效率" class="headerlink" title="冒泡排序的效率"></a>冒泡排序的效率</h3><p>通过对上面冒泡排序的分析可以看到，第1趟，总共10个数，需要9次比较，第二趟9个数，进行8次比较，依次类推，第10趟1个数，1次比较(这一次比较其实是没有用的)，总共就是9+8+7+6+5+4+3+2+1=45</p><p>一般来说，数组中有N个数据项，则第一趟排序有N-1次比较，第二趟有N-2次，如此类推，这样求和公式是:(N-1)+(N-2)+…+1=N(N-1)/2<br>当N很大时候，忽略掉低次项，也就是进行了约0.5N^2次比较。</p><p>上面是一种理论情况，实际进行交换的次数是少于比较的次数，如果数据是随机的，那么大概有一半数据需要交换，则交换次数为0.25(N^2)(最坏的情况是，初始数据完全是逆序的，每次比较都需要进行交换)</p><p>交换和比较操作次数都和N^2成正比。由于常数不算在大O表示法中，可以忽略掉系数，并且认为冒泡排序运行需要O(N^2)时间级别。这种排序是很慢的。</p><p>事实上，我们也可以这样计算，只要看到一个循环嵌套在另一个循环里，例如在冒泡排序和本章中的其他排序算法中，就可以怀疑这个算法的运行时间为O(N^2)级。外层循环执行N次，内部循环对于每一次外层循环都执行N次(或者几分之N次)，这就意味着将大约需要执行N*N或者N^2次某个基本操作。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>在上面的冒泡排序中，我们提到了比较次数和交换次数，比较是进行两个元素的比较，但不一定交换。</p><p>选择排序改进了冒泡排序，将必要的交换次数从O(N2)减少到O(N)。不幸的是比较次数仍然保持为O(N^2)。然而，选择排序依然为大记录量的排序提出了一个非常重要的改进，因为这些大量的记录需要在内存移动，这就使交换的时间和比较的时间相比起来，交换的时间更为重要。(一般来说，在Java语言中不是这种情况，Java中只是改变了引用位置，而实际对象的位置并没有改变。)</p><p>选择排序首先将最小的打上标签，然后将最小的移到最左边，作为已经排好的，然后接着从第二个元素开始，与剩余元素比较，然后找出最小的，再将最小的和第二个元素交换，按此迭代，直到排序结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void selectSort(int[] arr)&#123;</span><br><span class="line">        int i,j,min;</span><br><span class="line">        for(i = 0; i &lt; arr.length - 1; i++)&#123;</span><br><span class="line">            min = i;</span><br><span class="line">            for(j = i + 1; j &lt; arr.length; j++)&#123;</span><br><span class="line">                if(arr[j] &lt; arr[min])&#123;</span><br><span class="line">                    min = i;</span><br><span class="line">                &#125;</span><br><span class="line">                if(arr[i] &gt; arr[min])&#123;</span><br><span class="line">                    int tmp;</span><br><span class="line">                    tmp = arr[i];</span><br><span class="line">                    arr[i] = arr[min];</span><br><span class="line">                    arr[min] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>在大多数情况下，插入排序算法是本章描述的基本的排序算法中最好的一种。虽然插入排序算法仍然需要O(N^2)的时间，但是在一边情况下，它要比冒泡排序快一倍，比选择排序还要快一点。它经常被用在较复杂的排序算法的最后阶段，例如快速排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;a.length;i++)&#123;</span><br><span class="line">    int temp=a[i],j=i;</span><br><span class="line">    if(a[j-1]&gt;temp)&#123;</span><br><span class="line">        while(j&gt;=1&amp;&amp;a[j-1]&gt;temp)&#123;</span><br><span class="line">            a[j]=a[j-1];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：分析这个程序时候需要明确一点temp的值是在一次循环时候不变的，while循环后，j会进行自减。<br>我们以3 1 4 2 来进行分析，并且分析i = 1时情况 3 1 4 2<br>temp=a[1]=1，i = j = 1<br>首先j &gt;= 1，a[j-1]=a[0]=3 &gt; temp = 1，所以将a[0]的值赋给a[1]，这样，变成 3 3 4 2，<br>然后j自减变成0，由于j = 0 &lt; 1循环中止，此时j = 0，所以执行a[0] = temp=1，也就是1 3,4 2 </p><p>i = 2，满足条件，不用执行循环</p><p>i = 3, temp = a[3] = 2, i = j = 3<br>首先j &gt;= 1,a[j-1]=a[2]=4&gt;temp=2,所以将a[2]的赋给a[3]，这样变成1 3 4 4<br>接着将j自减1，变成2，首先j = 2&gt;=1,a[2-1]=a[1]=3，注意temp是不变的，所以a[1]依然大于temp=2，于是将a[1]赋给a[2]，变成1 3 3 4<br>然后j自减1，变成1，首先j = 1 &gt;= 1,a[1-1]=a[0]=1 &lt; 3，循环停止，于是<br>a[1]=temp=2<br>1 2 3 4<br>j再自减一次，已经不符合条件，整个循环中止，排序完成</p><h2 id="几种简单排序之间的比较"><a href="#几种简单排序之间的比较" class="headerlink" title="几种简单排序之间的比较"></a>几种简单排序之间的比较</h2><p>除非手边没有算法书可以参考，一般情况下，几乎不太使用冒泡排序算法，它过于简单了。当数据量很小的时候可以有应用价值。</p><p>选择排序虽然可以把交换次数降到最低，但比较次数仍然很大，当数据量比较小时候，并且交换数据相对于比较数据更加耗时情况下，可以应用选择排序。</p><p>在大多数情况下，数据量比较小或基本有序时，插入排序算法是三种简单排序算法中最好的选择，对于更大数据量，快速排序是最快的。<br>本章介绍的所有算法时间复杂度都是O(n^2)<br><img src="images/1909221.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>有类路由与无类路由的区别</title>
      <link href="/Classful-and-Classless.html"/>
      <url>/Classful-and-Classless.html</url>
      
        <content type="html"><![CDATA[<p>有类(Classful)网络 - 较早期，较垃圾。不支持子网掩码<br>无类(Classless)网络 - 现今一般三层设备大都是无类，携带子网掩码。无类网络中才能部署vlsm</p><a id="more"></a><p>最近看到RIP和OSPF方面了，这两个协议在NA里面被划分为距离矢量路由协议和链路状态路由协议；但是在NP里面划分路由又有种方法是基于有类的路由协议和无类的路由协议。RIP基于有类的路由协议,OSPF则是无类的路由协议。</p><ol><li>有类路由不会识别子网的信息,如宣告10.0.1.0/24 172.16.1.0/22 192.168.1.64/28；路由表中只会识别(自动汇总,且不能关闭)A类10.0.0.0/8,B类172.16.0.0/16 C类192.168.1.0/24 </li><li>无类的路由协议不会根据A B C类来识别,而是根据子网掩码的长度来区分网段,所以说无类的路由协议都可以关闭自动汇总</li><li>有类的路由自然也就不支持VLSM；无类的路由就可以支持VLSM </li></ol><p>IP Classful : RIP v1, IGRP ,EGP<br>IP Classless : RIP v2 ,EIGRP, OSPF, IS-IS, BGP</p><p>有类的路由协议只会传送网络前缀（网络地址），但是不会包含子网掩码。当它传送更新时，它首先检查直接连接的网络是否和发送更新的网络属于同一个大一点的子网，如果是的，那么它会继续检查它们的子网掩码是否相等，如果不等，那么更新信息会被丢弃而不会被广播。<br>当路由器A发送更新给路由器B时，它遵循下列几个步骤：</p><ol><li>路由器A检查192.168.1.0/24是否和192.168.2.0/30（更新传向过的网络）属于同一个大一点的网路。</li><li>答案是是的，所以路由器A比较它们的子网掩码192.168.1.0/24和192.168.2.0/30。</li><li>因为它们有两个不同的子网掩码，所以信息被丢弃。</li></ol><p>这就是为什么有类路由协议不支持VLSM(可变长子网掩码), 无类路由协议传输网络前缀（网络地址）的同时也会传输子网掩码，所以它支持VLSM</p><p>有类地址：早期的ip地址没有子网掩码，所有的地址都属于相应的主类网，距离矢量路由协议如RIP1，igrp属于有类的路由协议，它不能从邻居那里学到子网，所有关于子网的路由学到后被自动转为相应的主类网。譬如182.16.1.0就会变成B类地址的主类网182.16.0.0。</p><p>无类地址：根据可变长度的子网掩码划分不同的网络。譬如182.16.1.101，有类的话所在子网网段为182.16.0.0,子网掩码255.255.0.0，现在将子网掩码改为255.255.255.252的30位掩码，所在子网网段就是182.16.1.100。支持可变长度子网掩码的路由协议有RIP2，OSPF以及EIGRP。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSH</title>
      <link href="/The-Role-of-Layers-in-SSH.html"/>
      <url>/The-Role-of-Layers-in-SSH.html</url>
      
        <content type="html"><![CDATA[<p>传统的Java Web应用程序是采用JSP+Servlet+Javabean来实现的，这种模式实现了最基本的MVC分层，使得程序结构分为基层，有负责前台展示的JSP，负责流程逻辑控制的Servlet以及负责数据封装的Javabean。但是这种结构仍然存在问题：如JSP页面中需要使用符号嵌入很多的Java代码，造成页面结构混乱，Servlet和Javabean负责了大量的跳转和运算工作，耦合紧密，程序复用度低等等。</p><a id="more"></a><h2 id="Struts"><a href="#Struts" class="headerlink" title="Struts"></a>Struts</h2><p>为了解决这些问题，出现了Struts框架，他是一个完美的MVC实现，它有一个中央控制类（一个Servlet），针对不同的业务，我们需要一个Action类负责页面跳转和后台逻辑运算，一个或几个JSP页面负责数据的输入和输出显示，还有一个Form类负责传递Action和JSP中间的数据。JSP中可以使用Struts框架提供的一组标签，就像使用HTML标签一样简单，但是可以完成非常复杂的逻辑。从此JSP页面中不需要出现一行保卫的Java代码了。可是所有的运算逻辑都放在Struts的Action里将使得Action类复用度低和逻辑混乱，所以通常人们会把整个web应用分成三层，Struts负责显示层，它调用业务层完成运算逻辑，业务层再调用持久层完成数据库的读写。使用JDBC连接来读写数据库，我们最常见的就是打开数据库连接、使用复杂的SQL语句进行读写、关闭连接，获得的数据又需要转换或封装后往外传，这是一个繁琐的过程。</p><h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><p>这时出现了Hibernate框架，它需要你创建一系列的持久化类，每个类的属性都可以简单的看做和一张数据库表的属性一一对应，当然也可以实现关系数据库的各种表间关联的对应。当我们需要相关操作时，不用再关注数据库表。我们不用再去一行行的查询数据库，只需要持久化类就可以完成增删改查的功能，使得我们的软件开发真正面向对象，而不是面向混乱的代码。使用欧冠Hibernate比JDBC方式减少了80%的编程量。</p><p>现在我们有三个层了，可是每层之间的调用时怎样的呢？比如显示层的Struts需要调用一个业务类，就需要new一个业务类出来，然后使用；业务类需要调用持久层的类，也需要new一个持久层类出来用。通过这种new的方式互相调用就是软件开发中最糟糕设计的体现。简单的说，就是调用者依赖被调用者，它们之间形成了强耦合，如果我想在其他地方复用某个类，则这个类依赖的其他类也需要包含。程序就变得很混乱，每个类相互依赖相互调用，复用度极低。如果一个类做了修改，则依赖它的很多类都会受到牵连。</p><h2 id="为此，出现Spring框架。"><a href="#为此，出现Spring框架。" class="headerlink" title="为此，出现Spring框架。"></a>为此，出现Spring框架。</h2><p>Spring的作用就是完全解耦类之间的依赖关系，一个类如果要依赖什么，那就是一个接口。至于如何实现这个接口，这都不重要了。只要拿到一个实现了这个接口的类，就可以轻松的通过xml配置文件把实现类注射到调用接口的那个类里。所有类之间的这种依赖关系就完全通过配置文件的方式替代了。所以Spring框架最核心的就是所谓的依赖注入和控制反转。</p><p>现在的结构是，Struts负责显示层，Hibernate负责持久层，Spring负责中间层，这个结构是目前国内最流行的Java Web应用程序架构。</p><p>另外，由于Spring使用的依赖注射以及AOP(面向切面编程），所以它的这种内部模式非常优秀，以至于Spring自己也实现了一个使用依赖注射的MVC框架，叫Spring MVC，同时为了很好的处理事务，Spring集成了Hibernate，使事务管理从Hibernate的持久层提升到业务层，使用更加方便和强大。</p><p>业务流程：在表示层中，首先通过JSP页面实现交互界面，负责接收请求（Request）和传送响应（Response），然后Struts根据配置文件（struts-config.xml）将ActionServlet接收到的Request委派给相应的Action处理。在业务层中，管理服务组件的Spring IOC容器复杂向Action提交业务模型（Model）组件和该组件的协作对象数据处理（DAO）组件完成业务逻辑，并提供事务处理、缓冲池等容器组件以提升系统性能和保证数据的完整性。而在持久层中，则依赖于Hibernate的对象化映射和数据库交互，处理DAO组件请求的数据，返回处理结果。</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对于没有抽象类的抽象方法的思考</title>
      <link href="/abstract-class-without-abstract-method.html"/>
      <url>/abstract-class-without-abstract-method.html</url>
      
        <content type="html"><![CDATA[<p>一个类中的所有方法为抽象方法则可以把这个类定义为抽象类（此时类中的抽象方法格式书写默认）</p><p>抽象类中可以不定义抽象方法</p><p>抽象类不能创建对象</p><p>方法全为抽象方法的抽象类——接口（接口中的方法的格式都是默认好的）</p><a id="more"></a><p>【没有抽象方法的抽象类的思考】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">package Exercises;</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line">//没有抽象方法的抽象类的由来</span><br><span class="line">抽象类中可以不定义抽象方法，之所以定义为抽象类是为了使这个类不能创建对</span><br><span class="line"> */</span><br><span class="line">interface Inter&#123;</span><br><span class="line">    //四种显示方式</span><br><span class="line">    public void show1();</span><br><span class="line">    public void show2();</span><br><span class="line">    public void show3();</span><br><span class="line">    public void show4();</span><br><span class="line">&#125;</span><br><span class="line">//定义子类，要使用第一种显示方式</span><br><span class="line">class InterIMPL1 implements Inter&#123;</span><br><span class="line">    public void show1()&#123;</span><br><span class="line">        System.out.println(&quot;show1 run....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //仅仅实现show1 是不正确的（仅实现显示1 InterIMPL 相当于还是一个抽象类）为了使该类实例化，还要覆盖其他三个方法</span><br><span class="line">    //实现其他的抽象方法</span><br><span class="line">    public void show2()&#123;&#125;</span><br><span class="line">    public void show3()&#123;&#125;</span><br><span class="line">    public void show4()&#123;&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">//定义子类，要使用第四种显示方法</span><br><span class="line">class InterIMPL2 implements Inter&#123;</span><br><span class="line">    public void show4()&#123;</span><br><span class="line">        System.out.println(&quot;show4 run...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void show1()&#123;&#125;</span><br><span class="line">    public void show2()&#123;&#125;</span><br><span class="line">    public void show3()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">这样调用出现的问题</span><br><span class="line">当实现接口中的部分功能时，在两个实现中都有代码重复的部分，大大减小了的代码的复用性</span><br><span class="line">解决方式：</span><br><span class="line">抽取实现类中的共同部分，组成一个类</span><br><span class="line">具体思想：用一个类来空实现接口中的所有方法，再用不同的类通过继承来重写实现类中的方法，加大代码的复用性</span><br><span class="line"> */</span><br><span class="line">abstract class InterIMPL implements Inter&#123;  //将接口空实现，定义为一个没有抽象方法的抽象类——无法定义对象</span><br><span class="line">    public void show1()&#123;&#125;</span><br><span class="line">    public void show2()&#123;&#125;</span><br><span class="line">    public void show3()&#123;&#125;</span><br><span class="line">    public void show4()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class InterIMPL3 extends InterIMPL&#123;</span><br><span class="line">    public void show1()&#123;</span><br><span class="line">        System.out.println(&quot;show1 run!!!!!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class InterIMPL4 extends InterIMPL&#123;</span><br><span class="line">    public void show4()&#123;</span><br><span class="line">        System.out.println(&quot;show4 ru!!!!!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class interfaceDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        InterIMPL1 in1=new InterIMPL1();</span><br><span class="line">        in1.show1();</span><br><span class="line">        InterIMPL2 in2=new InterIMPL2();</span><br><span class="line">        in2.show4();</span><br><span class="line">        InterIMPL3 in3=new InterIMPL3();</span><br><span class="line">        in3.show3();</span><br><span class="line">        InterIMPL4 in4=new InterIMPL4();</span><br><span class="line">        in4.show4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决问题：只是用接口中的部分功能，提高代码的复用性，</p><p>具体：用一个类去空实现接口，再用具体实现的子类继承实现类，重写实现类中的方法。创建子类的对象就可以调用对应的方法</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>软考</title>
      <link href="/ruankao.html"/>
      <url>/ruankao.html</url>
      
        <content type="html"><![CDATA[<p>软考终于结束了，准备了前后有两个月吧，希望自己可以成功通过哈哈。备考的过程还是有很多的收获，很好的完善了所学的东西，更像是梳理了一遍。接下来还有很多东西要学，要与惰性作斗争，更要积极生活，保护好身体。加油(ง •̀_•́)ง</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于抽象类中的抽象方法和非抽象方法的问题</title>
      <link href="/abstract-class.html"/>
      <url>/abstract-class.html</url>
      
        <content type="html"><![CDATA[<p>抽象类就是不能使用new方法进行实例化的类，即没有具体实例对象的类。抽象类有点类似“模板”的作用，目的是根据其格式来创建和修改新的类。对象不能由抽象类直接创建，只可以通过抽象类派生出新的子类，再由其子类来创建对象。当一个类被声明为抽象类时，要在这个类前面加上修饰符abstract.</p><a id="more"></a><p>在抽象类中的成员方法可以包括一般方法和抽象方法。抽象方法就是以abstract修饰的方法，这种方法只声明返回的数据类型、方法名称和所需的参数，没有方法体，也就是说抽象方法只需要声明而不需要实现。当一个方法为抽象方法时，意味着这个方法必须被子类的方法所重写，否则其子类的该方法仍然是abstract的，而这个子类也必须是抽象的，即声明为abstract.</p><p>抽象类中不一定包含抽象方法，但是包含抽象方法的类一定要被声明为抽象类。抽象类本身不具备实际的功能，只能用于派生其子类。抽象类中可以包含构造方法，但是构造方法不能被声明为抽象。</p><p>调用抽象类中的方法（抽象方法和非抽象方法），如果方法是static的，直接 抽象类.方法 就可以了；如果是非static的则必须需要一个继承的非抽象类，然后用这个非抽象类的实例来调用方法。</p><p>抽象类可以实现接口，接口中的方法 在抽象类中可以不实现，当有子类继承 抽象类时，并且子类不是抽象类时，子类需要将抽象类中的 抽象方法和接口中的方法都实现。</p><p>抽象类不能用final来修饰，即一个类不能既是最终类又是抽象类。</p><p>总结： abstract不能与private、static、final、native并列修饰同一个方法。</p><ol><li>private :因为一个abstract方法需要被重写，所以不能修饰为private;</li><li>final:因为一个abstract方法需要被重写。被final修饰的方法是不能被重写的，所以不能同final共存；</li><li>static:因为一个abstract方法没有方法体。静态方法需要对方法体执行内容分配空间，所以不能同static共存；（abstract是没有实现的，不能产生对象，而是static是属于类的，类本身是已经存在的对象）</li><li>synchronized: 是同步的，然而同步需要具体的操作才能同步，但， abstract是只有声明没有实现的（即，使用synchronized关键字的是需要有具体的实现同步的操作的，但是使用abstract是只有声明而没有实现的，这样就产生了冲突）</li><li>native:他们本身的定义就是冲突的，native声明的方法是移交本地操作系统实现的，而abstract是移交子类对象实现的，同时修饰的话，导致不知道谁实现声明的方法</li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是spring的事务管理</title>
      <link href="/transaction-management.html"/>
      <url>/transaction-management.html</url>
      
        <content type="html"><![CDATA[<p>事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。<br>这样可以防止出现脏数据，防止数据库数据出现问题。</p><p>开发中为了避免这种情况一般都会进行事务管理。</p><p>在JDBC中是通过Connection对象进行事务管理的，默认是自动提交事务，可以手工将自动提交关闭，通过commit方法进行提交，rollback方法进行回滚，如果不提交，则数据不会真正的插入到数据库中。<br>Hibernate中是通过Transaction进行事务管理，处理方法与JDBC中类似。</p><p>Spring中也有自己的事务管理机制，一般是使用TransactionMananger进行管理，可以通过Spring的注入来完成此功能。</p><p>毕业报告中通过编写ShopOperationException.java继承runtime exception 完成插入数据库失败的回滚，如果是普通的exception，失败不会回滚，仍会插入。</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RESTful</title>
      <link href="/RESTful.html"/>
      <url>/RESTful.html</url>
      
        <content type="html"><![CDATA[<p>RESTFUL是一种网络应用程序的设计风格和开发方式，基于HTTP，可以使用XML格式定义或JSON格式定义。RESTFUL适用于移动互联网厂商作为业务使能接口的场景，实现第三方OTT调用移动网络资源的功能，动作类型为新增、变更、删除所调用资源。</p><a id="more"></a><h2 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h2><p>REST描述了一个架构样式的网络系统，比如 web 应用程序。在目前主流的三种Web服务交互方案中，REST相比于SOAP（Simple Object Access protocol，简单对象访问协议）以及XML-RPC更加简单明了，无论是对URL的处理还是对Payload的编码，REST都倾向于用更加简单轻量的方法设计和实现。值得注意的是REST并没有一个明确的标准，而更像是一种设计的风格。<br>Resource REpresentational State Transfer</p><p>Resource：资源，即数据。</p><p>Representational：某种表现形式，比如用JSON，XML，JPEG等；</p><p>State Transfer：状态变化。通过HTTP动词实现。</p><h2 id="原则条件"><a href="#原则条件" class="headerlink" title="原则条件"></a>原则条件</h2><p>REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。</p><p>Web 应用程序最重要的 REST 原则是，客户端和服务器之间的交互在请求之间是无状态的。从客户端到服务器的每个请求都必须包含理解请求所必需的信息。如果服务器在请求之间的任何时间点重启，客户端不会得到通知。此外，无状态请求可以由任何可用服务器回答，这十分适合云计算之类的环境。客户端可以缓存数据以改进性能。</p><p>在服务器端，应用程序状态和功能可以分为各种资源。资源是一个有趣的概念实体，它向客户端公开。资源的例子有：应用程序对象、数据库记录、算法等等。每个资源都使用 URI (Universal Resource Identifier) 得到一个唯一的地址。所有资源都共享统一的接口，以便在客户端和服务器之间传输状态。使用的是标准的 HTTP 方法，比如 GET、PUT、POST 和 DELETE。Hypermedia 是应用程序状态的引擎，资源表示通过超链接互联。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>每一个URI代表1种资源；</li><li>客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</li><li>通过操作资源的表现形式来操作资源；</li><li>资源的表现形式是XML或者HTML；</li><li>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。</li></ol><h2 id="RESTful与-RPC"><a href="#RESTful与-RPC" class="headerlink" title="RESTful与 RPC"></a>RESTful与 RPC</h2><p>使用 RPC 样式架构构建的基于 SOAP 的 Web 服务成为实现 SOA 最常用的方法。RPC 样式的 Web 服务客户端将一个装满数据的信封（包括方法和参数信息）通过 HTTP 发送到服务器。服务器打开信封并使用传入参数执行指定的方法。方法的结果打包到一个信封并作为响应发回客户端。客户端收到响应并打开信封。每个对象都有自己独特的方法以及仅公开一个 URI 的 RPC 样式 Web 服务，URI 表示单个端点。它忽略 HTTP 的大部分特性且仅支持 POST 方法。</p><p>由于轻量级以及通过 HTTP 直接传输数据的特性，Web 服务的 RESTful 方法已经成为最常见的替代方法。可以使用各种语言（比如 Java 程序、Perl、Ruby、Python、PHP 和 Javascript[包括 Ajax]）实现客户端。RESTful Web 服务通常可以通过自动客户端或代表用户的应用程序访问。但是，这种服务的简便性让用户能够与之直接交互，使用它们的 Web 浏览器构建一个 GET URL 并读取返回的内容。</p><p>在 REST 样式的 Web 服务中，每个资源都有一个地址。资源本身都是方法调用的目标，方法列表对所有资源都是一样的。这些方法都是标准方法，包括 HTTP GET、POST、PUT、DELETE，还可能包括 HEAD 和 OPTIONS。</p><p>在 RPC 样式的架构中，关注点在于方法，而在 REST 样式的架构中，关注点在于资源 —— 将使用标准方法检索并操作信息片段（使用表示的形式）。资源表示形式在表示形式中使用超链接互联。</p><p>Leonard Richardson 和 Sam Ruby 在他们的著作 RESTful Web Services 中引入了术语 REST-RPC 混合架构。REST-RPC 混合 Web 服务不使用信封包装方法、参数和数据，而是直接通过 HTTP 传输数据，这与 REST 样式的 Web 服务是类似的。但是它不使用标准的 HTTP 方法操作资源。它在 HTTP 请求的 URI 部分存储方法信息。好几个知名的 Web 服务，比如 Yahoo 的 Flickr API 和 Delicious API 都使用这种混合架构。</p><h2 id="RESTful架构"><a href="#RESTful架构" class="headerlink" title="RESTful架构"></a>RESTful架构</h2><p>RESTful架构是对MVC架构改进后所形成的一种架构，通过使用事先定义好的接口与不同的服务联系起来。在RESTful架构中，浏览器使用POST，DELETE，PUT和GET四种请求方式分别对指定的URL资源进行增删改查操作。因此，RESTful是通过URI实现对资源的管理及访问，具有扩展性强、结构清晰的特点。</p><p>RESTful架构将服务器分成前端服务器和后端服务器两部分，前端服务器为用户提供无模型的视图；后端服务器为前端服务器提供接口。浏览器向前端服务器请求视图，通过视图中包含的AJAX函数发起接口请求获取模型。</p><p>项目开发引入RESTful架构，利于团队并行开发。在RESTful架构中，将多数HTTP请求转移到前端服务器上，降低服务器的负荷，使视图获取后端模型失败也能呈现。但RESTful架构却不适用于所有的项目，当项目比较小时无需使用RESTful架构，项目变得更加复杂。</p><h2 id="RESTful-API-的特点"><a href="#RESTful-API-的特点" class="headerlink" title="RESTful API 的特点"></a>RESTful API 的特点</h2><p>RESTful API中，URL中只使用名词来指定资源，原则上不使用动词。“资源”是REST架构或者说整个网络处理的核心。比如：<a href="http://api.qc.com/v1/newsfeed" rel="external nofollow noopener noreferrer" target="_blank">http://api.qc.com/v1/newsfeed</a>: 获取某人的信息;<a href="http://api.qc.com/v1/friends" rel="external nofollow noopener noreferrer" target="_blank">http://api.qc.com/v1/friends</a>: 获取某人的好友列表;<a href="http://api.qc.com/v1/profile" rel="external nofollow noopener noreferrer" target="_blank">http://api.qc.com/v1/profile</a>: 获取某人的详细信息</p><p>那么动词怎么办呢？毕竟光对着资源名字，我们并不知道到底想要干嘛</p><p>GET     用来获取资源，POST  用来新建资源（也可以用于更新资源），</p><p>PUT     用来更新资源，</p><p>DELETE  用来删除资源。比如：DELETE <a href="http://api.qc.com/v1/friends" rel="external nofollow noopener noreferrer" target="_blank">http://api.qc.com/v1/friends</a>:</p><p>删除某人的好友 （在http parameter指定好友id）POST <a href="http://api.qc.com/v1/friends" rel="external nofollow noopener noreferrer" target="_blank">http://api.qc.com/v1/friends</a>:</p><p>添加好友PUT <a href="http://api.qc.com/v1/profile" rel="external nofollow noopener noreferrer" target="_blank">http://api.qc.com/v1/profile</a>: 更新个人资料</p><h2 id="使用RESTful的好处是什么？"><a href="#使用RESTful的好处是什么？" class="headerlink" title="使用RESTful的好处是什么？"></a>使用RESTful的好处是什么？</h2><ol><li>看Url就知道要什么</li><li>看http method就知道干什么</li><li>看http status  code就知道结果如何</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前后端分离 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前后端分离(续)</title>
      <link href="/Front-and-back-end-separation-xu.html"/>
      <url>/Front-and-back-end-separation-xu.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前后端分离已成为互联网项目开发的业界标准使用方式，通过nginx+tomcat的方式（也可以中间加一个nodejs）有效的进行解耦，并且前后端分离会为以后的大型分布式架构、弹性计算架构、微服务架构、多端化服务（多种客户端，例如：浏览器，车载终端，安卓，IOS等等）打下坚实的基础。这个步骤是系统架构从猿进化成人的必经之路。</p><p>核心思想是前端HTML页面通过AJAX调用后端的RESTFUL API接口并使用JSON数据进行交互。</p><p>Web服务器：一般指像Nginx，Apache这类的服务器，他们一般只能解析静态资源；</p><p>应用服务器：一般指像Tomcat，Jetty，Resin这类的服务器可以解析动态资源也可以解析静态资源，但解析静态资源的能力没有web服务器好；</p><p>一般都是只有web服务器才能被外网访问，应用服务器只能内网访问。</p><a id="more"></a><p>以前的Java Web项目大多数都是Java程序员又当爹又当妈，又搞前端，又搞后端。随着时代的发展，渐渐的许多大中小公司开始把前后端的界限分的越来越明确，前端工程师只管前端的事情，后端工程师只管后端的事情。正所谓术业有专攻，一个人如果什么都会，那么他毕竟什么都不精。大中型公司需要专业人才，小公司需要全才，但是对于个人职业发展来说，前后端需要分离。</p><h2 id="未分离时代（各种耦合）"><a href="#未分离时代（各种耦合）" class="headerlink" title="未分离时代（各种耦合）"></a>未分离时代（各种耦合）</h2><p>早期主要使用MVC框架，Jsp+Servlet的结构图如下：<br><img src="/images/1909231" alt></p><p>大致就是所有的请求都被发送给作为控制器的Servlet，它接受请求，并根据请求信息将它们分发给适当的JSP来响应。同时，Servlet还根据JSP的需求生成JavaBeans的实例并输出给JSP环境。JSP可以通过直接调用方法或使用UseBean的自定义标签得到JavaBeans中的数据。需要说明的是，这个View还可以采用 Velocity、Freemaker 等模板引擎。使用了这些模板引擎，可以使得开发过程中的人员分工更加明确，还能提高开发效率。</p><p>那么，在这个时期，开发方式有如下两种：<br><img src="/images/1909232" alt><br><img src="/images/1909233" alt><br>方式二已经逐渐淘汰。主要原因有两点：</p><ol><li>前端在开发过程中严重依赖后端，在后端没有完成的情况下，前端根本无法干活；</li><li>由于趋势问题，会JSP，懂velocity，freemarker等模板引擎的前端越来越少；</li></ol><p>因此，方式二逐渐不被采用。然而，不得不说一点，方式一，其实很多小型传统软件公司至今还在使用。那么，方式一和方式二具有哪些共同的缺点呢?</p><ol><li><p>前端无法单独调试，开发效率低；</p></li><li><p>前端不可避免会遇到后台代码，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;%</span><br><span class="line">       request.setCharacterEncoding(&quot;utf-8&quot;)</span><br><span class="line">       String name=request.getParameter(&quot;username&quot;);</span><br><span class="line">       out.print(name);</span><br><span class="line">   %&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p> 这种方式耦合性太强。那么，就算你用了freemarker等模板引擎，不用写Java代码。那前端也不可避免的要去重新学习该模板引擎的模板语法，无谓增加了前端的学习成本。正如我们后端开发不想写前端一样，你想想如果你的后台代码里嵌入前端代码，你是什么感受？因此，这种方式十分不妥。</p></li><li><p>JSP本身所导致的一些其他问题 比如，JSP第一次运行的时候比较缓慢，因为里头包含一个将JSP翻译为Servlet的步骤。再比如因为同步加载的原因，在JSP中有很多内容的情况下，页面响应会很慢。</p></li></ol><h2 id="半分离时代"><a href="#半分离时代" class="headerlink" title="半分离时代"></a>半分离时代</h2><p>前后端半分离，前端负责开发页面，通过接口（Ajax）获取数据，采用Dom操作对页面进行数据绑定，最终是由前端把页面渲染出来。这也就是Ajax与SPA应用（单页应用）结合的方式，其结构图如下：<br><img src="/images/1909234" alt><br>步骤如下：</p><ol><li>浏览器请求，CDN返回HTML页面；</li><li>HTML中的JS代码以Ajax方式请求后台的Restful接口；</li><li>接口返回Json数据，页面解析Json数据，通过Dom操作渲染页面；</li></ol><p>后端提供的都是以JSON为数据格式的API接口供Native端使用，同样提供给WEB的也是JSON格式的API接口。<br>那么意味着WEB工作流程是：</p><ol><li>打开web，加载基本资源，如CSS，JS等；</li><li>发起一个Ajax请求再到服务端请求数据，同时展示loading；</li><li>得到json格式的数据后再根据逻辑选择模板渲染出DOM字符串；</li><li>将DOM字符串插入页面中web view渲染出DOM结构；</li></ol><p>这些步骤都由用户所使用的设备中逐步执行，也就是说用户的设备性能与APP的运行速度联系的更紧换句话说就是如果用户的设备很低端，那么APP打开页面的速度会越慢。</p><p>为什么说是半分离的？因为不是所有页面都是单页面应用，在多页面应用的情况下，前端因为没有掌握controller层，前端需要跟后端讨论，我们这个页面是要同步输出呢，还是异步Json渲染呢？而且，即使在这一时期，通常也是一个工程师搞定前后端所有工作。因此，在这一阶段，只能算半分离。</p><p>首先，这种方式的优点是很明显的。前端不会嵌入任何后台代码，前端专注于HTML、CSS、JS的开发，不依赖于后端。自己还能够模拟Json数据来渲染页面。发现Bug，也能迅速定位出是谁的问题。</p><p>然而，在这种架构下，还是存在明显的弊端的。最明显的有如下几点：</p><ol><li>JS存在大量冗余，在业务复杂的情况下，页面的渲染部分的代码，非常复杂；</li><li>在Json返回的数据量比较大的情况下，渲染的十分缓慢，会出现页面卡顿的情况；</li><li>SEO（ Search Engine Optimization，即搜索引擎优化）非常不方便，由于搜索引擎的爬虫无法爬下JS异步渲染的数据，导致这样的页面，SEO会存在一定的问题；</li><li>资源消耗严重，在业务复杂的情况下，一个页面可能要发起多次HTTP请求才能将页面渲染完毕。可能有人不服，觉得PC端建立多次HTTP请求也没啥。那你考虑过移动端么，知道移动端建立一次HTTP请求需要消耗多少资源么？</li></ol><p>正是因为如上缺点，我们才亟需真正的前后端分离架构。</p><h2 id="分离时代"><a href="#分离时代" class="headerlink" title="分离时代"></a>分离时代</h2><p>大家一致认同的前后端分离的例子就是SPA(Single-page application)，所有用到的展现数据都是后端通过异步接口(AJAX/JSONP)的方式提供的，前端只管展现。从某种意义上来说，SPA确实做到了前后端分离，但这种方式存在两个问题：</p><ul><li>WEB服务中，SPA类占的比例很少。很多场景下还有同步/同步+异步混合的模式，SPA不能作为一种通用的解决方案；</li><li>现阶段的SPA开发模式，接口通常是按照展现逻辑来提供的，而且为了提高效率我们也需要后端帮我们处理一些展现逻辑，这就意味着后端还是涉足了view层的工作，不是真正的前后端分离。</li></ul><p>SPA式的前后端分离，从物理层做区分（认为只要是客户端的就是前端，服务器端就是后端）这种分法已经无法满足前后端分离的需求，我们认为从职责上划分才能满足目前的使用场景：</p><ul><li>前端负责view和controller层</li><li>后端只负责model层，业务处理与数据持久化等</li></ul><p>controller层与view层对于目前的后端开发来说，只是很边缘的一层，目前的java更适合做持久层、model层的业务。</p><p>在前后端彻底分离这一时期，前端的范围被扩展，controller层也被认为属于前端的一部分。在这一时期：<br>前端：负责View和Controller层。<br>后端：只负责Model层，业务/数据处理等。</p><p>可是服务端人员对前端HTML结构不熟悉，前端也不懂后台代码呀，controller层如何实现呢？这就是node.js的妙用了，node.js适合运用在高并发、I/O密集、少量业务逻辑的场景。最重要的一点是，前端不用再学一门其他的语言了，对前端来说，上手度大大提高。<br><img src="/images/1909235" alt><br>可以就把Nodejs当成跟前端交互的api。总得来说，NodeJs的作用在MVC中相当于C（控制器）。Nodejs路由的实现逻辑是把前端静态页面代码当成字符串发送到客户端（例如浏览器），简单理解可以理解为路由是提供给客户端的一组api接口，只不过返回的数据是页面代码的字符串而已。</p><p>用NodeJs来作为桥梁架接服务器端API输出的JSON。后端出于性能和别的原因，提供的接口所返回的数据格式也许不太适合前端直接使用，前端所需的排序功能、筛选功能，以及到了视图层的页面展现，也许都需要对接口所提供的数据进行二次处理。这些处理虽可以放在前端来进行，但也许数据量一大便会浪费浏览器性能。因而现今，增加Node中间层便是一种良好的解决方案。<br><img src="/images/1909238.png" alt><br>浏览器(webview)不再直接请求JSP的API，而是：</p><ol><li>浏览器请求服务器端的NodeJS；</li><li>NodeJS再发起HTTP去请求；</li><li>依然原样API输出JSON给NodeJS；</li><li>NodeJS收到JSON后再渲染出HTML页面；</li><li>NodeJS直接将HTML页面flush到浏览器；<br>这样，浏览器得到的就是普通的HTML页面，而不用再发Ajax去请求服务器了。</li></ol><p>淘宝的前端团队提出的中途岛(Midway Framework)的架构如下图所示：<br><img src="/images/1909236.jpg" alt><br>增加node.js作为中间层，具体有哪些好处呢？</p><ol><li>适配性提升；我们其实在开发过程中，经常会给PC端、mobile、app端各自研发一套前端。其实对于这三端来说，大部分端业务逻辑是一样的。唯一区别就是交互展现逻辑不同。如果controller层在后端手里，后端为了这些不同端页面展示逻辑，自己维护这些controller，模版无法重用，徒增和前端沟通端成本。 如果增加了node.js层，此时架构图如下：<br><img src="/images/1909237" alt><br>在该结构下，每种前端的界面展示逻辑由node层自己维护。如果产品经理中途想要改动界面什么的，可以由前端自己专职维护，后端无需操心。前后端各司其职，后端专注自己的业务逻辑开发，前端专注产品效果开发。</li><li>响应速度提升；我们有时候，会遇到后端返回给前端的数据太简单了，前端需要对这些数据进行逻辑运算。那么在数据量比较小的时候，对其做运算分组等操作，并无影响。但是当数据量大的时候，会有明显的卡顿效果。这时候，node中间层其实可以将很多这样的代码放入node层处理、也可以替后端分担一些简单的逻辑、又可以用模板引擎自己掌握前台的输出。这样做灵活度、响应度都大大提升。<br>举个例子，即使做了页面静态化之后，前端依然还是有不少需要实时从后端获取的信息，这些信息都在不同的业务系统中，所以需要前端发送5，6个异步请求来。有了NodeJs之后，前端可以在NodeJs中去代理这5个异步请求。还能很容易的做bigpipe，这块的优化能让整个渲染效率提升很多。在PC上你觉得发5,6个异步请求也没什么，但是在无线端，在客户手机上建立一个http请求开销很大。有了这个优化，性能一下提升好几倍。</li><li>性能得到提升；大家应该都知道单一职责原则。从该角度来看，我们，请求一个页面，可能要响应很多个后端接口，请求变多了，自然速度就变慢了，这种现象在mobile端更加严重。采用node作为中间层，将页面所需要的多个后端数据，直接在内网阶段就拼装好，再统一返回给前端，会得到更好的性能。</li><li>异步与模板统一；淘宝首页就是被几十个HTML片段（每个片段一个文件）拼装成，之前PHP同步include这几十个片段，一定是串行的，Node可以异步，读文件可以并行，一旦这些片段中也包含业务逻辑，异步的优势就很明显了，真正做到哪个文件先渲染完就先输出显示。前端机的文件系统越复杂，页面的组成片段越多，这种异步的提速效果就越明显。前后端模板统一在无线领域很有用，PC页面和WIFI场景下的页面适合前端渲染（后端数据Ajax到前端），2G、3G弱网络环境适合后端渲染（数据随页面吐给前端），所以同样的模板，在不同的条件下走不同的渲染渠道，模板只需一次开发。<br>增加NodeJS中间层后的前后端职责划分：<br><img src="/images/1909239.png" alt></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从经典的JSP+Servlet+JavaBean的MVC时代，到SSM（Spring + SpringMVC + Mybatis）和SSH（Spring + Struts + Hibernate）的Java 框架时代，再到前端框架（KnockoutJS、AngularJS、vueJS、ReactJS）为主的MV*时代，然后是Nodejs引领的全栈时代，技术和架构一直都在进步。虽然“基于NodeJS的全栈式开发”模式很让人兴奋，但是把基于Node的全栈开发变成一个稳定，让大家都能接受的东西还有很多路要走。创新之路不会止步，无论是前后端分离模式还是其他模式，都是为了更方便得解决需求，但它们都只是一个“中转站”。前端项目与后端项目是两个项目，放在两个不同的服务器，需要独立部署，两个不同的工程，两个不同的代码库，不同的开发人员。前端只需要关注页面的样式与动态数据的解析及渲染，而后端专注于具体业务逻辑。</p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://2014.jsconf.cn/slides/herman-taobaoweb/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://2014.jsconf.cn/slides/herman-taobaoweb/index.html</a><br><a href="https://mp.weixin.qq.com/s/bSl1FKWFznVzn_1wbBoOCA" rel="external nofollow noopener noreferrer" target="_blank">https://mp.weixin.qq.com/s/bSl1FKWFznVzn_1wbBoOCA</a><br><a href="https://zhuanlan.zhihu.com/p/20534796" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/20534796</a><br><a href="https://blog.csdn.net/dream_cat_forever/article/details/80709503" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/dream_cat_forever/article/details/80709503</a><br><a href="https://blog.csdn.net/fuzhongmin05/article/details/81591072" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/fuzhongmin05/article/details/81591072</a></p>]]></content>
      
      
      <categories>
          
          <category> 前后端分离 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么说SSH已经过时了</title>
      <link href="/Why-SSH-is-no-longer-popular.html"/>
      <url>/Why-SSH-is-no-longer-popular.html</url>
      
        <content type="html"><![CDATA[<p>在JavaEE的开发过程中，时常会用到Web应用程序的框架，SSH是曾经一度比较热门的框架，其作用同样是为了搭建一个架构清晰、有较好的可复用性、便于维护和管理的系统。具体来说，SSH是指Struts、Spring、Hibernate三大框架，Struts用来作为基础性的架构，Hibernate用于数据的持久层，而Spring用来对前两者进行管理，编写基本的DAO接口。其实，三大框架在实践中也经历了不断地进化，从SSH框架发展为SSM框架，稍早的一些项目使用Spring、Struts2、Mybatis来写，而现在一般情况下使用Spring、SpringMVC、Mybatis来做项目。总之，框架的基本功能相同，但经历了不断地改进。</p><a id="more"></a><p>首先回顾一下SSH框架的功能和用途，Hibernate是一个轻量级的持久框架，能够较为完善地处理表与表之间的映射关系，同时能够较好的封装JDBC。在开发数据库的过程中写好接口的同时并不需要用大量的SQL语句对数据库进行交互操作。Struts作为MVC的Web层框架，对底层Servlet的大量封装，可对业务逻辑调用的同时也拥有强大的拦截器机制。</p><p>三大框架之间的关系或流程基本是这样的：按照JSP——Struts——Service——Hibernate的顺序。Struts调用Service，从而控制了Service的生命周期，加强了各层次之间的依赖性，在一定程度上也增加了耦合性。所以我们引用了 Spring来作为框架中的容器，维护不同层次之间的关系。通过IOC反转控制DI依赖注入完成各个层之间的注入，使得层与层之间实现完全脱耦，增加运行效率利于维护。</p><p>说起Spring，则不得不提AOP面向切面编程，运用这一方法可达到在不改变代码的情况下完成对方法增强的目的。比较常用的就是Spring的声明式事务管理，底层通过AOP实现，避免了我们每次都要手动开启事务，提交事务的重复性代码，使得开发逻辑更加清晰。面试会问得细一些，例如Hibernate的懒加载以及Spring的AOP和IOC原理，等等。</p><p>以上回顾了SSH的基本功能和作用，下面说说SSH的现状和SSH框架为什么会被取代。</p><p>首先struts2框架存在一定的漏洞，在应用和实施中对信息的安全有较大的隐患。在开发中也有很多方面不够便利，特别是JSR-311标准出台之后，随着Restful方式的流程程度普及开来，struts2逐渐淡出人们的视线，虽然struts2也加入了一些plugin来进行支持REST，但在应用的过程中也较为繁琐。</p><p>其次是Spring以IOC为核心，在功能上做了一写扩展，先后推出了SpringMVC来完成逻辑层的编写逻辑，现在SpringMVC基本已经完成了替代struts2的工作，当然，可能有一些老的项目还在用，但新开发的项目几乎已看不到。</p><p>SpringMVC获得了开发者的广泛认可，在SpringMVC和Web容器的基础上，对二者的功能进行了有机的结合，推出了SpringBoot，经过几年的发展，现在后端基本被Spring系列所统一。可以说，Spring系列在框架的优化方面经受住了考验，被广泛采用。Hibernate是一个对操作数据库进行映射的框架，它的替代品也很多，所以是否实施也需要看项目而定，其方便之处可能就在于对SQL的优化上。</p><p>当前的开发环境中，比较提倡前后端分离，但并非完全分离。不是之前通过模版进行分离，前后端数据交互是根据http进行的。后端设计的接口趋向于Restful的架构，因为现在前端不仅仅是web端，在移动互联网时代，APP也是很大一部分。在后端看来，APP客户端无法通过模版进行渲染的，只能通过http传输数据。Java后端技术有很多，如果想要提高，最好的方法还是多做项目多思考，对于SSH框架可用于参考，要把主要精力放在SpringMVC，掌握Spring的核心，然后深入了解一下Restful概念和JDBC的一些概念。</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中的多态</title>
      <link href="/Polymorphism.html"/>
      <url>/Polymorphism.html</url>
      
        <content type="html"><![CDATA[<h2 id="多态的定义"><a href="#多态的定义" class="headerlink" title="多态的定义"></a>多态的定义</h2><p>多态、封装和继承是面向对象的三大特性。现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。</p><p>Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。一个Student对象既可以赋值给一个Student类型的引用，也可以赋值给一个Person类型的引用。 </p><p><strong>最终多态体现为父类引用变量可以指向子类对象：父类类型 变量名 = new 子类类型();</strong> </p><ol><li>多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。 </li><li>在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。 <a id="more"></a></li></ol><h2 id="多态的表现形式"><a href="#多态的表现形式" class="headerlink" title="多态的表现形式"></a>多态的表现形式</h2><ol><li>方法重载：通常是指在同一个类中，相同的方法名对应着不同的方法实现，这些方法名相同的方法其区别在于他们需要的参数不同；</li><li>方法重写：方法重写主要用于父类和子类间，子类重写父类的方法，只是对应的方法实现不同，其方法名和参数都相同；</li><li>抽象类：在java语言中，一个类中的方法只给出了标准，而没有给出具体的实现方法，这样的类就是抽象类。例如父类就是抽象类，它不会被实例化的类；</li><li>接口：在多态机制中，接口比抽象类使用起来更加方便。而抽象类组成的集合就是接口。</li></ol><h2 id="多态的三种形式"><a href="#多态的三种形式" class="headerlink" title="多态的三种形式"></a>多态的三种形式</h2><ul><li><p>普通类多态定义的格式：父类类型 变量名 = new 子类类型()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">    int num = 4;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Son extends Father &#123;</span><br><span class="line">    int num = 5;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//普通类多态形式</span><br><span class="line">Father father = new Son();</span><br></pre></td></tr></table></figure></li><li><p>抽象类多态定义的格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">abstract class Father &#123;</span><br><span class="line">    abstract void method();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Son extends Father &#123;</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        System.out.println(&quot;abstract&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//抽象类多态表现形式</span><br><span class="line">Father father = new Son();</span><br></pre></td></tr></table></figure></li><li><p>接口多态定义的格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Father &#123;</span><br><span class="line">    public void method();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Son implements Father&#123;</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        System.out.println(&quot;implements&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//接口多态的表现形式</span><br><span class="line">Father father = new Son();</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：同一个父类的方法会被不同的子类重写。在调用方法时，调用的为各个子类重写后的方法。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = new Student();</span><br><span class="line">Person p2 = new Teacher();</span><br><span class="line">p1.work(); //p1会调用Student类中重写的work方法</span><br><span class="line">p2.work(); //p2会调用Teacher类中重写的work方法</span><br></pre></td></tr></table></figure><h2 id="多态的编译和运行"><a href="#多态的编译和运行" class="headerlink" title="多态的编译和运行"></a>多态的编译和运行</h2><h3 id="成员变量：编译和运行都看左边。"><a href="#成员变量：编译和运行都看左边。" class="headerlink" title="成员变量：编译和运行都看左边。"></a>成员变量：编译和运行都看左边。</h3><p>多态出现后类的成员有啥变化呢？学习继承时，我们知道子父类之间成员变量有了自己的特定变化，那么当多态出现后，成员变量在使用上有没有变化呢？<br>多态出现后会导致子父类中的成员变量有微弱的变化。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">    int num = 4;//没有这句会编译失败</span><br><span class="line">&#125;</span><br><span class="line">class Son extends Father &#123;</span><br><span class="line">    int num = 5;</span><br><span class="line">&#125;</span><br><span class="line">class Demo &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        Father f = new Son();</span><br><span class="line">        System.out.println(f.num);</span><br><span class="line">        Son z = new Son();</span><br><span class="line">        System.out.println(z.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：4<br>5<br>总结：当子父类中出现同名的成员变量时，多态调用该变量时： </p><ol><li>编译时期：参考的是引用型变量所属的类中是否有被调用的成员变量。没有，编译失败 </li><li>运行时期：也是调用引用型变量所属的类中的成员变量。 </li></ol><p>简单记：编译和运行都参考等号的左边。编译运行看左边。</p><h3 id="成员方法：编译看左边，运行看右边。"><a href="#成员方法：编译看左边，运行看右边。" class="headerlink" title="成员方法：编译看左边，运行看右边。"></a>成员方法：编译看左边，运行看右边。</h3><p>多态出现后会导致子父类中的成员方法有微弱的变化，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">    int num = 4;</span><br><span class="line">    //没有这个方法，编译失败</span><br><span class="line">    void show() &#123;</span><br><span class="line">        System.out.println(&quot;Father show num&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Son extends Father &#123;</span><br><span class="line">    int num = 5;</span><br><span class="line">    //重写父类方法</span><br><span class="line">    void show() &#123;</span><br><span class="line">           System.out.println(&quot;Son show num&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    void show_1&#123;</span><br><span class="line">           System.out.println(&quot;Son show show_1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Demo &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        Father f = new Son();</span><br><span class="line">        f.show();</span><br><span class="line">        //f.show_1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：Son show num<br>总结：多态成员方法 </p><ol><li>编译时期：参考引用变量所属的类，如果没有类中没有调用的方法，编译失败(如果把f.show_1()前面的注释打开，则编译失败)。 </li><li>运行时期：参考引用变量所指的对象所属的类，并运行对象所属类中的成员方法（如果把子类重写的show()方法注释掉，那么打印的结果是Father show num）。</li></ol><p>简而言之：编译看左边，运行看右边。</p><h2 id="多态的转型"><a href="#多态的转型" class="headerlink" title="多态的转型"></a>多态的转型</h2><ul><li>向上转型：当有子类对象赋值给一个父类引用时，便是向上转型，多态本身就是向上转型的过程。<br>使用格式：父类类型 变量名 = new 子类类型()<br><code>Person p = new Student();</code></li><li>向下转型：一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用转为子类引用，这个过程是向下转型。如果是直接创建父类对象，是无法向下转型的！<br>使用格式：子类类型 变量名 = （子类类型）父类类型<br><code>Person p = new Student();</code><br><code>Student stu = (Student) p</code></li></ul><h2 id="多态的好处与弊病"><a href="#多态的好处与弊病" class="headerlink" title="多态的好处与弊病"></a>多态的好处与弊病</h2><p>当父类的引用指向子类对象时，就发生了向上转型，即把子类类型对象转成了父类类型。向上转型的好处是隐藏了子类类型，提高了代码的扩展性。但向上转型也有弊端，只能使用父类共性的内容，而无法使用子类特有功能，功能有限制。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//描述动物类，并抽取共性eat方法</span><br><span class="line">abstract class Animal &#123;</span><br><span class="line">    abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 描述狗类，继承动物类，重写eat方法，增加lookHome方法</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    void eat() &#123;</span><br><span class="line">        System.out.println(&quot;啃骨头&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void lookHome() &#123;</span><br><span class="line">        System.out.println(&quot;看家&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 描述猫类，继承动物类，重写eat方法，增加catchMouse方法</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃鱼&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void catchMouse() &#123;</span><br><span class="line">        System.out.println(&quot;抓老鼠&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Animal a = new Dog(); //多态形式，创建一个狗对象</span><br><span class="line">        a.eat(); // 调用对象中的方法，会执行狗类中的eat方法</span><br><span class="line">        // a.lookHome();//使用Dog类特有的方法，需要向下转型，不能直接使用</span><br><span class="line">        // 为了使用狗类的lookHome方法，需要向下转型</span><br><span class="line">        // 向下转型过程中，可能会发生类型转换的错误，即ClassCastException异常</span><br><span class="line">        // 那么，在转之前需要做健壮性判断 </span><br><span class="line">        if( !a instanceof Dog)&#123; // 判断当前对象是否是Dog类型</span><br><span class="line">                System.out.println(&quot;类型不匹配，不能转换&quot;); </span><br><span class="line">                return; </span><br><span class="line">        &#125; </span><br><span class="line">        Dog d = (Dog) a; //向下转型</span><br><span class="line">        d.lookHome();//调用狗类的lookHome方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>什么时候使用向上转型?</strong><br>当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作，这时就可以使用向上转型：<br><code>Animal a = new Dog();</code><br><code>a.eat();</code></p><p><strong>什么时候使用向下转型?</strong><br>当要使用子类特有功能时，就需要使用向下转型：<br><code>Dog d = (Dog) a; //向下转型</code><br><code>d.lookHome();//调用狗类的lookHome方法</code><br>向下转型的好处：可以使用子类特有功能。<br>向下转型的弊端：需要面对具体的子类对象；在向下转型时容易发生ClassCastException类型转换异常。在转换之前必须做类型判断。<br>如：if( !a instanceof Dog){…}</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSM中各层作用及关系</title>
      <link href="/The-Role-of-Layers-in-SSM.html"/>
      <url>/The-Role-of-Layers-in-SSM.html</url>
      
        <content type="html"><![CDATA[<h2 id="持久层：DAO层（mapper层）（属于mybatis模块）"><a href="#持久层：DAO层（mapper层）（属于mybatis模块）" class="headerlink" title="持久层：DAO层（mapper层）（属于mybatis模块）"></a>持久层：DAO层（mapper层）（属于mybatis模块）</h2><ul><li>DAO层：主要负责与数据库进行交互设计，用来处理数据的持久化工作。</li><li>DAO层的设计首先是设计DAO的接口，也就是项目中看到的Dao包。</li><li>然后在Spring的xml配置文件中定义此接口的实现类，就可在其他模块中调用此接口来进行数据业务的处理，而不用关心接口的具体实现类是哪个类，这里往往用到的就是反射机制，DAO层的jdbc.properties数据源配置，以及有关数据库连接的参数都在Spring的配置文件中进行配置。</li><li>有的项目Dao层，写成mapper，当成一个意思理解。<a id="more"></a></li></ul><h2 id="业务层：Service层（属于spring模块）"><a href="#业务层：Service层（属于spring模块）" class="headerlink" title="业务层：Service层（属于spring模块）"></a>业务层：Service层（属于spring模块）</h2><ul><li>Service层：主要负责业务模块的逻辑应用设计。也就是项目中看到的Service包。</li><li>Service层的设计首先是设计接口，再设计其实现的类。也就是项目中看到的service+impl包。</li><li>接着再在Spring的xml配置文件中配置其实现的关联。这样我们就可以在应用中调用Service接口来进行业务处理。</li><li>最后通过调用DAO层已定义的接口，去实现Service具体的实现类。</li><li>Service层的业务实现，具体要调用到已定义的DAO层的接口。</li></ul><h2 id="控制层-表现层：Controller层（Handler层）-（属于springMVC模块）"><a href="#控制层-表现层：Controller层（Handler层）-（属于springMVC模块）" class="headerlink" title="控制层/表现层：Controller层（Handler层） （属于springMVC模块）"></a>控制层/表现层：Controller层（Handler层） （属于springMVC模块）</h2><ul><li>Controller层：主要负责具体的业务模块流程控制，也就是看到的controller包。</li><li>Controller层通过要调用Service层的接口来控制业务流程，控制的配置也同样是在Spring的xml配置文件里面，针对具体的业务流程，会有不同的控制器。</li></ul><h2 id="View层-（属于springMVC模块）"><a href="#View层-（属于springMVC模块）" class="headerlink" title="View层 （属于springMVC模块）"></a>View层 （属于springMVC模块）</h2><ul><li>负责前台jsp页面的展示，此层需要与Controller层结合起来开发。</li><li>Jsp发送请求，controller接收请求，处理，返回，jsp回显数据。</li></ul><h2 id="各层之间的联系"><a href="#各层之间的联系" class="headerlink" title="各层之间的联系"></a>各层之间的联系</h2><ul><li>DAO层，Service层这两个层次可以单独开发，互相的耦合度很低。</li><li>Controller，View层耦合度比较高，因而要结合在一起开发。也可以听当做两层来开发，这样，在层与层之前我们只需要知道接口的定义，调用接口即可完成所需要的逻辑单元应用，项目会显得清晰简单。</li><li>值得注意的是，Service逻辑层设计：Service层是建立在DAO层之上的，在Controller层之下。因而Service层应该既调用DAO层的接口，又提供接口给Controller层的类来进行调用，它处于一个中间层的位置。每个模型都有一个Service接口，每个接口分别封装各自的业务处理方法。 </li></ul><h2 id="SSM框架实现一个web程序主要使用到如下三个技术："><a href="#SSM框架实现一个web程序主要使用到如下三个技术：" class="headerlink" title="SSM框架实现一个web程序主要使用到如下三个技术："></a>SSM框架实现一个web程序主要使用到如下三个技术：</h2><ul><li>Spring：用到注解和自动装配，就是Spring的两个精髓IOC(反向控制)和 AOP(面向切面编程)。</li><li>SpringMVC：用到了MVC模型，将流程控制代码放到Controller层处理，将业务逻辑代码放到Service层处理。</li><li>Mybatis：用到了与数据库打交道的层面，dao（mapper）层，放在所有的逻辑之后，处理与数据库的CRUD相关的操作。</li></ul><h2 id="开发项目的时候，需要完成一个功能模块"><a href="#开发项目的时候，需要完成一个功能模块" class="headerlink" title="开发项目的时候，需要完成一个功能模块"></a>开发项目的时候，需要完成一个功能模块</h2><ul><li>先写实体类entity，定义对象的属性，（可以参照数据库中表的字段来设置，数据库的设计应该在所有编码开始之前）。</li><li>写Mapper.xml（Mybatis），其中定义功能，对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。</li><li>写Mapper.java/Dao.java，将Mapper.xml中的操作按照id映射成Java函数。实际上就是Dao接口，二者选一即可。</li><li>写Service.java，为控制层提供服务，接受控制层的参数，完成相应的功能，并返回给控制层。</li><li>写Controller.java，连接页面请求和服务层，获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。</li><li>写JSP页面调用，请求哪些参数，需要获取什么数据。</li></ul><h2 id="面向对象——三层架构（表现层、业务层、持久层）"><a href="#面向对象——三层架构（表现层、业务层、持久层）" class="headerlink" title="面向对象——三层架构（表现层、业务层、持久层）"></a>面向对象——三层架构（表现层、业务层、持久层）</h2><p>三层架构：即表现层、业务层、持久层。</p><ul><li>持久层：采用DAO模式，建立实体类和数据库表映射（ORM映射）。也就是哪个类对应哪个表，哪个属性对应哪个列。持久层的目的就是，完成对象数据和关系数据的转换。</li><li>业务层：采用事务脚本模式。将一个业务中所有的操作封装成一个方法，同时保证方法中所有的数据库更新操作，即保证同时成功或同时失败。避免部分成功部分失败引起的数据混乱操作。</li><li>表现层：采用MVC模式。<br>M称为模型，也就是实体类。用于数据的封装和数据的传输。<br>V为视图，也就是GUI组件，用于数据的展示。<br>C为控制，也就是事件，用于流程的控制</li><li>业务层接口的设计原则：一个实体类一个接口，一次提交一个业务方法。业务方法的参数自表现层。</li><li>持久层接口的设计原则：一个实体类一个接口，一次数据库操作一个持久方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是微服务，SpringBoot和SpringCloud的关系</title>
      <link href="/microservice.html"/>
      <url>/microservice.html</url>
      
        <content type="html"><![CDATA[<p>今天上课老师提到了一个最近很火的概念，microservices(微服务), 下面是网上查询后一个简单的总结</p><a id="more"></a><h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><p>就目前而言对于微服务业界没有一个统一的,标准的定义.但通常而言,微服务是一种架构模式或者说是一种架构风格,它提倡单一应用程序划分为一组小的服务,每个服务在其独立的自己的进程中,服务之间相互协调,互相配合,为用户提供最终价值.服务之间采用轻量级的通信机制互相沟通(基于Http的Restful API)每个服务都围绕着具体的业务进行构建,并且能够被独立的部署到生产环境,类生产环境进行构建,可以有一个非常轻量级的集中式管理来协调这些服务,可以使用不同的语言来编写服务,也可以使用不同的数据存储.</p><h2 id="微服务与微服务架构"><a href="#微服务与微服务架构" class="headerlink" title="微服务与微服务架构?"></a>微服务与微服务架构?</h2><ul><li>微服务强调的是服务的大小,关注的是点,是具体解决某一个问题/提供落地对象服务的一个服务应用,</li><li>狭义的看,可以看做Eclipse中的一个个微服务工程.</li><li>微服务架构为一种架构模式.他提倡将单一应用程序分成一组小的服务,服务之间互相协调,互相配合,为用户提供最终价值.</li><li>每个服务运行在其独立的进程中,服务于服务间采用轻量级的通信机制互相协作(通常是Http 的Restful API) 每一个服务</li><li>都围绕着具体业务进行构建,并且能够被独立的部署到生产环境,类生产环境中.另外,应当尽量避免统一的,集中式的服务管理机制,</li><li>对具体的一个服务而言,应根据业务上下文,选择合适的语言,工具对其进行构建.</li></ul><h2 id="SpringCloud-是什么"><a href="#SpringCloud-是什么" class="headerlink" title="SpringCloud 是什么?"></a>SpringCloud 是什么?</h2><ul><li>基于SpringBoot提供了一套为微服务(microservices)解决方案,包括服务注册与发现,</li><li>配置中心,全链路监控,服务网关,负载均衡,熔断器等组件,除了基于NetFlix的开营组件做 高度抽象之外,还有一些选型中立了的开源组件.</li><li>分布式微服务架构下的一站式解决方案,是各个微服务架构落地技术的结合体,俗称为微服务全家桶.</li></ul><h2 id="SpringBoot和SpringCloud的关系和区别"><a href="#SpringBoot和SpringCloud的关系和区别" class="headerlink" title="SpringBoot和SpringCloud的关系和区别"></a>SpringBoot和SpringCloud的关系和区别</h2><ol><li>SpringBoot专注于方便的开发单个个体微服务</li><li>SpringCloud是关注于全局的微服务协调治理框架,它将SpringBoot开发的一个个单体微服务整合并管理起来.为各个微服务之间提供配置管理,服务发现,断路器,路由,微代理,事件总线,决策竞选,分布式会话等集成服务.</li><li>SpringBoot可以离开SpringCloud单独使用,而SpringCloud离不开SpringBoot</li></ol>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法2-数组</title>
      <link href="/Data-Structure-and-Algorithms-2-Array.html"/>
      <url>/Data-Structure-and-Algorithms-2-Array.html</url>
      
        <content type="html"><![CDATA[<p>数组是应用最广泛的数据存储结构。它被植入到大部分编程语言中。大部分数据结构都有最基本的四个操作：插入、删除、查找、修改。对于这四种操作每一种数据结构都有相应的算法。算法和数据结构因此就是非常紧密的相联系的。</p><a id="more"></a><h2 id="数组例子"><a href="#数组例子" class="headerlink" title="数组例子"></a>数组例子</h2><p>数组的每一个元素必须是连续，也就是中间没有洞。就是说第一个元素和第三个元素有值，但不允许第二个元素是空的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class Array &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        //创建一个数组</span><br><span class="line">        long[] arr;</span><br><span class="line">        arr = new long[100];</span><br><span class="line">        int nElems = 10;</span><br><span class="line">        int j;</span><br><span class="line">        long searchKey;</span><br><span class="line">        arr[0] = 99;</span><br><span class="line">        arr[1] = 11;</span><br><span class="line">        arr[2] = 22;</span><br><span class="line">        arr[3] = 33;</span><br><span class="line">        arr[4] = 55;</span><br><span class="line">        arr[5] = 66;</span><br><span class="line">        arr[6] = 44;</span><br><span class="line">        arr[7] = 77;</span><br><span class="line">        arr[8] = 23;</span><br><span class="line">        arr[9] = 88;</span><br><span class="line">        nElems = 10;</span><br><span class="line">        //输出前10位数组元素</span><br><span class="line">        for(j = 0; j &lt; nElems; j++)&#123;</span><br><span class="line">            System.out.print(arr[j] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        //查找数组的一个元素值为55的元素</span><br><span class="line">        searchKey = 55;</span><br><span class="line">        for(j = 0; j &lt; arr.length; j++)&#123;</span><br><span class="line">            if(arr[j] == searchKey)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(j == nElems)&#123;</span><br><span class="line">            System.out.println(&quot;Can&apos;t find the element&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;find the element &quot; + searchKey + &quot; at index &quot; + (j + 1) );</span><br><span class="line">        &#125;</span><br><span class="line">        //删除指定元素</span><br><span class="line">        searchKey = 66;</span><br><span class="line">        for(j = 0; j &lt; arr.length; j++)&#123;</span><br><span class="line">            if(arr[j] == searchKey)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int k = j; k &lt; nElems; k++)&#123;</span><br><span class="line">            arr[k] = arr[k+1];</span><br><span class="line">        &#125;</span><br><span class="line">        nElems--;</span><br><span class="line">        //输出删除后的数组</span><br><span class="line">        for(j = 0; j &lt; nElems; j++)&#123;</span><br><span class="line">            System.out.print(arr[j] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">99 11 22 33 55 66 44 77 23 88 </span><br><span class="line">find the element 55 at index 5</span><br><span class="line">99 11 22 33 55 44 77 23 88</span><br></pre></td></tr></table></figure><h2 id="将程序划分成类"><a href="#将程序划分成类" class="headerlink" title="将程序划分成类"></a>将程序划分成类</h2><p>上面的程序包含了一个很大的方法，通过将程序划分成类以后，并且将其中的方法模块化，这样程序看起来更加有条理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line">class ArrayMethod&#123;</span><br><span class="line">    private long[] arr;</span><br><span class="line">    private int nElems;</span><br><span class="line">    public ArrayMethod(int max)&#123;</span><br><span class="line">        arr = new long[max];</span><br><span class="line">        nElems = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    public void insert(long value)&#123;</span><br><span class="line">        arr[nElems] = value;</span><br><span class="line">        nElems++;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean find(long searchKey)&#123;</span><br><span class="line">        //查找数组的一个元素值为searchKey的元素</span><br><span class="line">        int j;</span><br><span class="line">        for(j = 0; j &lt; arr.length; j++)&#123;</span><br><span class="line">            if(arr[j] == searchKey)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(j == nElems)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;    </span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //删除指定元素</span><br><span class="line">    public boolean delete(long searchKey)&#123;</span><br><span class="line">        int j;</span><br><span class="line">        for(j = 0; j &lt; arr.length; j++)&#123;</span><br><span class="line">            if(arr[j] == searchKey)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int k = j; k &lt; nElems; k++)&#123;</span><br><span class="line">            arr[k] = arr[k+1];</span><br><span class="line">        &#125;</span><br><span class="line">        nElems--;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //输出数组</span><br><span class="line">    public void display()&#123;</span><br><span class="line">        //输出前10位数组元素</span><br><span class="line">        for(int j = 0; j &lt; nElems; j++)&#123;</span><br><span class="line">            System.out.print(arr[j] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class HighArray &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int maxSize = 100;</span><br><span class="line">        ArrayMethod arr = new ArrayMethod(maxSize);</span><br><span class="line">        arr.insert(99);</span><br><span class="line">        arr.insert(11);</span><br><span class="line">        arr.insert(22);</span><br><span class="line">        arr.insert(33);</span><br><span class="line">        arr.insert(55);</span><br><span class="line">        arr.insert(66);</span><br><span class="line">        arr.insert(44);</span><br><span class="line">        arr.insert(77);</span><br><span class="line">        arr.insert(23);</span><br><span class="line">        arr.insert(88);</span><br><span class="line">        //输出数组</span><br><span class="line">        arr.display();</span><br><span class="line">        //查找值为55的元素</span><br><span class="line">        long searchKey = 55;</span><br><span class="line">        if(arr.find(searchKey))&#123;</span><br><span class="line">            System.out.println(&quot;find the element &quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;Can&apos;t find the element&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //删除指定元素</span><br><span class="line">        searchKey = 22;</span><br><span class="line">        if(arr.delete(searchKey))&#123;</span><br><span class="line">            System.out.println(&quot;Delete the element successfully &quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;Can&apos;t find the element&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //输出删除元素后的数组</span><br><span class="line">        arr.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h2><p>假设一个数组，其中的数据项按关键字升序排列，即最小值在下标为0的单元上，每一个单元都比前一个单元的值大。这种数组被称为有序数组。</p><p>当向这种数组中插入数据项时，需要为插入操作找到正确的位置：刚好在稍小值的后面，稍大值的前面。然后将所有比待茶数据项的值向后移以便腾出空间。<br>将数据按顺序排列的好处之一就是可以通过二分法查找显著地提高查找速度。但缺点是降低了插入操作的速度。</p><h2 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h2><p>默认情况下是线性查找，线性查找和未经排序的数组的查找操作相似。</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>当使用二分查找时就体现有序数组的好处，这种查找比线性查找快很多，尤其是对大数组来说更为显著。<br>二分查找首先从要查找的范围确定一个中位数，然后比较要找的数和中位数的大小关系，确定更小的范围，依次递归，知道找到那个数。<br><img src="images/1909131.PNG" alt></p><h3 id="有序数组的二分搜索代码"><a href="#有序数组的二分搜索代码" class="headerlink" title="有序数组的二分搜索代码"></a>有序数组的二分搜索代码</h3><p>二分查找是将数组数据项范围不断对半分隔来查找特定的数据项。方法如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line">class ArrayMethod&#123;</span><br><span class="line">    private long[] arr;</span><br><span class="line">    private int nElems;</span><br><span class="line">    public ArrayMethod(int max)&#123;</span><br><span class="line">        arr = new long[max];</span><br><span class="line">        nElems = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    public void insert(long value)&#123;</span><br><span class="line">        arr[nElems] = value;</span><br><span class="line">        nElems++;</span><br><span class="line">    &#125;</span><br><span class="line">    //二分查找法</span><br><span class="line">    public int halfFind (long searchKey)&#123;</span><br><span class="line">        int lowerBound = 0;</span><br><span class="line">        int upperBound = nElems - 1;</span><br><span class="line">        int curIn;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            curIn = (lowerBound + upperBound)/2;</span><br><span class="line">            if(arr[curIn] == searchKey)&#123;</span><br><span class="line">                return curIn;</span><br><span class="line">            &#125;else if(lowerBound &gt;= upperBound)&#123;</span><br><span class="line">                return nElems;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(arr[curIn] &gt; searchKey)&#123;</span><br><span class="line">                    upperBound = curIn - 1;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    lowerBound = curIn + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int size()&#123;</span><br><span class="line">        return nElems;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean find(long searchKey)&#123;</span><br><span class="line">        //查找数组的一个元素值为searchKey的元素</span><br><span class="line">        int j;</span><br><span class="line">        for(j = 0; j &lt; arr.length; j++)&#123;</span><br><span class="line">            if(arr[j] == searchKey)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(j == nElems)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;    </span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //删除指定元素</span><br><span class="line">    public boolean delete(long searchKey)&#123;</span><br><span class="line">        int j;</span><br><span class="line">        for(j = 0; j &lt; arr.length; j++)&#123;</span><br><span class="line">            if(arr[j] == searchKey)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int k = j; k &lt; nElems; k++)&#123;</span><br><span class="line">            arr[k] = arr[k+1];</span><br><span class="line">        &#125;</span><br><span class="line">        nElems--;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //输出数组</span><br><span class="line">    public void display()&#123;</span><br><span class="line">        //输出前10位数组元素</span><br><span class="line">        for(int j = 0; j &lt; nElems; j++)&#123;</span><br><span class="line">            System.out.print(arr[j] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class HighArray &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int maxSize = 100;</span><br><span class="line">        ArrayMethod arr = new ArrayMethod(maxSize);</span><br><span class="line">        arr.insert(99);</span><br><span class="line">        arr.insert(11);</span><br><span class="line">        arr.insert(22);</span><br><span class="line">        arr.insert(33);</span><br><span class="line">        arr.insert(55);</span><br><span class="line">        arr.insert(66);</span><br><span class="line">        arr.insert(44);</span><br><span class="line">        arr.insert(77);</span><br><span class="line">        arr.insert(23);</span><br><span class="line">        arr.insert(88);</span><br><span class="line">        //输出数组</span><br><span class="line">        arr.display();</span><br><span class="line">        //查找值为55的元素</span><br><span class="line">        long searchKey = 35;</span><br><span class="line">//        if(arr.find(searchKey))&#123;</span><br><span class="line">//            System.out.println(&quot;find the element &quot;);</span><br><span class="line">//        &#125;else&#123;</span><br><span class="line">//            System.out.println(&quot;Can&apos;t find the element&quot;);</span><br><span class="line">//        &#125;</span><br><span class="line">        //二分法查找</span><br><span class="line">        if(arr.halfFind(searchKey) != arr.size())&#123;</span><br><span class="line">            System.out.println(&quot;Find it&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;Can&apos;t find it&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">//        //删除指定元素</span><br><span class="line">//        searchKey = 22;</span><br><span class="line">//        if(arr.delete(searchKey))&#123;</span><br><span class="line">//            System.out.println(&quot;Delete the element successfully &quot;);</span><br><span class="line">//        &#125;else&#123;</span><br><span class="line">//            System.out.println(&quot;Can&apos;t find the element&quot;);</span><br><span class="line">//        &#125;</span><br><span class="line">        //输出删除元素后的数组</span><br><span class="line">        arr.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有序数组的优点"><a href="#有序数组的优点" class="headerlink" title="有序数组的优点"></a>有序数组的优点</h3><p>使用有序数组最主要的好处是查找的速度比无序数组快多了。不好的方面是在插入操作中由于所有靠后的数据都需要移动以腾开空间，所以速度较慢。有序数组和无序数组中的删除操作都很慢，这是因为数据项必须向前移动来填补已删除数据项的洞。有序数组在查找频繁的情况下十分有用，但若是插入和删除较为频繁时，则无法高效工作。</p><h2 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h2><p>计算机科学中评价算法效率的方法称为大O表示法。比较算法时候通常会说”算法A比算法B快2倍”，这种说法意义不大。因为数据项的变化会对排序造成一定很大影响。有可能数据项增加50%，算法A就比B快了3倍，或者可能只有一半的数据项，A和B的速度是相同的。</p><h3 id="无序数组的插入：常数"><a href="#无序数组的插入：常数" class="headerlink" title="无序数组的插入：常数"></a>无序数组的插入：常数</h3><p>无序数组的插入是我们到现在为止所见过的算法中唯一一个与数组项个数无关的算法。新数据项总被放在下一个有空的地方,a[nElems]，然后nElems增加。无论数组中的数据项个数N有多大，一次插入总是用相同的时间。我们可以说向一个无序数组中插入一个数据项的时间T是一个常数K<br>T=K<br>在现实情况中，插入所需的实际时间与以下这些因素有关：微处理器，编译程序生成程序代码的效率，等等。</p><h3 id="线性查找：与N成正比"><a href="#线性查找：与N成正比" class="headerlink" title="线性查找：与N成正比"></a>线性查找：与N成正比</h3><p>在数组数据项的线性查找中，我们已经发现寻找特定数据项所需的比较平均次数为数据项总数的一半。因此设N为数据项总数，搜索时间T与N的一半成正比：T=K*N/2</p><p>同插入一样，若要得到方程中K的值，首先需要对某个N值的查找进行计时，然后用T来计算K。当得到K后，便可以对任意N的值来计算T。将2并入K可以得到更方便的公式，新K值等于原先的K除以2即: T=KN</p><p>这个方程说明平均线性查找时间与数组的大小成正比。即如果一个数组增大两倍，则所花费的查找时间也会相应地增长两倍。</p><h3 id="二分查找-与log-N-成正比"><a href="#二分查找-与log-N-成正比" class="headerlink" title="二分查找:与log(N)成正比"></a>二分查找:与log(N)成正比</h3><p>同样，我们可以为二分查找指定出一个与T和N有关的公式:T=Klog2(N)</p><p>实际上，由于所有的对数和其他对数成比例(比如从底数2转换到底数为10需乘以3.322)，也可以将这个为常数的底数也并入K。由此不必指定底数: T=Klog(N), 不要常数</p><p>大O表示法同上面的公式比较类似，但它省去了常数K。当比较算法时，并不在乎具体的微处理器或编译器；真正需要比较的是对应不同的N值，T是如何变化的，而不是具体的数字，因此不需要常数。</p><p>大O表示法使用大写字母O，可以认为其含义是order of(大约是)。我们可以使用大O表示法来描述线性查找使用了O(N)级时间，二分查找使用了O(logN)级时间。向一个无序数组中的插入使用了O(1)，或常数级时间。</p><p>下表总结的是讨论过的算法的运行时间<br><img src="images/1909132.PNG" alt><br>大O表示法的实质并不是对运行时间给出实际值，而是表达了运行时间是如何受数据项个数所影响的。除了实际安装后真正去测量一次算法的运行时间之外，这可能是对算法进行比较的最有意义的方法了。</p><h2 id="为什么不用数组表示一切？"><a href="#为什么不用数组表示一切？" class="headerlink" title="为什么不用数组表示一切？"></a>为什么不用数组表示一切？</h2><p>仅使用数组似乎就可以完成所有工作，为什么不用它们来进行所有数据存储呢？我们已经见到了许多关于数组的缺点。在一个无序数组中可以很快进行插入(O(1))，但是查找却要花费较慢的O(N)时间。在一个有序数组中可以查找得很快，用O(logN)的时间，但插入却花费了O(N)时间。对于这两种数组而言，由于平均半数的数据项为了填补”空洞”必须移动，所以删除操作平均需要O(N)时间。</p><p>如果有一种数据结构进行任何如插入、删除和查找的操作都很快(理想的O(1)或是O(logN)时间)，那就好了。后面会介绍类似的数组，但这是以程序的复杂度为代价的。</p><p>另外数组被创建后，占用内存长度是确定的，无法进行修改，这样的话，如果创建的长度过大，但是实际需要的很少就会造成内存浪费，如果创建的长度过小，就会造成溢出，无法弹性使用。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法1-综述</title>
      <link href="/Data-Structure-and-Algorithms-1-Overview.html"/>
      <url>/Data-Structure-and-Algorithms-1-Overview.html</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的逻辑结构和数据的物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构。</p><a id="more"></a><p>数据的逻辑结构和物理结构是数据结构的两个密切相关的方面，同一逻辑结构可以对应不同的存储结构。算法的设计取决于数据的逻辑结构，而算法的实现依赖于指定的存储结构。</p><p>数据结构的研究内容是构造复杂软件系统的基础，它的核心技术是分解与抽象。通过分解可以划分出数据的3个层次；再通过抽象，舍弃数据元素的具体内容，就得到逻辑结构。类似地，通过分解将处理要求划分成各种功能，再通过抽象舍弃实现细节，就得到运算的定义。上述两个方面的结合可以将问题变换为数据结构。这是一个从具体（即具体问题）到抽象（即数据结构）的过程。然后，通过增加对实现细节的考虑进一步得到存储结构和实现运算，从而完成设计任务。这是一个从抽象（即数据结构）到具体（即具体实现）的过程。</p><h2 id="常用的数据结构"><a href="#常用的数据结构" class="headerlink" title="常用的数据结构"></a>常用的数据结构</h2><p>数组(Array)<br>数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。数组可以说是最基本的数据结构，在各种编程语言中都有对应。一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等。数组还可以有一维、二维以及多维等表现形式。   </p><p>栈( Stack)<br>栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。栈按照后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。   </p><p>队列(Queue)<br>队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列。   </p><p>链表( Linked List)<br>链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。   </p><p>树( Tree)<br>树是典型的非线性结构，它是包括，2个结点的有穷集合K。在树结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有聊个后继结点，m≥0。   </p><p>图(Graph)<br>图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。   </p><p>堆(Heap)<br>堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构。   </p><p>散列表(Hash)<br>散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。   </p><h2 id="数据结构和算法起到的作用"><a href="#数据结构和算法起到的作用" class="headerlink" title="数据结构和算法起到的作用"></a>数据结构和算法起到的作用</h2><p>数据结构是对计算机内存中(有时在磁盘中)的数据的一种安排。数据结构是存放数据物理结构在逻辑上的形式体现，常见的数据结构有数组、链表、栈、二叉树、哈希表等等。算法对这些结构中的数据进行各种处理，例如，查找一条特殊的数据项或对数据进行排序。数据结构和处理技术(即算法)可以解决如下问题</p><h3 id="现实世界数据的存储"><a href="#现实世界数据的存储" class="headerlink" title="现实世界数据的存储"></a>现实世界数据的存储</h3><p>现实世界中有很多信息，有些信息是强相关的，比如一个人的身高、体重、年龄等等，这些信息不是随便放的，就像你不会把厨房里的锅放在卧室里面，铲子放到卫生间里面，我们需要一个统一地方存放这些信息，在物理上就是放在存储空间里面，比如硬盘或内存，在逻辑形式上就是上面提到的各种数据结构，比如数组、链表等等。</p><h3 id="现实世界的建模"><a href="#现实世界的建模" class="headerlink" title="现实世界的建模"></a>现实世界的建模</h3><p>一些数据具有很强的实用性，就是与相应的事件对应起来，比如队列可以模拟顾客在银行中排队等待。</p><h2 id="数据结构的概述"><a href="#数据结构的概述" class="headerlink" title="数据结构的概述"></a>数据结构的概述</h2><p>数据结构与算法就是讨论这些数据结构的实现以及在数据结构上进行一些操作。<br>下面列出了一些数据结构优点和缺点</p><ul><li>数组　　　　　　<br>插入快，如果知道下标，可以非常快地存取　　　　　　　　　　 查找慢，删除慢，大小固定</li><li>有序数组    　　<br>比无序的数组查找快    　　　　　　　　　　　　　　　　　　　 删除和插入慢，大小固定</li><li>栈　　　　　　<br>提供后进先出方式的存取　　　　　　　　　　　　　　　　　　 存取其他项很慢</li><li>队列    　　　　<br>提供先进先出方式的存取　　　　　　　　　　　　　　　　　　 存取其他项很慢</li><li>链表    　　　　<br>插入快，删除快    　　　　　　　　　　　　　　　　　　　　　 查找慢</li><li>二叉树    　　　　<br>查找、插入、删除都快(如果树保持平衡)    　　　　　　　　　删除算法复杂</li><li>红-黑树    　　　　<br>查找、插入、删除都快，树总是平衡的    　　　　　　　　　　　 算法复杂</li><li>2-3-4树    　　　<br>查找、插入、删除都快，树总是平衡的，树对磁盘存储有用　　　 算法复杂</li><li>哈希表    　　　　<br>如果关键字已知则存取极快，插入快    　　　　　　　　　　　　删除慢，如果不知道关键字则存取很慢，对存储空间使用不充分</li><li>堆    　　　　　　<br>插入、删除快，对最大数据项的存取很快    　　　　　　　　　　对其他数据项存取慢</li><li>图    　　　　　　<br>对现实世界建模    　　　　　　　　　　　　有些算法慢且复杂</li></ul><p>数据结构除了数组之外都可以被认为是抽象数据结构(ADT)，主要是数据的存储物理结构与逻辑结构并非拓扑结构上一致。</p><h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><p>数据结构研究的内容：就是如何按一定的逻辑结构，把数据组织起来，并选择适当的存储表示方法把逻辑结构组织好的数据存储到计算机的存储器里。研究的目的是为了更有效的处理数据，提高数据运算效率。数据的运算是定义在数据的逻辑结构上，但运算的具体实现要在存储结构上进行。一般有以下几种常用运算：<br>(1)检索。检索就是在数据结构里查找满足一定条件的节点。一般是给定一个某字段的值，找具有该字段值的节点。<br>(2)插入。往数据结构晕增加新的节点。<br>(3)删除。把指定的结点从数据结构中去掉。<br>(4)更新。改变指定节点的一个或多个字段的值。<br>(5)排序。把节点按某种指定的顺序重新排列。例如递增或递减。</p><h2 id="过程性语言的问题"><a href="#过程性语言的问题" class="headerlink" title="过程性语言的问题"></a>过程性语言的问题</h2><p>面向对象编程语言的产生是由于发现过程性语言在处理大小的复杂问题时有些力不从心。具体是哪些问题呢？<br>有两类问题：一是程序与现实世界缺乏对应关系，二是程序内部的结果出现了问题。</p><ul><li>对现实世界建模的无能为力<br>使用过程语言对现实世界问题进行抽象即概念化十分困难：方法执行任务，而后数据存储信息，但是现实世界中的事物是对二者同时进行操作。</li><li>粗糙的组织结构<br>解决程序的内部组织结构是一个更微妙而且事关重大的问题。面向过程的程序被划分为一个个方法，这种基于方法组织形式的一个巨大问题是它仅仅考虑了方法，而没有重视数据。当不得不面对数据时，它没有太多的选择。简而言之，数据可以是一个特定的方法的局部量，也可以是所有方法都可以存取的全局量，就是无法规定一个变量只允许某些方法存取而不允许另一些方法存取。</li></ul><h2 id="Java数据结构的类库"><a href="#Java数据结构的类库" class="headerlink" title="Java数据结构的类库"></a>Java数据结构的类库</h2><p>Java.util包中含有诸如向量(一个可扩充的数组)、栈、库和哈希表等类型的数据结构。这些数据结构已经被实现并提供了相关操作方法。但是我们仍然需要学习别的数据结构，提供的数据结构是不够的。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>有了IP为什么还要有MAC</title>
      <link href="/IP-and-MAC.html"/>
      <url>/IP-and-MAC.html</url>
      
        <content type="html"><![CDATA[<h2 id="为什么有了MAC地址，还需要IP地址？"><a href="#为什么有了MAC地址，还需要IP地址？" class="headerlink" title="为什么有了MAC地址，还需要IP地址？"></a>为什么有了MAC地址，还需要IP地址？</h2><p>Mac地址是物理层的地址，但它是以太网的物理地址。互联网是由很多异构的物理网络通过路由器联接起来的，不同的物理网络，寻址方式很可能是不同的，可能根本不使用MAC地址。如果只用MAC地址，不同的物理网络进行寻址时会非常困难，因为彼此的数据帧格式不一样相互不兼容。所以，我们需要一个公用的标准去遵循，这个标准就是IP地址。这里也体现了计算机网络中分层的好处，让你不再去考虑两个不同的实现方式的物理网之间如何通讯。它屏蔽了下层的东西，让所有的网络都建立在IP地址之上，整个互联网在第三层看起来就像是一个巨大的IP网，而不用去管底层物理网络是什么。</p><a id="more"></a><h2 id="只有IP地址，不要MAC地址？"><a href="#只有IP地址，不要MAC地址？" class="headerlink" title="只有IP地址，不要MAC地址？"></a>只有IP地址，不要MAC地址？</h2><p>1.IP地址是有限的，根本就不够用，不可能为全球每台计算机都分配一个IP地址。<br>2.MAC地址全球固定而且唯一的，有了MAC地址就能准确的找到你的计算。<br>3.如果IP层抢了第二层的饭碗，你就不得不考虑第二层的很多东西了，这就让IP层的实现变得十分困难。</p><p>IP地址就不用说了也就是一个逻辑地址，至于MAC地址的定义就是一个设备的物理地址。好了，为什么有了IP还要有MAC？在网上看了看了很久每一个能回答好点的，最好的也就是有了IP可以屏蔽掉各个链路的差异。拿实际来讲，若是没有MAC地址，就用IP地址来充当MAC。首先，有个问题要说清楚的是IP地址肯定是在不停的变化的，比如你从A走到了B，A和B有不同的网络，那么你在用手机上网的时候，IP地址在不停的变化，那么就说这个数据，若是下雨天什么情况的话，当你在A点的时候玩亡者农药，数据发出去了，由于天气原因，手机显示420ms导致数据传输不过，这时，你换到了B点，重新获得了IP地址，wo吼，恭喜您成功解锁由于接收不到数据被举报，而导致制裁！为什么？因为IP地址换了，所以之前的数据一脸懵逼不知道转送给谁，若是某某人链接到了之前的IP（你之前链接的IP），那就是传送给了那个某某人了。所以没有MAC只是有IP，不仅有接收不到数据的可能，同时还极大的消耗CPU的资源，这就不太好了。</p><p>那有了MAC为什么还要有IP地址？在很久很久以前，那是没有路由，交换机的时代，若是两台电脑要通信，可以一根线直接连接就ok了，比如电话。若是有多台怎么通信？？这时就出现了集线器，只需要在消息里面附加上对方的MAC地址就可以了，集线器就会广播消息，每个设备接收消息并对照自己的MAC，是不是一样的，若是一样的收下。这样的广播比较麻烦就出现了交换机，交换机会把MAC地址与某一个端口一一对应，比如主机A要与主机B通信，主机A发送附带主机B的MAC地址的消息发送到交换机，交换机根据对应表查找到相应的端口号，并把消息发送到B，这就比如，你坐公交一样，各个站点的路线信息就相当于集线器告诉你公交是怎么走的。那么也就是意味着交换机与各个站牌中的信息一样要记录所有与它连接设备的MAC地址，那么问题来了，比如A是中国某一地区的主机，B是台湾的某一地区的主机，假设A直接连接到中国这一个大子网，B直接连接到台湾这一个大子网，两个大子网的链接是用交换机相连接的，A要与B通信，由于交换机记录与它链接的设备的地址，中国这一个大子网的交换机只会记录台湾的一个交换机的MAC地址，所以A附带B的MAC地址的信息，无法通过中国这一个大子网的换交换机的，除非A和B在同一个子网中。所以就出现 了IP这个逻辑地址来解决以上不能通信的问题。</p><p>可能会想到的是，把MAC地址像IP地址一样来对待，用一个交换机来构成多个子MAC进而构成多个子网，那问题是MAC地址要被有规则的被分配的话，那由谁来管理，再说MAC是厂商制造的，那肯定由厂商自己决定MAC地址是多少，那么多的选择方式。当然MAC是唯一的了。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二层交换机与三层交换机区别</title>
      <link href="/Differences-between-Layer2-Switches-and-Layer3-Switches.html"/>
      <url>/Differences-between-Layer2-Switches-and-Layer3-Switches.html</url>
      
        <content type="html"><![CDATA[<p>我们习惯说，在二层网络环境中相同VLAN（Virtual Local Area Network）之间可以通信，不同vlan之间不可以通信，如果想通信必须借助三层设备，所以说三层交换机必须要做的事情是路由转发，但是二、三层交换机具体有什么区别呢？</p><a id="more"></a><h2 id="二层交换机"><a href="#二层交换机" class="headerlink" title="二层交换机"></a>二层交换机</h2><p>二层交换机工作于OSI模型的第2层(数据链路层)，故而称为二层交换机。二层交换技术发展比较成熟，二层交换机属数据链路层设备，可以识别数据包中的MAC地址信息，根据MAC地址进行转发，并将这些MAC地址与对应的端口记录在自己内部的一个地址表中。具体的工作流程如下：</p><ol><li><p>当交换机从某个端口收到一个数据包，它先读取包头中的源MAC地址，这样它就知道源MAC地址的机器是连在哪个端口上的；</p></li><li><p>再去读取包头中的目的MAC地址，并在地址表中查找相应的端口；</p></li><li><p>如表中有与这目的MAC地址对应的端口，把数据包直接复制到这端口上；</p></li><li><p>如表中找不到相应的端口则把数据包广播到所有端口上，当目的机器对源机器回应时，交换机又可以学习一目的MAC地址与哪个端口对应，在下次传送数据时就不再需要对所有端口进行广播了。</p></li></ol><p>不断的循环这个过程，对于全网的MAC地址信息都可以学习到，二层交换机就是这样建立和维护它自己的地址表。</p><p>二层交换技术从网桥发展到VLAN（虚拟局域网），在局域网建设和改造中得到了广泛的应用。第二层交换技术是工作在OSI七层网络模型中的第二层，即数据链路层。它按照所接收到数据包的目的MAC地址来进行转发，对于网络层或者高层协议来说是透明的。它不处理网络层的IP地址，不处理高层协议的诸如TCP、UDP的端口地址，它只需要数据包的物理地址即MAC地址，数据交换是靠硬件来实现的，其速度相当快，这是二层交换的一个显著的优点。但是，它不能处理不同IP子网之间的数据交换。传统的路由器可以处理大量的跨越IP子网的数据包，但是它的转发效率比二层低，因此要想利用二层转发效率高这一优点，又要处理三层IP数据包，三层交换技术就诞生了。</p><h2 id="三层交换机"><a href="#三层交换机" class="headerlink" title="三层交换机"></a>三层交换机</h2><h3 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h3><p>传统交换技术是在OSI网络标准模型第二层–数据链路层进行操作的，而三层交换技术是在网络模型中的第三层实现了数据包的高速转发，既可实现网络路由功能，又可根据不同网络状况做到最优网络性能。</p><p>二层交换技术从网桥发展到VLAN（虚拟局域网），在局域网建设和改造中得到了广泛的应用。第二层交换技术是工作在OSI七层网络模型中的第二层，即数据链路层。它按照所接收到数据包的目的MAC地址来进行转发，对于网络层或者高层协议来说是透明的。</p><p>它不处理网络层的IP地址，不处理高层协议的诸如TCP、UDP的端口地址，它只需要数据包的物理地址即MAC地址，数据交换是靠硬件来实现的，其速度相当快，这是二层交换的一个显著的优点。但是，它不能处理不同IP子网之间的数据交换。传统的路由器可以处理大量的跨越IP子网的数据包，但是它的转发效率比二层低，因此要想利用二层转发效率高这一优点，又要处理三层IP数据包，三层交换技术就诞生了。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>三层交换（也称多层交换技术，或IP交换技术）是相对于传统交换概念而提出的。众所周知，传统的交换技术是在OSI网络标准模型中的第二层——数据链路层进行操作的，而三层交换技术是在网络模型中的第三层实现了数据包的高速转发。三层交换机就是具有部分路由器功能的交换机，三层交换机的最重要目的是加快大型局域网内部的数据交换，所具有的路由功能也是为这目的服务的，能够做到一次路由，多次转发。对于数据包转发等规律性的过程由硬件高速实现，而像路由信息更新、路由表维护、路由计算、路由确定等功能，由软件实现。简单地说，三层交换技术就是：二层交换技术＋三层转发技术。<br><img src="images/1909091.PNG" alt><br>三层交换机就是具有部分路由器功能的交换机。</p><p>三层交换机的最重要目的是加快大型局域网内部的数据交换，所具有的路由功能也是为这目的服务的，能够做到一次路由，多次转发。对于数据包转发等规律性的过程由硬件高速实现，而像路由信息更新、路由表维护、路由计算、路由确定等功能，由软件实现。三层交换技术就是二层交换技术+三层转发技术。</p><p>三层交换技术的出现，解决了局域网中网段划分之后，网段中子网必须依赖路由器进行管理的局面，解决了传统路由器低速、复杂所造成的网络瓶颈问题。<br><img src="images/1909092.PNG" alt><br>交换机在判断出目的IP不是自己的时候是不是一定就去查看路由表呢 ？不是，这个就是交换机的关键所在了，交换机此时不会查看路由表，不会查看arp表，不会查看mac地址表；那交换机会查看什么表？</p><p>交换机此时会查看自己集成在ASIC硬件转发卡中的硬件转发表，那这个硬件转发表都包含了什么内容呢？</p><ul><li>当第一个包过来的时候，发现硬件转发表并没有什么表项，所以此时必须将数据包交由路由进程处理，一旦交由cpu处理，必然会消耗cpu资源，此时会查看路由表，然后发现此IP地址和自己是直连的，此时就去查看arp找出此地址对应的mac地址，就可以转发出去了</li><li>在决定转发出去过程中，交换机至少会做三件事情，一，修改IP包头的ttl值；二，修改原mac地址，改成自己出接口mac地址；三，建立交换机硬件转发表，包括目的IP地址，目的IP地址（下一跳）对应的mac地址，mac地址对应的vlan，以及对应的端口（这个每个厂家有自己的理解）</li><li>这样当一下包过来的时候，交换机就会查看硬件转发表直接转发而不会在经过路由表的查询了，也即是交换机的一次路由，多次交换机原理。</li></ul><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p>假设两个使用IP协议的站点A、B通过第三层交换机进行通信，发送站点A在开始发送时，把自己的IP地址与B站的IP地址比较，判断B站是否与自己在同一子网内。若目的站B与发送站A在同一子网内，则进行二层的转发。若两个站点不在同一子网内，如发送站A要与目的站B通信，发送站A要向“缺省网关”发出ARP(地址解析)封包，而“缺省网关”的IP地址其实是三层交换机的三层交换模块。</p><p>当发送站A对“缺省网关”的IP地址广播出一个ARP请求时，如果三层交换模块在以前的通信过程中已经知道B站的MAC地址，则向发送站A回复B的MAC地址。否则三层交换模块根据路由信息向B站广播一个ARP请求，B站得到此ARP请求后向三层交换模块回复其MAC地址，三层交换模块保存此地址并回复给发送站A,同时将B站的MAC地址发送到二层交换引擎的MAC地址表中。</p><p>从这以后，当A向B发送的数据包便全部交给二层交换处理，信息得以高速交换。由于仅仅在路由过程中才需要三层处理，绝大部分数据都通过二层交换转发，因此三层交换机的速度很快，接近二层交换机的速度，同时比相同路由器的价格低很多。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单点来说，二层和三层交换机最基本的区别就是，三层交换机具有路由功能，可以看作是网络层的设备（当然，也可以做二层用）。二层交换机是数据链路层的设备，不具备路由功能。</p><p>总之，二层交换机用于小型的局域网络。这个就不用多言了，在小型局域网中，广播包影响不大，二层交换机的快速交换功能、多个接入端口和低廉价格为小型网络用户提供了很完善的解决方案。</p><p>而三层交换机的最重要的功能是加快大型局域网络内部的数据的快速转发，加入路由功能也是为这个目的服务的。如果把大型网络按照部门，地域等等因素划分成一个个小局域网，这将导致大量的网际互访，单纯的使用二层交换机不能实现网际互访；如单纯的使用路由器，由于接口数量有限和路由转发速度慢，将限制网络的速度和网络规模，采用具有路由功能的快速转发的三层交换机就成为首选。</p><p>一般来说，在内网数据流量大，要求快速转发响应的网络中，如全部由三层交换机来做这个工作，会造成三层交换机负担过重，响应速度受影响，将网间的路由交由路由器去完成，充分发挥不同设备的优点，不失为一种好的组网策略，当然，前提是你的腰包很鼓，不然就退而求其次，让三层交换机也兼为网际互连。</p><p>传统交换技术是在OSI网络标准模型第二层–数据链路层进行操作的，而三层交换技术是在网络模型中的第三层实现了数据包的高速转发，既可实现网络路由功能，又可根据不同网络状况做到最优网络性能。</p><h2 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h2><p>二层交换机和三层交换机都属于以太网交换机。</p><p>以太网交换机是基于以太网传输数据的交换机，以太网采用共享总线型传输媒体方式的局域网。以太网交换机的结构是每个端口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。</p><p>以太网交换机应用最为普遍，价格也较便宜，档次齐全。因此，应用领域非常广泛，在大大小小的局域网都可以见到它们的踪影。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP and UDP</title>
      <link href="/TCP-and-UDP.html"/>
      <url>/TCP-and-UDP.html</url>
      
        <content type="html"><![CDATA[<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP（User Data Protocol，用户数据报协议）它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去。</p><a id="more"></a><p>UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。比如，我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。例如，在默认状态下，一次“ping”操作发送4个数据包。发送的数据包数量是4包，收到的也是4包（因为对方主机收到后会发回一个确认收到的数据包）。这充分说明了UDP协议是面向非连接的协议，没有建立连接的过程。正因为UDP协议没有连接的过程，所以它的通信效果高；但也正因为如此，它的可靠性不如TCP协议高。QQ就使用UDP发消息，因此有时会出现收不到消息的情况。</p><p>我们来看一下 UDP 的包头<br><img src="images/1909081.PNG" alt><br>由上图可以看出，UDP 除了端口号，基本啥都没有了。如果没有这两个端口号，数据就不知道该发给哪个应用。<br>所以 UDP 特别简单，有如下三个特点</p><ol><li>沟通简单，不需要大量的数据结构，处理逻辑和包头字段</li><li>轻信他人。它不会建立连接，但是会监听这个地方，谁都可以传给它数据，它也可以传给任何人数据，甚至可以同时传给多个人数据。</li><li>愣头青，做事不懂变通。不会根据网络的情况进行拥塞控制，无论是否丢包，它该怎么发还是怎么发</li></ol><p>因为 UDP 是”小孩子”，所以处理的是一些没那么难的项目，并且就算失败的也能接收。基于这些特点的话，UDP 可以使用在如下场景中</p><ol><li>需要资源少，网络情况稳定的内网，或者对于丢包不敏感的应用，比如 DHCP 就是基于 UDP 协议的。</li><li>不需要一对一沟通，建立连接，而是可以广播的应用。因为它不面向连接，所以可以做到一对多，承担广播或者多播的协议。</li><li>需要处理速度快，可以容忍丢包，但是即使网络拥塞，也毫不退缩，一往无前的时候</li></ol><h3 id="UDP-的几个例子"><a href="#UDP-的几个例子" class="headerlink" title="UDP 的几个例子"></a>UDP 的几个例子</h3><ol><li>直播。直播对实时性的要求比较高，宁可丢包，也不要卡顿的，所以很多直播应用都基于 UDP 实现了自己的视频传输协议</li><li>实时游戏。游戏的特点也是实时性比较高，在这种情况下，采用自定义的可靠的 UDP 协议，自定义重传策略，能够把产生的延迟降到最低，减少网络问题对游戏造成的影响</li><li>物联网。一方面，物联网领域中断资源少，很可能只是个很小的嵌入式系统，而维护 TCP 协议的代价太大了；另一方面，物联网对实时性的要求也特别高。比如 Google 旗下的 Nest 简历 Thread Group，推出了物联网通信协议 Thread，就是基于 UDP 协议的</li></ol><h3 id="UDP的优点"><a href="#UDP的优点" class="headerlink" title="UDP的优点"></a>UDP的优点</h3><p>快，比TCP稍安全<br>    UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，udp是一个无状态的传输协议，所以他在传输数据时非常快。M没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。UDP也是无法避免攻击的，比如：UDP flood攻击。。。</p><h3 id="UDP的缺点"><a href="#UDP的缺点" class="headerlink" title="UDP的缺点"></a>UDP的缺点</h3><p>不可靠，不稳定<br>    因为UDP没有TCP的那些可靠机制，在网络质量不好时很容易丢包。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP（Transmission Control Protocol，传输控制协议）<br>首先是 TCP 的包头格式<br><img src="images/1909082.PNG" alt></p><ol><li>首先，源端口和目标端口是不可少的。</li><li>接下来是包的序号。主要是为了解决乱序问题。不编好号怎么知道哪个先来，哪个后到</li><li>确认序号。发出去的包应该有确认，这样能知道对方是否收到，如果没收到就应该重新发送，这个解决的是不丢包的问题</li><li>状态位。SYN 是发起一个链接，ACK 是回复，RST 是重新连接，FIN 是结束连接。因为 TCP 是面向连接的，因此需要双方维护连接的状态，这些状态位的包会引起双方的状态变更<br>窗口大小，TCP 要做流量控制，需要通信双方各声明一个窗口，标识自己当前的处理能力。</li></ol><p>通过对 TCP 头的解析，我们知道要掌握 TCP 协议，应该重点关注以下问题：</p><ul><li>顺序问题</li><li>丢包问题</li><li>连接维护</li><li>流量控制</li><li>拥塞控制</li></ul><h3 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h3><p>所有的问题，首先都要建立连接，所以首先是连接维护的问题</p><p>TCP 的建立连接称为三次握手，可以简单理解为下面这种情况</p><blockquote><p>A：您好，我是 A<br>    B：您好 A，我是 B<br>    A：您好 B</p></blockquote><p>对于 A 来说它发出请求，并收到了 B 的响应，对于 B 来说它响应了 A 的请求，并且也接收到了响应。</p><blockquote><p>TCP 的三次握手除了建立连接外，主要还是为了沟通 TCP 包的序号问题。</p></blockquote><p>A 告诉 B，我发起的包的序号是从哪个号开始的，B 同样也告诉 A，B 发起的 包的序号是从哪个号开始的。<br>双方建立连接之后需要共同维护一个状态机，在建立连接的过程中，双方的状态变化时序图如下所示<br><img src="images/1909083.PNG" alt><br>这是网上经常见到的一张图，刚开始的时候，客户端和服务器都处于 CLOSED 状态，先是服务端主动监听某个端口，处于 LISTEN 状态。然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态。服务端接收了发起的连接，返回 SYN，并且 ACK ( 确认 ) 客户端的 SYN，之后处于 SYN-SENT 状态。客户端接收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后就处于 ESTAVLISHED 状态，因为它一发一收成功了。服务端收到 ACK 的 ACK 之后，也处于 ESTABLISHED 状态，因为它也一发一收了。</p><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><p>说完建立连接，再说下断开连接，也被称为四次挥手，可以简单理解如下</p><blockquote><p>A：B 啊，我不想玩了<br>    B：哦，你不想玩了啊，我知道了<br>    这个时候，只是 A 不想玩了，即不再发送数据，但是 B 可能还有未发送完的数据，所以需要等待 B 也主动关闭。<br>    B：A 啊，好吧，我也不玩了，拜拜<br>    A：好的，拜拜</p></blockquote><p>这样整个连接就关闭了，当然上面只是正常的状态，也有些非正常的状态（比如 A 说完不玩了，直接跑路，B 发起的结束得不到 A 的回答，不知道该怎么办或则 B 直接跑路 A 不知道该怎么办），TCP 协议专门设计了几个状态来处理这些非正常状态<br><img src="images/1909084.PNG" alt><br>断开的时候，当 A 说不玩了，就进入 FIN_WAIT_1 的状态，B 收到 A 不玩了的消息后，进入 CLOSE_WAIT 的状态。</p><p>A 收到 B 说知道了，就进入 FIN_WAIT_2 的状态，如果 B 直接跑路，则 A 永远处与这个状态。TCP 协议里面并没有对这个状态的处理，但 Linux 有，可以调整 tcp_fin_timeout 这个参数，设置一个超时时间。</p><p>如果 B 没有跑路，A 接收到 B 的不玩了请求之后，从 FIN_WAIT_2 状态结束，按说 A 可以跑路了，但是如果 B 没有接收到 A 跑路的 ACK 呢，就再也接收不到了，所以这时候 A 需要等待一段时间，因为如果 B 没接收到 A 的 ACK 的话会重新发送给 A，所以 A 的等待时间需要足够长。</p><h3 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h3><blockquote><p>TCP 如何实现可靠传输?<br>首先为了保证顺序性，每个包都有一个 ID。在建立连接的时候会商定起始 ID 是什么，然后按照 ID 一个个发送，为了保证不丢包，需要对发送的包都要进行应答，当然，这个应答不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这种模式成为累计应答或累计确认。</p></blockquote><p>为了记录所有发送的包和接收的包，TCP 需要发送端和接收端分别来缓存这些记录，发送端的缓存里是按照包的 ID 一个个排列，根据处理的情况分成四个部分</p><ul><li>发送并且确认的</li><li>发送尚未确认的</li><li>没有发送等待发送的</li><li>没有发送并且暂时不会发送的</li></ul><p>这里的第三部分和第四部分就属于流量控制的内容</p><p>在 TCP 里，接收端会给发送端报一个窗口大小，叫 Advertised window。这个窗口应该等于上面的第二部分加上第三部分，超过这个窗口，接收端做不过来，就不能发送了</p><p>于是，发送端要保持下面的数据结构<br><img src="images/1909085.PNG" alt></p><p>对于接收端来讲，它的缓存里面的内容要简单一些</p><ul><li>接收并且确认过的</li><li>还没接收，但是马上就能接收的</li><li>还没接收，但也无法接收的<br>对应的数据结构如下<br><img src="images/1909086.PNG" alt></li></ul><h3 id="顺序问题和丢包问题"><a href="#顺序问题和丢包问题" class="headerlink" title="顺序问题和丢包问题"></a>顺序问题和丢包问题</h3><p>结合上面的图看，在发送端，1、2、3 已发送并确认；4、5、6、7、8、9 都是发送了还没确认；10、11、12 是还没发出的；13、14、15 是接收方没有空间，不准备发的。</p><p>在接收端来看，1、2、3、4、5 是已经完成 ACK 但是还没读取的；6、7 是等待接收的；8、9 是已经接收还没有 ACK 的。<br>发送端和接收端当前的状态如下：</p><ul><li>1、2、3 没有问题，双方达成了一致</li><li>4、5 接收方说 ACK 了，但是发送方还没收到</li><li>6、7、8、9 肯定都发了，但是 8、9 已经到了，6、7 没到，出现了乱序，缓存着但是没办法 ACK。<br>根据这个例子可以知道顺序问题和丢包问题都有可能存在，所以我们先来看确认与重传机制。</li></ul><p>假设 4 的确认收到了，5 的 ACK 丢了，6、7 的数据包丢了，该怎么办？</p><p>一种方法是超时重试，即对每一个发送了但是没有 ACK 的包设定一个定时器，超过了一定的事件就重新尝试。这个时间必须大于往返时间，但也不宜过长，否则超时时间变长，访问就变慢了。</p><p>如果过一段时间，5、6、7 都超时了就会重新发送。接收方发现 5 原来接收过，于是丢弃 5；6 收到了，发送 ACK，要求下一个是 7，7 不幸又丢了。当 7 再次超时的时候，TCP 的策略是超时间隔加倍。每当遇到一次超时重传的时候，都会讲下一次超时时间间隔设为先前值的两倍。</p><p>超时重传的机制是超时周期可能相对较长，是否有更快的方式呢？</p><p>有一个快速重传的机制，即当接收方接收到一个序号大于期望的报文段时，就检测到了数据流之间的间隔，于是发送三个冗余的 ACK，客户端接收到之后，知道数据报丢失，于是重传丢失的报文段。</p><p>例如，接收方发现 6、8、9 都接收了，但是 7 没来，所以肯定丢了，于是发送三个 6 的 ACK，要求下一个是 7。客户端接收到 3 个，就会发现 7 的确又丢了，不等超时，马上重发。</p><h3 id="流量控制的问题"><a href="#流量控制的问题" class="headerlink" title="流量控制的问题"></a>流量控制的问题</h3><p>在流量控制的机制里面，在对于包的确认中，会携带一个窗口的大小</p><p>简单的说一下就是接收端在发送 ACK 的时候会带上缓冲区的窗口大小，但是一般在窗口达到一定大小才会更新窗口，因为每次都更新的话，刚空下来就又被填满了</p><h3 id="拥塞控制的问题"><a href="#拥塞控制的问题" class="headerlink" title="拥塞控制的问题"></a>拥塞控制的问题</h3><p>也是通过窗口的大小来控制的，但是检测网络满不满是个挺难的事情，所以 TCP 发送包经常被比喻成往水管里灌水，所以拥塞控制就是在不堵塞，不丢包的情况下尽可能的发挥带宽。</p><p>水管有粗细，网络有带宽，即每秒钟能发送多少数据；水管有长度，端到端有时延。理想状态下，水管里面的水 = 水管粗细 * 水管长度。对于网络上，通道的容量 = 带宽 * 往返时延。</p><p>如果我们设置发送窗口，使得发送但未确认的包为通道的容量，就能撑满整个管道。<br><img src="images/1909087.PNG" alt><br>如图所示，假设往返时间为 8 秒，去 4 秒，回 4 秒，每秒发送一个包，已经过去了 8 秒，则 8 个包都发出去了，其中前四个已经到达接收端，但是 ACK 还没返回，不能算发送成功，5-8 后四个包还在路上，还没被接收，这个时候，管道正好撑满，在发送端，已发送未确认的 8 个包，正好等于带宽，也即每秒发送一个包，也即每秒发送一个包，乘以来回时间 8 秒。</p><p>如果在这个基础上调大窗口，使得单位时间可以发送更多的包，那么会出现接收端处理不过来，多出来的包会被丢弃，这个时候，我们可以增加一个缓存，但是缓存里面的包 4 秒内肯定达不到接收端课，它的缺点会增加时延，如果时延达到一定程度就会超时重传</p><p>TCP 拥塞控制主要来避免两种现象，包丢失和超时重传，一旦出现了这些现象说明发送的太快了，要慢一点。</p><p>具体的方法就是发送端慢启动，比如倒水，刚开始倒的很慢，渐渐变快。然后设置一个阈值，当超过这个值的时候就要慢下来</p><p>慢下来还是在增长，这时候就可能水满则溢，出现拥塞，需要降低倒水的速度，等水慢慢渗下去。</p><p>拥塞的一种表现是丢包，需要超时重传，这个时候，采用快速重传算法，将当前速度变为一半。所以速度还是在比较高的值，也没有一夜回到解放前。</p><h3 id="Tcp的优点"><a href="#Tcp的优点" class="headerlink" title="Tcp的优点"></a>Tcp的优点</h3><p>可靠，稳定<br>    TCP的可靠性体现在传输数据之前，三次握手建立连接（四次挥手释放连接），并且在数据传递时，有确认、窗口、重传、拥塞控制机制，数据传完之后，断开连接用来节省系统资源。</p><h3 id="TCP的缺点"><a href="#TCP的缺点" class="headerlink" title="TCP的缺点"></a>TCP的缺点</h3><p>慢，效率低，占用系统资源高，易被攻击<br>    传数据之前建立连接，这样会消耗时间，而且在消息传递时，确认机制、重传机制和拥塞控制机制都会消耗大量的时间，而且要在每台设备上维护所有的传输连接。而每个连接都会占用系统的CPU、内存等硬件软件资源。并且TCP的取而机制、三次握手，这些也导致TCP容易被人利用，实现DOS，DDOS攻击。</p><h2 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2><p>UDP 是一种面向无连接，且不可靠的协议，在通信过程中，它并不像 TCP 那样需要先建立一个连接，只要（目的地址，端口号，源地址，端口号）确定了，就可以直接发送信息报文，并且不需要确保服务端一定能收到或收到完整的数据。它仅仅提供了校验和机制来保障一个报文是否完整，若校验失败，则直接丢弃报文，不做任何处理。</p><p>TCP和UDP都是传输层协议，但是两者具有不同的特性和应用场景</p><ol><li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。</li><li>UDP程序结构较简单</li><li>TCP 是面向字节流的，UDP 是基于数据报的</li><li>TCP 保证数据正确性，UDP 可能丢包</li><li>TCP 保证数据顺序，UDP 不保证</li><li>TCP要求系统资源较多，UDP较少。</li><li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。</li><li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。</li><li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。</li><li>TCP首部开销20字节;UDP的首部开销小，只有8个字节。</li><li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。<br><img src="images/1909088.PNG" alt></li></ol><p><strong>名词解释</strong><br><strong>面向报文和面向字节流</strong><br>面向报文的传输方式是应用层交给UDP多长的报文，UDP就发送多长的报文，即一次发送一个报文。因此应用程序必须选择大小合适的报文。报文太长，则IP层需要分片，降低效率。</p><p>面向字节流的传输方式是应用程序和TCP的交互是一次一个数据块（大小不等），TCP把这些数据块看成是一连串无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就会把它分割成多块传送。<br><strong>双工性</strong><br>全双工：是指在发送数据的同时也能够接收数据，两者同步进行，这好像我们平时打电话一样，说话的同时也能够听到对方的声音。目前的网卡一般都支持全双工。</p><p>半双工：所谓半双工就是指一个时间段内只有一个动作发生，举个简单例子，一条窄窄的马路，同时只能有一辆车通过，当目前有两量车对开，这种情况下就只能一辆先过，等到头儿后另一辆再开，这个例子就形象的说明了半双工的原理。</p><h2 id="TCP-UDP编程模型"><a href="#TCP-UDP编程模型" class="headerlink" title="TCP/UDP编程模型"></a>TCP/UDP编程模型</h2><p>从程序实现的角度来看，可以用下图来进行描述。<br><img src="images/1909089.PNG" alt><br>从上图也能清晰的看出，TCP通信需要服务器端侦听listen、接收客户端连接请求accept，等待客户端connect建立连接后才能进行数据包的收发（recv/send）工作。而UDP则服务器和客户端的概念不明显，服务器端即接收端需要绑定端口，等待客户端的数据的到来。后续便可以进行数据的收发（recvfrom/sendto）工作。</p><p>前面提到了UDP保留了报文的边界，下面我们来谈谈TCP和UDP中报文的边界问题。在默认的阻塞模式下，TCP无边界，UDP有边界。</p><p>对于TCP协议，客户端连续发送数据，只要服务端的这个函数的缓冲区足够大，会一次性接收过来，即客户端是分好几次发过来，是有边界的，而服务端却一次性接收过来，所以证明是无边界的；</p><p>而对于UDP协议，客户端连续发送数据，即使服务端的这个函数的缓冲区足够大，也只会一次一次的接收，发送多少次接收多少次，即客户端分几次发送过来，服务端就必须按几次接收，从而证明，这种UDP的通讯模式是有边界的。</p><h2 id="TCP-与-UDP-的应用场景"><a href="#TCP-与-UDP-的应用场景" class="headerlink" title="TCP 与 UDP 的应用场景"></a>TCP 与 UDP 的应用场景</h2><p><img src="images/19090810.jpg" alt><br><img src="images/19090811.jpg" alt><br>从特点上我们已经知道，TCP 是可靠的但传输速度慢 ，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。</p><p>若通信数据完整性需让位与通信实时性，则应该选用 TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。</p><h3 id="什么时候应该使用TCP"><a href="#什么时候应该使用TCP" class="headerlink" title="什么时候应该使用TCP"></a>什么时候应该使用TCP</h3><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。</p><p>在日常生活中，常见使用TCP协议的应用如下：</p><ul><li>浏览器，用的HTTP</li><li>FlashFXP，用的FTP</li><li>Outlook，用的POP、SMTP</li><li>Putty，用的Telnet、SSH</li><li>QQ文件传输</li></ul><h3 id="什么时候应该使用UDP"><a href="#什么时候应该使用UDP" class="headerlink" title="什么时候应该使用UDP"></a>什么时候应该使用UDP</h3><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。<br>比如，日常生活中，常见使用UDP协议的应用如下：</p><ul><li>QQ语音</li><li>QQ视频</li><li>TFTP</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="什么是面向连接，什么是面向无连接"><a href="#什么是面向连接，什么是面向无连接" class="headerlink" title="什么是面向连接，什么是面向无连接"></a>什么是面向连接，什么是面向无连接</h3><p>在互通之前，面向连接的协议会先建立连接，如 TCP 有三次握手，而 UDP 不会</p><h3 id="TCP-为什么是可靠连接"><a href="#TCP-为什么是可靠连接" class="headerlink" title="TCP 为什么是可靠连接"></a>TCP 为什么是可靠连接</h3><ul><li>通过 TCP 连接传输的数据无差错，不丢失，不重复，且按顺序到达。</li><li>TCP 报文头里面的序号能使 TCP 的数据按序到达</li><li>报文头里面的确认序号能保证不丢包，累计确认及超时重传机制</li><li>TCP 拥有流量控制及拥塞控制的机制<br>TCP 的顺序问题，丢包问题，流量控制都是通过滑动窗口来解决的<br>拥塞控制时通过拥塞窗口来解决的</li></ul><p>两种协议都是传输层协议，为应用层提供信息载体。TCP协议是基于连接的可靠协议，有流量控制和差错控制，也正因为有可靠性的保证和控制手段，所以传输效率比UDP低；UDP协议是基于无连接的不可靠协议，没有控制手段，仅仅是将数据发送给对方，因此效率比TCP要高。</p><p>基于上述特性，不难得到结论，TCP协议适用于对效率要求相对低，但对准确性要求相对高的场景下，或者是有一种连接概念的场景下；而UDP协议适用于对效率要求相对高，对准确性要求相对低的场景。</p><p>几个应用的例子。TCP一般用于文件传输（FTP HTTP 对数据准确性要求高，速度可以相对慢），发送或接收邮件（POP IMAP SMTP 对数据准确性要求高，非紧急应用），远程登录（TELNET SSH 对数据准确性有一定要求，有连接的概念）等等；UDP一般用于即时通信（QQ聊天 对数据准确性和丢包要求比较低，但速度必须快），在线视频（RTSP 速度一定要快，保证视频连续，但是偶尔花了一个图像帧，人们还是能接受的），网络语音电话（VoIP 语音数据包一般比较小，需要高速发送，偶尔断音或串音也没有问题）等等。<br>一些其他应用。比如，TCP可以用于网络数据库，分布式高精度计算系统的数据传输；UDP可以用于服务系统内部之间的数据传输，因为数据可能比较多，内部系统局域网内的丢包错包率又很低，即便丢包，顶多是操作无效，这种情况下，UDP经常被使用。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CDN</title>
      <link href="/CDN.html"/>
      <url>/CDN.html</url>
      
        <content type="html"><![CDATA[<p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CDN(Content Delivery Network)是指内容分发网络，也称为内容传送网络，这个概念始于1996年，是美国麻省理工学院的一个研究小组为改善互联网的服务质量而提出的。为了能在传统IP网上发布丰富的宽带媒体内容，他们提出在现有互联网基础上建立一个内容分发平台专门为网站提供服务，并于1999年成立了专门的CDN服务公司，为Yahoo提供专业服务。由于CDN是为加快网络访问速度而被优化的网络覆盖层，因此被形象地称为“网络加速器”。 </p><p>CDN网络的诞生大大地改善了互联网的服务质量，因此传统的大型网络运营商纷纷开始建设自己的CDN网络，如AT&amp;T、德国电信、中国电信等。随着市场需求的不断增加，甚至出现了纯粹的CDN网络运营商，美国的Akamai就是其中最大的一个，拥有分布在世界各地的1000多个节点。我国第一家纯粹的CDN网络服务公司是北京蓝汛公司，已从2000年开始建立了一个专门的CDN服务网络一ChinaCache。目前CDN网络已经突破50个节点，覆盖中国六大骨干网络一中国电信、中国网通、中国移动、中国联通、中国铁通网络以及中国教育网，带宽资源储备超过35G，服务的客户数量达到300多家。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>CDN网络中包含的功能实体包括内容缓存设备、内容交换机、内容路由器、CDN内容管理系统等组成。<br>内容缓存为CDN网络节点，位于用户接入点，是面向最终用户的内容提供设备，可缓存静态Web内容和流媒体内容，实现内容的边缘传播和存储，以便用户的就近访问。<br>内容交换机处于用户接入集中点，可以均衡单点多个内容缓存设备的负载，并对内容进行缓存负载平衡及访问控制。<br>内容路由器负责将用户的请求调度到适当的设备上。内容路由通常通过负载均衡系统来实现，动态均衡各个内容缓存站点的载荷分配，为用户的请求选择最佳的访问站点，同时提高网站的可用性。内容路由器可根据多种因素制定路由，包括站点与用户的临近度、内容的可用性、网络负载、设备状况等。负载均衡系统是整个CDN的核心。负载均衡的准确性和效率直接决定了整个CDN的效率和性能。<br>内容管理系统负责整个CDN的管理，是可选部件，作用是进行内容管理，如内容的注入和发布、内容的分发、内容的审核、内容的服务等。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol><li>节省骨干网带宽，减少带宽需求量；</li><li>提供服务器端加速，解决由于用户访问量大造成的服务器过载问题</li><li>服务商能使用Web Cache技术在本地缓存用户访问过的Web页面和对象，实现相同对象的访问无须占用主干的出口带宽，并提高用户访问因特网页面的相应时间的需求；</li><li>能克服网站分布不均的问题，并且能降低网站自身建设和维护成本；</li><li>降低“通信风暴”的影响，提高网络访问的稳定性。</li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</p><p>CDN的基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</p><h2 id="服务模式"><a href="#服务模式" class="headerlink" title="服务模式"></a>服务模式</h2><p>内容分发网络（CDN）是一种新型网络构建方式，它是为能在传统的IP网发布宽带丰富媒体而特别优化的网络覆盖层；而从广义的角度，CDN代表了一种基于质量与秩序的网络服务模式。<br>简单地说，内容分发网络（CDN）是一个经策略性部署的整体系统，包括分布式存储、负载均衡、网络请求的重定向和内容管理4个要件，而内容管理和全局的网络流量管理（Traffic Management）是CDN的核心所在。通过用户就近性和服务器负载的判断，CDN确保内容以一种极为高效的方式为用户的请求提供服务。<br>总的来说，内容服务基于缓存服务器，也称作代理缓存（Surrogate），它位于网络的边缘，距用户仅有”一跳”（Single Hop）之遥。同时，代理缓存是内容提供商源服务器（通常位于CDN服务提供商的数据中心）的一个透明镜像。这样的架构使得CDN服务提供商能够代表他们客户，即内容供应商，向最终用户提供尽可能好的体验，而这些用户是不能容忍请求响应时间有任何延迟的。   </p><h2 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h2><ol><li>本地Cache加速：提高了企业站点（尤其含有大量图片和静态页面站点）的访问速度，并大大提高以上性质站点的稳定性。    </li><li>镜像服务：消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。    </li><li>远程加速：远程访问用户根据DNS负载均衡技术智能自动选择Cache服务器，选择最快的Cache服务器，加快远程访问的速度。    </li><li>带宽优化：自动生成服务器的远程Mirror（镜像）cache服务器，远程用户访问时从cache服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点WEB服务器负载等功能。    </li><li>集群抗攻击：广泛分布的CDN节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种D.D.o.S攻击对网站的影响，同时保证较好的服务质量 。</li></ol><h2 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h2><h3 id="内容发布"><a href="#内容发布" class="headerlink" title="内容发布"></a>内容发布</h3><p>它借助于建立索引、缓存、流分裂、组播（Multicast）等技术，将内容发布或投递到距离用户最近的远程服务点（POP）处。<br>内容分发包含从内容源到CDN边缘的Cache的过程。从实现上，有两种主流的内容分发技术：PUSH和PULL。<br>PUSH是一种主动分发的技术。通常，PUSH由内容管理系统发起，将内容从源或者中心媒体资源库分发到各边缘的 Cache节点。分发的协议可以采用 Http/ftp等。通过PUSH分发的内容一般是比较热点的内容，这些内容通过PUSH方式预分发（ Preload）到边缘Cache，可以实现有针对的内容提供。对于PUSH分发需要考虑的主要问题是分发策略，即在什么时候分发什么内容。一般来说，内容分发可以由CP（内容提供商）或者CDN内容管理员人工确定，也可以通过智能的方式决定，即所谓的智能分发，它根据用户访问的统计信息，以及预定义的内容分发的规则，确定内容分发的过程PULL是一种被动的分发技术，PULL分发通常由用户请求驱动。当用户请求的内容在本地的边缘 Cache上不存在（未命中）时， Cache启动PUL方法从内容源或者其他CDN节点实时获取内容。在PULL方式下，内容的分发是按需的。</p><h3 id="内容路由"><a href="#内容路由" class="headerlink" title="内容路由"></a>内容路由</h3><p>它是整体性的网络负载均衡技术，通过内容路由器中的重定向（DNS）机制，在多个远程POP上均衡用户的请求，以使用户请求得到最近内容源的响应。</p><p>CDN负载均衡系统实现CDN的内容路由功能。它的作用是将用户的请求导向整个CDN网络中的最佳节点。最佳节点的选定可以根据多种策略，例如距离最近、节点负载最轻等。负载均衡系统是整个CDN的核心，负载均衡的准确性和效率直接决定了整个CDN的效率和性能。通常负载均衡可以分为两个层次:全局负载均衡（GSLB）和本地负载均衡（SLB）。全局负载均衡主要的目的是在整个网络范围内将用户的请求定向到最近的节点（或者区域）。因此，就近性判断是全局负载均衡的主要功能。本地负载均衡一般局限于一定的区域范围内，其目标是在特定的区域范围内寻找一台最适合的节点提供服务，因此，CDN节点的健康性、负载情况、支持的媒体格式等运行状态是本地负载均衡进行决策的主要依据。</p><h3 id="内容存储"><a href="#内容存储" class="headerlink" title="内容存储"></a>内容存储</h3><p>对于CDN系统而言，需要考虑两个方面的内容存储问题。一个是内容源的存储，一个是内容在 Cache节点中的存储。<br>对于内容源的存储，由于内容的规模比较大（通常可以达到几个甚至几十个TB），而且内容的吞吐量较大，因此，通常采用海量存储架构，如NAS和SON。对于在 Cache节点中的存储，是 Cache设计的一个关键问题。需要考虑的因素包括功能和性能两个方面:功能上包括对各种内容格式的支持，对部分缓存的支持;在性能上包括支持的容量、多文件吞吐率、可靠性、稳定性。<br>其中，多种内容格式的支持要求存储系统根据不同文件格式的读写特点进行优化，以提高文件内容读写的效率。特别是对针对流媒体文件的读写。部分缓存能力指流媒体内容可以以不完整的方式存储和读取。部分缓存的需求来自用户访问行为的随机性，因为许多用户并不会完整地收看整个流媒体节目。事实上，许多用户访问单个流媒体节目的时间不超过10分钟。因此，部分缓存能力能够大大提高存储空间的利用率，并有效提高用户请求的响应时间。但是部分缓存可能导致内容的碎片问题，需要进行良好的设计和控制。<br>Cache存储的另一个重要因素是存储的可靠性，目前，多数存储系统都采用了独立磁盘冗余阵列（RAID）技术进行可靠存储。但是不同设备使用的RAID方式各有不同。</p><h3 id="内容管理"><a href="#内容管理" class="headerlink" title="内容管理"></a>内容管理</h3><p>它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能（如包丢失、延时、平均带宽、启动时间、帧速率等），保证网络处于最佳的运行状态。<br>内容管理在广义上涵盖了从内容的发布、注入、分发、调整、传递等一系列过程。在这里，内容管理重点强调内容进人 Cache点后的内容管理，称其为本地内容管理。本地内容管理主要针对一个ODN节点（有多个 CDN Cache设备和一个SLB设备构成）进行。本地内容管理的主要目标是提高内容服务的效率，提高本地节点的存储利用率。通过本地内容管理，可以在CDN节点实现基于内容感知的调度，通过内容感知的调度，可以避免将用户重定向到没有该内容的 Cache设备上，从而提高负载均衡的效率。通过本地内容管理还可以有效实现在ODN节点内容的存储共享，提高存储空间的利用率。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Abstract class和Interface的区别</title>
      <link href="/Differences-between-abstract-class-and-interface.html"/>
      <url>/Differences-between-abstract-class-and-interface.html</url>
      
        <content type="html"><![CDATA[<p>含有 abstract 修饰符 class 即为抽象类，抽象类不能创建实际对象，含有抽象方法的抽象类必须定义为 abstract class。</p><p>接口可以说成是一种特殊的抽象类，接口中的所有方法都必须是抽象的，接口中的方法定义默认为 public abstract 类型，接口中的成员产量类型默认为 public static final。<br>两者的区别:</p><a id="more"></a><ol><li><p>抽象类可以有构造方法，接口中不能有构造方法。</p></li><li><p>抽象类中可以有普通成员变量，接口中没有普通成员变量。</p></li><li><p>抽象类中可以包含非抽象普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的方法。</p></li><li><p>抽象类中的抽象方法的访问权限可以是 public、protected 和(默认类型，虽然 eclipse 不报错，但也不能用，默认类型子类不能继承)，接口中的抽象方法只能是 public 类型的，并且默认即为 public abstract 类型。</p></li><li><p>抽象类中可以包含静态方法，在 JDK1.8 之前接口中不能不包含静态方法，JDK1.8 以后可以包含。</p></li><li><p>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问权限可以是任意的，但接口中定义的变量只能是 public static final 类型的，并且默认即为 public static final 类型。</p></li><li><p>一个类可以实现多个接口，用逗号隔开，但只能继承一个抽象类，接口不可以实现接口，但可以继承接口，并且可以继承多个接口，用逗号隔开。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java中ArrayList与LinkedList的区别</title>
      <link href="/Differences-between-ArrayList-and-LinkedList-in-Java.html"/>
      <url>/Differences-between-ArrayList-and-LinkedList-in-Java.html</url>
      
        <content type="html"><![CDATA[<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li><p>ArrayList的实现是基于数组，LinkedList的实现是基于双向链表。 </p></li><li><p>对于随机访问，ArrayList优于LinkedList</p></li><li><p>对于插入和删除操作，LinkedList优于ArrayList</p></li><li><p>LinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</p><a id="more"></a></li></ol><h2 id="在时间复杂度上的区别"><a href="#在时间复杂度上的区别" class="headerlink" title="在时间复杂度上的区别"></a>在时间复杂度上的区别</h2><p>假设我们有两个很大的列表，它们里面的元素已经排好序了，这两个列表分别是ArrayList类型和LinkedList类型的，现在我们对这两个列表来进行二分查找(binary search)，比较它们的查找速度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> 1 package com.demo;</span><br><span class="line"> 2 </span><br><span class="line"> 3 import java.util.ArrayList;</span><br><span class="line"> 4 import java.util.Collections;</span><br><span class="line"> 5 import java.util.LinkedList;</span><br><span class="line"> 6 import java.util.List;</span><br><span class="line"> 7 </span><br><span class="line"> 8 public class Demo1 &#123;</span><br><span class="line"> 9     static List&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;();</span><br><span class="line">10     static List&lt;Integer&gt; linked = new LinkedList&lt;Integer&gt;();</span><br><span class="line">11 </span><br><span class="line">12     public static void main(String[] args) &#123;</span><br><span class="line">13 </span><br><span class="line">14         for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">15             array.add(i);</span><br><span class="line">16             linked.add(i);</span><br><span class="line">17         &#125;</span><br><span class="line">18         System.out.println(&quot;ArrayList访问消耗的时间：&quot; + getTime(array));</span><br><span class="line">19         System.out.println(&quot;LinkedList访问消耗的时间：&quot; + getTime(linked));</span><br><span class="line">20     &#125;</span><br><span class="line">21 </span><br><span class="line">22     public static long getTime(List list) &#123;</span><br><span class="line">23         long time = System.currentTimeMillis();</span><br><span class="line">24         for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">25             int index = Collections.binarySearch(list, list.get(i));</span><br><span class="line">26             if (index != i) &#123;</span><br><span class="line">27                 System.out.println(&quot;ERROR!&quot;);</span><br><span class="line">28             &#125;</span><br><span class="line">29         &#125;</span><br><span class="line">30         return System.currentTimeMillis() - time;</span><br><span class="line">31     &#125;</span><br><span class="line">32 </span><br><span class="line">33 &#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList访问消耗的时间：10</span><br><span class="line">LinkedList访问消耗的时间：383</span><br></pre></td></tr></table></figure><p>可以看出，对于随机访问，ArrayList的访问速度更快。 </p><p>ArrayList和LinkedList的插入数据耗时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> 1 package com.demo;</span><br><span class="line"> 2 </span><br><span class="line"> 3 import java.util.ArrayList; </span><br><span class="line"> 4 import java.util.LinkedList;</span><br><span class="line"> 5 import java.util.List;</span><br><span class="line"> 6 </span><br><span class="line"> 7 public class Demo2 &#123;</span><br><span class="line"> 8     static List&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;();</span><br><span class="line"> 9     static List&lt;Integer&gt; linked = new LinkedList&lt;Integer&gt;();</span><br><span class="line">10 </span><br><span class="line">11     public static void main(String[] args) &#123;</span><br><span class="line">12 </span><br><span class="line">13         for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">14             array.add(i);</span><br><span class="line">15             linked.add(i);</span><br><span class="line">16         &#125;</span><br><span class="line">17         System.out.println(&quot;ArrayList插入消耗的时间：&quot; + insertTime(array));</span><br><span class="line">18         System.out.println(&quot;LinkedList插入消耗的时间：&quot; + insertTime(linked));</span><br><span class="line">19     &#125;</span><br><span class="line">20 </span><br><span class="line">21     public static long insertTime(List list) &#123;</span><br><span class="line">22         long time = System.currentTimeMillis();</span><br><span class="line">23         for (int i = 100; i &lt; 10000; i++) &#123;</span><br><span class="line">24             list.add(10, i); // 在索引为10的位置插入i</span><br><span class="line">25         &#125;</span><br><span class="line">26         return System.currentTimeMillis() - time;</span><br><span class="line">27     &#125;</span><br><span class="line">28 &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList插入消耗的时间：31</span><br><span class="line">LinkedList插入消耗的时间：4</span><br></pre></td></tr></table></figure><p>可以看出，对于插入操作，LinkedList 的速度更快</p><h2 id="在空间复杂度上的区别"><a href="#在空间复杂度上的区别" class="headerlink" title="在空间复杂度上的区别"></a>在空间复杂度上的区别</h2><p>在LinkedList中有一个私有的内部类，定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static class Entry &#123;   </span><br><span class="line">         Object element;   </span><br><span class="line">         Entry next;   </span><br><span class="line">         Entry previous;   </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>LinkedList中的每一个元素中还存储了它的前一个元素的索引和后一个元素的索引。</p><p>ArrayList使用一个内置的数组来存储元素，这个数组的起始容量是10，当数组需要增长时，新的容量按如下公式获得：新容量 = 旧容量*1.5 + 1，也就是说每一次容量大概会增长50% </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>ArrayList的实现是基于数组，LinkedList的实现是基于双向链表。 </p></li><li><p>对于随机访问，ArrayList优于LinkedList，ArrayList可以根据下标以O(1)时间复杂度对元素进行随机访问。而LinkedList的每一个元素都依靠地址指针和它后一个元素连接在一起，在这种情况下，查找某个元素的时间复杂度是O(n) </p></li><li><p>对于插入和删除操作，LinkedList优于ArrayList，因为当元素被添加到LinkedList任意位置的时候，不需要像ArrayList那样重新计算大小或者是更新索引。 </p></li><li><p>LinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>泛型的意义和作用</title>
      <link href="/Significance-and-Function-of-Generics.html"/>
      <url>/Significance-and-Function-of-Generics.html</url>
      
        <content type="html"><![CDATA[<h2 id="意义和作用："><a href="#意义和作用：" class="headerlink" title="意义和作用："></a>意义和作用：</h2><p>类型的参数化，就是可以把类型像方法的参数那样传递。这一点意义非凡。<br>泛型使编译器可以在编译期间对类型进行检查以提高类型安全，减少运行时由于对象类型不匹配引发的异常。</p><a id="more"></a>　<p>想要理解为什么引入泛型，就要知道没有泛型的麻烦。<br>我们知道现在的程序开发都是面向对象了，所以程序里会有很多各种类型的对象，对象多了肯定需要有某种类型的容器来装。所以就有了一些容器类型，比如数组、ArrayList、HashMap、TreeSet等。<br>对于数组，我们知道需要在使用时指定数组装的对象类型，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal animal[];</span><br><span class="line"> </span><br><span class="line">Dog dog[];</span><br></pre></td></tr></table></figure><p>而对于集合类型容器如ArrayList、HashMap、TreeSet等，它们不但是容器，还提供了一些方法对容器内对象的操作方法，如get，set，sort。这个时候就需要知道容器内放的是什么类型的对象，才能return或set。</p><p>正因为程序开发人员可能把任何类型的对象放进集合容器，所以这些容器在设计的时候只能默认设计成装Object类型对象。因为Java里Object是根类。<br>所以容器就成了类似这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ListContainer &#123;</span><br><span class="line">    private Object obj;</span><br><span class="line"> </span><br><span class="line">    public Object getObj() &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setObj(Object obj) &#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，根据多态，容器就能装任何类型的对象了。不过，取出对象时则需求进行强制类型转换，转换成实际的类型。但这样会有很多类型不安全问题，为什么呢？因为编译器没法帮忙做类型检查，导致代码在运行时易于出现ClassCastException异常。因此，类型安全问题只能由程序员自己来把关了，记住各种类型，避免类型转换错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListContainer myContainer = new ListContainer();</span><br><span class="line"> </span><br><span class="line">myContainer.setObj(&quot;123&quot;);</span><br><span class="line"> </span><br><span class="line">   ArrayList objectList = new ArrayList();</span><br><span class="line"> </span><br><span class="line">objectList.add(myContainer);</span><br><span class="line"> </span><br><span class="line">//下面这句编译时无异常，运行时会ClassCastException异常</span><br><span class="line"> </span><br><span class="line">Integer myStr = (Integer) (objectList.get(0)).getObj();</span><br><span class="line"> </span><br><span class="line">//下面这句ok</span><br><span class="line"> </span><br><span class="line">String myStr1 = (String) (objectList.get(0)).getObj();</span><br><span class="line"></span><br><span class="line">System.out.println(myStr1);</span><br></pre></td></tr></table></figure><h2 id="泛型出场：类型的参数化"><a href="#泛型出场：类型的参数化" class="headerlink" title="泛型出场：类型的参数化"></a>泛型出场：类型的参数化</h2><p>利用泛型，重新设计：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ListContainer&lt;T&gt; &#123;</span><br><span class="line">    private T t;</span><br><span class="line"> </span><br><span class="line">    public T getObj() &#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setObj(T t) &#123;</span><br><span class="line">        this.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<t>的T的类型的参数，具体T指代什么类型，是String还是Animal还是Dog类型此处不管，而在程序员开发时使用到ListContainer时再指定，如：<br><code>ListContainer&lt;Dog&gt; myCon=new ListContainer&lt;Dog&gt;();</code><br>这种环境下，编译器就知道ListContainer容器是放Dog类型对象的。并进行类型安全检查。</t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myCon.setObj(new Dog())//ok</span><br><span class="line"> </span><br><span class="line">myCon.setObj(“123”);//编译时提醒类型错误</span><br></pre></td></tr></table></figure><p>这样设计的容器在使用时编译器就可以帮忙做很大一部分的类型安全检查工作了，这就避免了很多运行时的ClassCastException异常，程序员也无需记住各种对象的类型和担心类型匹配问题了。同时大部分情况下也不用做类型强制转换工作了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ListContainer&lt;String&gt; myContainer = new ListContainer&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">myContainer.setObj(&quot;123&quot;);</span><br><span class="line"> </span><br><span class="line">myContainer.setObj(new Dog());//编译器就提醒类型异常</span><br><span class="line"> </span><br><span class="line">ArrayList objectList&lt;ListContainer&gt; = new ArrayList&lt;ListContainer&gt;();</span><br><span class="line"> </span><br><span class="line">objectList.add(myContainer);</span><br><span class="line"> </span><br><span class="line">Integer myStr = (objectList.get(0)).getObj(); //编译时提醒类型异常</span><br><span class="line"> </span><br><span class="line">String myStr = (objectList.get(0)).getObj();</span><br></pre></td></tr></table></figure><p>当然泛型的&lt;&gt;里也可以放多个参数，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MultiContainer&lt;T,S&gt; &#123;</span><br><span class="line"> </span><br><span class="line">private T t;</span><br><span class="line"> </span><br><span class="line">private S s;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">MultiContainer&lt;String,Dog&gt; multicon=new MultiContainer&lt;String,Dog&gt;();</span><br></pre></td></tr></table></figure><h2 id="有界泛型"><a href="#有界泛型" class="headerlink" title="有界泛型"></a>有界泛型</h2><p>看看这个泛型和多态的问题,Dog,Cat是Animal的子类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void killAll(ArrayList&lt;Animal&gt; animals)&#123;...&#125;;//Animal容器</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">ArrayList&lt;Animal&gt; animals=new ArrayList&lt;Animal&gt;();</span><br><span class="line"> </span><br><span class="line">animals.add(new Dog());</span><br><span class="line"> </span><br><span class="line">animals.add(new Cat());</span><br><span class="line"> </span><br><span class="line">killAll(animals);//这里ok</span><br><span class="line"> </span><br><span class="line">ArrayList&lt;Dog&gt; dogs=new ArrayList&lt;Dog&gt;();//Dog是Animal的子类</span><br><span class="line"> </span><br><span class="line">dogs.add(new Dog());</span><br><span class="line"> </span><br><span class="line">dogs.add(new Dog());</span><br><span class="line"> </span><br><span class="line">killAll(dogs);//这里编译不通过</span><br></pre></td></tr></table></figure><p>在这里看上去似乎多态不行了。<br>这里就要用到有界泛型：<br>在使用泛型时，我们会有这种需求：需要指定泛型的类型范围。有界类型就是在类型参数部分指定extends或super关键字，这里的extends也含有implements的功能，分别用上限或下限来限制类型范围，从而限制泛型的类型边界。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends Animal&gt;//限定T是Animal的子类</span><br><span class="line"> </span><br><span class="line">&lt;T super Dog &gt;//限定T是Dog的超类</span><br></pre></td></tr></table></figure><p>那么上面那个多态问题就变成：<br><code>public void killAll(ArrayList&lt;T extends Animal&gt; animals){...};</code><br>解决了<br><code>&lt;T extends Object&amp;Comparable&amp;Serializable&gt;</code><br>多个限定时我们可以使用&amp;来进行分割，这时关键词只能使用extends。与多重继承类似，这里只有一个类其他都是接口。</p><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>有时，我们设计的方法可能其参数类型是不限定的。这种场景如果用重载方法的方式来做的话，算法重复，不是最好的方案。此时泛型方法就可以解决此类问题。<br>如Calculator的add方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static &lt; N extends Number &gt; double add( N a, N b )&#123;</span><br><span class="line">double sum = 0;</span><br><span class="line"> </span><br><span class="line">sum = a.doubleValue() + b.doubleValue();</span><br><span class="line"> </span><br><span class="line">return(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用重载来做的话，要很多重复代码了。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Navicat连接Mysql报错</title>
      <link href="/Navicat-Connection-Mysql-Error.html"/>
      <url>/Navicat-Connection-Mysql-Error.html</url>
      
        <content type="html"><![CDATA[<p>Client does not support authentication protocol requested by server；<br>解决办法，登入MySQL的命令行界面，然后输入：<br><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;;</code><br>其中password需要改成你自己的密码，大概原因是MySQL8.0的加密方式改变了，但是比较老版本的navicate没有来得及支持，因此需要将mysql设置为支持传统的那种密码加密，如果用比较低版本的MySQL，比如MySQL57应该就不会出现这种问题。<br>最后再输入下面一句进行刷新<br><code>FLUSH PRIVILEGES;</code><br>问题解决</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据的逻辑结构和存储结构</title>
      <link href="/Logical-Structure-and-Storage-Structure-of-Data.html"/>
      <url>/Logical-Structure-and-Storage-Structure-of-Data.html</url>
      
        <content type="html"><![CDATA[<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p><img src="/images/1908261.png" alt><br>我们从上可以发现：上面这三种逻辑结构之间的节点与节点之间的关系是不一样的，对于线性结构来说，节点之间的关系是一对一的；树形结构的节点是一对多；图形结构的节点是多对多的关系。</p><ol><li><p>线性结构：开始节点和终端节点都是唯一的，我们可以把第一个节点认为是开始节点，第四个节点认为是终端节点。除了开始节点和终端节点以外，其余节点都有且仅有一个前驱节点，有且仅有一个后继节点。对于第二个节点来说，它的前驱节点就是第一个节点，它的后继节点是第三个节点。</p></li><li><p>树形结构：开始节点唯一，终端节点不唯一，开始节点就是指的根节点，终端节点就是指的最下面的节点。除终端节点以外，每个节点有一个或多个后继节点，在根节点的左节点中有三个后继节点，右节点有两个后继节点，除开始节点外（根节点没有前驱节点），每个节点有且仅有一个前驱节点。</p></li><li><p>图形结构：没有开始节点和终端节点，所有节点都可能有多个前驱节点和多个后继节点，也就是说形成了一个多对多的图形结构，我们在图形结构中也看到了，节点之间是相互连接的。</p><a id="more"></a><p>下面这张图是数据逻辑结构的层次组织关系<br><img src="images/1908262.png" alt><br>数据逻辑结构主要分为线性结构和非线性结构，在非线性结构中又包括了之前讲过的树和图两种结构，在树结构中又分为一般树和二叉树，图结构又分为有向图和无向图；在线性结构中包括了一般的线性表，受限线性表，线性表推广等，在受线性表中分为栈和队列。因此我们应该根据数据逻辑结构把所有的数据结构中的内容通过上图的方式组织起来，起码做到对这张图有个印象，这将会指导后面的学习。</p></li></ol><p>另外，我们在学习掌握数据的逻辑结构时，还应该掌握逻辑结构的二元组表示方法。对于线性结构，树形结构，图形结构都可以通过这种二元组来表示.</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>数据的存储方式可分为线性表、树和图三种存储结构，而每种存储结构又可细分为顺序存储结构和链式存储结构。数据存储方式如此之多，针对不同类型的数据选择合适的存储方式是至关重要的。<br>那么，到底如何选择呢？数据存储结构的选择取决于两方面，即数据的逻辑结构和存储结构（又称物理结构）。</p><h3 id="逻辑结构-1"><a href="#逻辑结构-1" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>数据的逻辑结构，简单地理解，就是指的数据之间的逻辑关系。<br><img src="images/1908263.gif" alt><br>例如，图 1 显示是一张家庭的成员关系图，从图中可以看到，张平、张华和张群是兄弟，他们的父亲是张亮，其中张平有两个儿子，分别是张晶和张磊。</p><p>以上所说，父子、兄弟等这些关系都指的是数据间的逻辑关系，假设我们要存储这样一张家庭成员关系图，不仅要存储张平、张华等数据，还要存储它们之间的关系，两者缺一不可。</p><p>一组数据成功存储到计算机的衡量标准是要能将其完整的复原。例如图 1 所示的成员关系图，如果所存储的数据能将此成员关系图彻底复原，则说明数据存储成功。</p><ol><li>线性表用于存储具有“一对一”逻辑关系的数据；</li><li>树结构用于存储具有“一对多”关系的数据；</li><li>图结构用于存储具有“多对多”关系的数据；</li></ol><p>由此，我们可以通过分析数据之间的逻辑关系来决定使用哪种存储结构，但具体使用顺序存储还是链式存储，还要通过数据的物理结构来决定。</p><h3 id="存储结构（物理结构）"><a href="#存储结构（物理结构）" class="headerlink" title="存储结构（物理结构）"></a>存储结构（物理结构）</h3><p>数据的存储结构，也就是物理结构，指的是数据在物理存储空间上选择集中存放还是分散存放。假设要存储大小为 10G 的数据，则集中存放就如图 3a) 所示，分散存放就如图 3b）所示。<br><img src="images/1908264.gif" alt><br>如果选择集中存储，就使用顺序存储结构；反之，就使用链式存储。至于如何选择，主要取决于存储设备的状态以及数据的用途。</p><p>我们知道，集中存储（底层实现使用的是数组）需要使用一大块连续的物理空间，假设要存储大小为 1G 的数据，若存储设备上没有整块大小超过 1G 的空间，就无法使用顺序存储，此时就要选择链式存储，因为链式存储是随机存储数据，占用的都是存储设备中比较小的存储空间，因此有一定几率可以存储成功。</p><p>并且，数据的用途不同，选择的存储结构也不同。将数据进行集中存储有利于后期对数据进行遍历操作，而分散存储更有利于后期增加或删除数据。因此，如果后期需要对数据进行大量的检索（遍历），就选择集中存储；反之，若后期需要对数据做进一步更新（增加或删除），则选择分散存储。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java数据类型总结：基本类型、引用类型</title>
      <link href="/Summary-of-Java-Data-Types.html"/>
      <url>/Summary-of-Java-Data-Types.html</url>
      
        <content type="html"><![CDATA[<p>Java语言是静态类型的（statical typed)，也就是说所有变量和表达式的类型再编译时就已经完全确定。由于是statical typed，导致Java语言也是强类型（Strong typed）的。强类型意味着每个变量都具有一种类型，每个表达式具有一种类型，并且每种类型都是严格定义的，类型限制了变量可以hold哪些值，表达式最终产生什么值。同时限制了这些值可以进行的操作类型以及操作的具体方式。所有的赋值操作，无论是显式的还是在方法调用中通过参数传递，都要进行类型兼容性检查。</p><a id="more"></a><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在java源代码中，每个变量都必须声明一种类型（type）。有两种类型：primitive type和reference type。引用类型引用对象（reference to object），而基本类型直接包含值（directly contain value）。因此，Java数据类型（type）可以分为两大类：基本类型（primitive types）和引用类型（reference types）。primitive types 包括boolean类型以及数值类型（numeric types）。numeric types又分为整型（integer types）和浮点型（floating-point type）。整型有5种：byte short int long char(char本质上是一种特殊的int)。浮点类型有float和double。<br><img src="images/1908251" alt><br>对象是动态创建的类实例或者动态创建的数组。The value of reference types are references to objects，而引用一般是指内存地址。所有的对象（包括数组）支持Object类中定义的方法。String literals are presented by String object.</p><p>java有两种类型（type），与之相对应的是两种数据的值（two kinds of data values that can be stored in variable, pass as arguments and returned by methods)，这两只data values是：primitive values，reference values。也许这么理解起来更方便（虽然不严谨），Java变量有两种：primitive variable和reference variable，在变量中，它们分别存储primitive value和reference value。</p><p>null是一种特殊的type，但是你不能声明一个变量为null类型，null type的唯一取值就是null。null可以负值给任意的引用类型或者转化成任意的引用类型。在实践中，一般把null当做字面值（literal），这个字面值可是是任意的引用类型。</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>Java为基本类型提供语言级别的支持，即已经在Java中预定义，用相应的保留关键字表示。基本类型是单个值，而不是复杂的对象，基本类型不是面向对象的，主要出去效率方面的考虑，但是同时也提供基本类型的对象版本，即基本类型的包装器（wrapper）。可以直接使用这些基本类型，也可以使用基本类型构造数组或者其他自定义类型。基本类型具有明确的取值范围和数学行为。</p><p>基本类型，或者叫做内置类型，是JAVA中不同于类的特殊类型。它们是我们编程中使用最频繁的类型。java是一种强类型语言，第一次申明变量必须说明数据类型，第一次变量赋值称为变量的初始化。</p><h3 id="Java的简单类型及其封装器类"><a href="#Java的简单类型及其封装器类" class="headerlink" title="Java的简单类型及其封装器类"></a>Java的简单类型及其封装器类</h3><p>Java基本类型共有八种，基本类型可以分为三类，字符类型char，布尔类型boolean以及数值类型byte、short、int、long、float、double。数值类型又可以分为整数类型byte、short、int、long和浮点数类型float、double。JAVA中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者操作系统的改变而改变。实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。8种类型表示范围如下：</p><p>byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。</p><p>short：16位，最大数据存储量是65536，数据范围是-32768~32767之间。</p><p>int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。</p><p>long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。</p><p>float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。</p><p>double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。</p><p>boolean：只有true和false两个取值。</p><p>char：16位，存储Unicode码，用单引号赋值。<br>Java决定了每种简单类型的大小。这些大小并不随着机器结构的变化而变化。这种大小的不可更改正是Java程序具有很强移植能力的原因之一。下表列出了Java中定义的简单类型、占用二进制位数及对应的封装器类。</p><p><img src="images/1908252.png" alt><br>封装类为各个数据类型提供一些数据的操作方法，可以直接使用；</p><p>例如String跟int的互相转化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;21&quot;;int b = Integer.parseInt(a);//String 转int。</span><br><span class="line">int a = 21; String b = String.valueOf(a);//int转String。</span><br></pre></td></tr></table></figure><p>对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。如：</p><p>基本类型byte 二进制位数：Byte.SIZE最小值：Byte.MIN_VALUE最大值：Byte.MAX_VALUE</p><p>基本类型short二进制位数：Short.SIZE最小值：Short.MIN_VALUE最大值：Short.MAX_VALUE</p><p>基本类型char二进制位数：Character.SIZE最小值：Character.MIN_VALUE最大值：Character.MAX_VALUE</p><p>基本类型double 二进制位数：Double.SIZE最小值：Double.MIN_VALUE最大值：Double.MAX_VALUE</p><p>注意：float、double两种类型的最小值与Float.MIN_VALUE、 Double.MIN_VALUE的值并不相同，实际上Float.MIN_VALUE和Double.MIN_VALUE分别指的是 float和double类型所能表示的最小正数。也就是说存在这样一种情况，0到±Float.MIN_VALUE之间的值float类型无法表示，0 到±Double.MIN_VALUE之间的值double类型无法表示。这并没有什么好奇怪的，因为这些范围内的数值超出了它们的精度范围。</p><p>Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的”E+数字”表示E之前的数字要乘以10的多少倍。比如3.14E3就是3.14×1000=3140，3.14E-3就是3.14/1000=0.00314。</p><p>Java基本类型存储在栈中，因此它们的存取速度要快于存储在堆中的对应包装类的实例对象。从Java5.0（1.5）开始，JAVA虚拟机（Java Virtual Machine）可以完成基本类型和它们对应包装类之间的自动转换。因此我们在赋值、参数传递以及数学运算的时候像使用基本类型一样使用它们的包装类，但这并不意味着你可以通过基本类型调用它们的包装类才具有的方法。另外，所有基本类型（包括void）的包装类都使用了final修饰，因此我们无法继承它们扩展新的类，也无法重写它们的任何方法。</p><p>基本类型的优势：数据存储相对简单，运算效率比较高</p><p>包装类的优势：有的容易，比如集合的元素必须是对象类型，满足了java一切皆是对象的思想</p><h3 id="JAVA中的常量"><a href="#JAVA中的常量" class="headerlink" title="JAVA中的常量"></a>JAVA中的常量</h3><p>十六进制整型常量：以十六进制表示时，需以0x或0X开头，如0xff,0X9A。</p><p>八进制整型常量：八进制必须以0开头，如0123，034。</p><p>长整型：长整型必须以L作结尾，如9L,342L。</p><p>浮点数常量：由于小数常量的默认类型是double型，所以float类型的后面一定要加f(F)。同样带小数的变量默认为double类型。</p><p>如：float f;</p><pre><code>f=1.3f;//必须声明f。</code></pre><p>字符常量：字符型常量需用两个单引号括起来（注意字符串常量是用两个双引号括起来）。Java中的字符占两个字节。一些常用的转义字符：</p><p>①\r表示接受键盘输入，相当于按下了回车键；</p><p>②\n表示换行；</p><p>③\t表示制表符，相当于Table键；</p><p>④\b表示退格键，相当于Back Space键；</p><p>⑤&#39;表示单引号；</p><p>⑥&#39;‘表示双引号；</p><p>⑦\表示一个斜杠\。</p><h2 id="数据类型之间的转换"><a href="#数据类型之间的转换" class="headerlink" title="数据类型之间的转换"></a>数据类型之间的转换</h2><h3 id="简单类型数据间的转换"><a href="#简单类型数据间的转换" class="headerlink" title="简单类型数据间的转换"></a>简单类型数据间的转换</h3><p>两种方式:自动转换和强制转换,通常发生在表达式中或方法的参数传递时。</p><p>自动转换</p><p>具体地讲,当一个较”小”数据与一个较”大”的数据一起运算时,系统将自动将”小”数据转换成”大”数据,再进行运算。而在方法调用时,实际参数较”小”,而被调用的方法的形式参数数据又较”大”时(若有匹配的,当然会直接调用匹配的方法),系统也将自动将”小”数据转换成”大”数据,再进行方法的调用,自然,对于多个同名的重载方法,会转换成最”接近”的”大”数据并进行调用。这些类型由”小”到”大”分别为 (byte，short，char)–int–long–float—double。这里我们所说的”大”与”小”,并不是指占用字节的多少,而是指表示值的范围的大小。</p><ol><li><p>下面的语句可以在Java中直接通过：</p><p> byte b;int i=b; long l=b; float f=b; double d=b;</p></li><li><p>如果低级类型为char型，向高级类型（整型）转换时，会转换为对应ASCII码值，例如</p><p> char c=’c’; int i=c;</p><p> System.out.println(“output:”+i);输出：output:99;</p></li><li><p>对于byte,short,char三种类型而言，他们是平级的，因此不能相互自动转换，可以使用下述的强制类型转换。</p><p> short i=99 ; char c=(char)i; System.out.println(“output:”+c);输出：output:c;</p></li></ol><p>强制转换</p><p>将”大”数据转换为”小”数据时，你可以使用强制类型转换。即你必须采用下面这种语句格式： int n=(int)3.14159/2;可以想象，这种转换肯定可能会导致溢出或精度的下降。</p><h3 id="表达式的数据类型自动提升"><a href="#表达式的数据类型自动提升" class="headerlink" title="表达式的数据类型自动提升"></a>表达式的数据类型自动提升</h3><ol><li><p>所有的byte,short,char型的值将被提升为int型；</p></li><li><p>如果有一个操作数是long型，计算结果是long型；</p></li><li><p>如果有一个操作数是float型，计算结果是float型；</p></li><li><p>如果有一个操作数是double型，计算结果是double型；</p><p> 例， byte b; b=3; b=(byte)(b*3);//必须声明byte。</p></li></ol><h3 id="包装类过渡类型转换"><a href="#包装类过渡类型转换" class="headerlink" title="包装类过渡类型转换"></a>包装类过渡类型转换</h3><p>一般情况下，我们首先声明一个变量，然后生成一个对应的包装类，就可以利用包装类的各种方法进行类型转换了。例如：</p><ol><li><p>当希望把float型转换为double型时：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float f1=100.00f;</span><br><span class="line"></span><br><span class="line">Float F1=new Float(f1);</span><br><span class="line"></span><br><span class="line">double d1=F1.doubleValue();//F1.doubleValue()为Float类的返回double值型的方法</span><br></pre></td></tr></table></figure></li><li><p>当希望把double型转换为int型时：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double d1=100.00;</span><br><span class="line"></span><br><span class="line">Double D1=new Double(d1);</span><br><span class="line"></span><br><span class="line">int i1=D1.intValue();</span><br></pre></td></tr></table></figure><p> 简单类型的变量转换为相应的包装类，可以利用包装类的构造函数。即：Boolean(boolean value)、Character(char value)、Integer(int value)、Long(long value)、Float(float value)、Double(double value)</p><p> 而在各个包装类中，总有形为××Value()的方法，来得到其对应的简单类型数据。利用这种方法，也可以实现不同数值型变量间的转换，例如，对于一个双精度实型类，intValue()可以得到其对应的整型变量，而doubleValue()可以得到其对应的双精度实型变量。</p></li></ol><h3 id="字符串与其它类型间的转换"><a href="#字符串与其它类型间的转换" class="headerlink" title="字符串与其它类型间的转换"></a>字符串与其它类型间的转换</h3><p>其它类型向字符串的转换</p><ol><li><p>调用类的串转换方法:X.toString();</p></li><li><p>自动转换:X+””;</p></li><li><p>使用String的方法:String.volueOf(X);</p><p> 字符串作为值,向其它类型的转换</p></li><li><p>先转换成相应的封装器实例,再调用对应的方法转换成其它类型</p><p> 例如，字符中”32.1”转换double型的值的格式为:new Float(“32.1”).doubleValue()。也可以用:Double.valueOf(“32.1”).doubleValue()</p></li><li><p>静态parseXXX方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;1&quot;;</span><br><span class="line"></span><br><span class="line">byte b = Byte.parseByte( s );</span><br><span class="line"></span><br><span class="line">short t = Short.parseShort( s );</span><br><span class="line"></span><br><span class="line">int i = Integer.parseInt( s );</span><br><span class="line"></span><br><span class="line">long l = Long.parseLong( s );</span><br><span class="line"></span><br><span class="line">Float f = Float.parseFloat( s );</span><br><span class="line"></span><br><span class="line">Double d = Double.parseDouble( s );</span><br></pre></td></tr></table></figure></li><li><p>Character的getNumericValue(char ch)方法</p></li></ol><h3 id="Date类与其它数据类型的相互转换"><a href="#Date类与其它数据类型的相互转换" class="headerlink" title="Date类与其它数据类型的相互转换"></a>Date类与其它数据类型的相互转换</h3><p>整型和Date类之间并不存在直接的对应关系，只是你可以使用int型为分别表示年、月、日、时、分、秒，这样就在两者之间建立了一个对应关系，在作这种转换时，你可以使用Date类构造函数的三种形式：</p><ol><li><p>Date(int year, int month, int date)：以int型表示年、月、日</p></li><li><p>Date(int year, int month, int date, int hrs, int min)：以int型表示年、月、日、时、分</p></li><li><p>Date(int year, int month, int date, int hrs, int min, int sec)：以int型表示年、月、日、时、分、秒</p></li></ol><p>在长整型和Date类之间有一个很有趣的对应关系，就是将一个时间表示为距离格林尼治标准时间1970年1月1日0时0分0秒的毫秒数。对于这种对应关系，Date类也有其相应的构造函数：Date(long date)。</p><p>获取Date类中的年、月、日、时、分、秒以及星期你可以使用Date类的getYear()、getMonth()、getDate()、getHours()、getMinutes()、getSeconds()、getDay()方法，你也可以将其理解为将Date类转换成int。</p><p>而Date类的getTime()方法可以得到我们前面所说的一个时间对应的长整型数，与包装类一样，Date类也有一个toString()方法可以将其转换为String类。</p><p>有时我们希望得到Date的特定格式，例如20020324，我们可以使用以下方法，首先在文件开始引入，<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">java.util.Date date = new java.util.Date();</span><br><span class="line"></span><br><span class="line">//如果希望得到YYYYMMDD的格式</span><br><span class="line"></span><br><span class="line">SimpleDateFormat sy1=new SimpleDateFormat(&quot;yyyyMMDD&quot;);</span><br><span class="line"></span><br><span class="line">String dateFormat=sy1.format(date);</span><br><span class="line"></span><br><span class="line">//如果希望分开得到年，月，日</span><br><span class="line"></span><br><span class="line">SimpleDateFormat sy=new SimpleDateFormat(&quot;yyyy&quot;);</span><br><span class="line"></span><br><span class="line">SimpleDateFormat sm=new SimpleDateFormat(&quot;MM&quot;);</span><br><span class="line"></span><br><span class="line">SimpleDateFormat sd=new SimpleDateFormat(&quot;dd&quot;);</span><br><span class="line"></span><br><span class="line">String syear=sy.format(date);</span><br><span class="line"></span><br><span class="line">String smon=sm.format(date);</span><br><span class="line"></span><br><span class="line">String sday=sd.format(date);</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>只有boolean不参与数据类型的转换</p></li><li><p>自动类型的转换：</p><ul><li><p>常数在表数范围内是能够自动类型转换的</p></li><li><p>数据范围小的能够自动数据类型大的转换（注意特例）int到float，long到float，long到double 是不会自动转换的，不然将会丢失精度</p></li><li><p>引用类型能够自动转换为父类的</p></li><li><p>基本类型和它们包装类型是能够互相转换的</p></li></ul></li><li><p>强制类型转换：用圆括号括起来目标类型，置于变量前</p></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p>java开发过程中整型用int、小数用double、布尔用boolean；</p></li><li><p>类型转换都是小范围向大范围转换，大范围往小范围转化需要用到强制转换；<br> 例如：(1)int a=12; double b=a;(2) double a=3.0;int b=(int)a;</p></li><li><p>long, byte, char等很少用到，一般在数据处理的时候会用到；</p></li><li><p>int跟char之间的转换是通过ASCII转化的；<br> 例如：char a = ‘A’;int b = a; System.out.prientln(b);最后输出的结果为65；</p></li><li><p>String类型，String是项目中必不可少且使用最多的数据类型，它属于引用数据类型中“类”的范畴。</p></li></ol><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>Java有 5种引用类型（对象类型）：类 接口 数组 枚举 标注</p><p>引用类型：底层结构和基本类型差别较大</p><p>JVM的内存空间：</p><ol><li><p>Heap 堆空间：分配对象 new Student（）</p></li><li><p>Stack 栈空间：临时变量 Student stu</p></li><li><p>Code 代码区 ：类的定义，静态资源 Student.class</p><p> eg：Student stu = new Student（）； //new 在内存的堆空间创建对象</p><p> stu.study(); //把对象的地址赋给stu引用变量</p></li></ol><p>上例实现步骤：</p><ol><li><p>JVM加载Student.class 到Code区</p></li><li><p>new Student()在堆空间分配空间并创建一个Student实例</p></li><li><p>将此实例的地址赋值给引用stu， 栈空间</p></li></ol><p>Java把内存分成两种，一种叫做栈内存，一种叫做堆内存在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。堆内存用于存放由new创建的对象和数组。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名。</p><p>引用变量是普通变量，定义时在栈中分配内存，引用变量在程序运行到作用域外释放。而数组＆对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针! </p><h3 id="类Class"><a href="#类Class" class="headerlink" title="类Class"></a>类Class</h3><p>可以是我们创建的，主要是讲解几个java库中的类<br>Object ：Object是一个很重要的类，Object是类层次结构的根类，每个类都使用Object作为超类，所有对象（包括数组）都实现这个类的方法。用Object可以定义所有的类<br>如： Object object= new Integer(1); 来定义一个Interger类<br>     Integer i=(Integer) object;     在来把这个Object强制转换成Interger类 </p><p>String ：String类代表字符串，Java 程序中的所有字符串字面值（如”abc”）都作为此类的实例来实现。检查序列的单个字符、比较字符串、搜索字符串、提取子字符串、创建字符串副本、在该副本中、所有的字符都被转换为大写或小写形式。 </p><p>Date ：Date表示特定的瞬间，精确到毫秒。Date的类一般现在都被Calendar 和GregorianCalendar所有代替 </p><p>Void ：Void 类是一个不可实例化的占位符类，它保持一个对代表 Java 关键字 void 的 Class 对象的引用。</p><h3 id="接口interface"><a href="#接口interface" class="headerlink" title="接口interface"></a>接口interface</h3><p>可以是我们创建的，主要是讲解几个java库中的接口interface<br>List<e>：列表 ，此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引 （在列表中的位置）访问元素，并搜索列表中的元素。List 接口提供了两种搜索指定对象的方法。从性能的观点来看，应该小心使用这些方法。在很多实现中，它们将执行高开销的线性搜索。 List 接口提供了两种在列表的任意位置高效插入和移除多个元素的方法。<br>add() : 在列表的插入指定元素。<br>remove()：移除列表中指定位置的元素。<br>get(int index)：返回列表中指定位置的元素。</e></p><p>Map&lt;K,V&gt;：<br>K - 此映射所维护的键的类型<br>V - 映射值的类型 将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。<br>put(K key,V value)：将指定的值与此映射中的指定键关联（可选操作）。如果此映射以前包含一个该键的映射关系，则用指定值替换旧值（当且仅当，返回 true 时，才能说映射 m 包含键 k 的映射关系）。<br>remove(Object key)如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。更确切地讲，如果此 映射包含从满足(key==null ? k==null :key.equals(k))的键 k 到值 v 的映射关系，则移除该映射关系。（该映射最多只能包含一个这样的映射关系.） get(Object key)：返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。</p><h3 id="数组Array"><a href="#数组Array" class="headerlink" title="数组Array"></a>数组Array</h3><p>数组：存储在一个连续的内存块中的相同数据类型（引用数据类型）的元素集合。<br>数组中的每一个数据称之为数组元素，数组中的元素以索引来表示其存放的位置，索引（下标）从0开始。</p><p>数组的定义<br>第一种方式：类型[] 数组名; 如 int[] nums;<br>第二种方式：类型数组名[]; 如 int nums[];<br>大多数Java程序员喜欢使用第一种风格,因为它把数据类型int[],和变量名num分开了.</p><p>数组的初始化<br>Java中数组必先初始化后才能使用.<br>初始化就是给数组元素分配内存，并为每个元素赋初始值。</p><p>初始化数组的两种方式：</p><ol><li>静态初始化:<br> 语法格式:类型[] 数组名 = new 数组类型[]{元素1,元素2,元素3,…元素n};<br> 简化语法：类型[] 数组名 = {元素1,元素2,元素3…元素n};</li><li>动态初始化:<br> 如果我们事先不知道数组里存储哪些数据，只知道需要存储数据的个数，此时可以使用动态初始化方式。<br> 动态初始化：初始化时由我们指定数组的长度，系统自动为数组元素分配初始值。<br> 格式：类型[] 数组名 = new 数组类型[数组长度];</li></ol><p>注意:无论，以哪种方式初始化数组，一旦初始化完成，数组的长度就固定了，不能改变，除非重新初始化。也就是说数组是定长的。</p><h2 id="为什么Java里有基本数据类型和引用数据类型？"><a href="#为什么Java里有基本数据类型和引用数据类型？" class="headerlink" title="为什么Java里有基本数据类型和引用数据类型？"></a>为什么Java里有基本数据类型和引用数据类型？</h2><p>引用类型在堆里，基本类型在栈里。</p><p>栈空间小且连续，往往会被放在缓存。引用类型cache miss率高且要多一次解引用。</p><p>对象还要再多储存一个对象头，对基本数据类型来说空间浪费率太高</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSM配置问题总结</title>
      <link href="/SSM-configuration-summary.html"/>
      <url>/SSM-configuration-summary.html</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL安装配置及操作"><a href="#MySQL安装配置及操作" class="headerlink" title="MySQL安装配置及操作"></a>MySQL安装配置及操作</h2><h3 id="MySQL5-5"><a href="#MySQL5-5" class="headerlink" title="MySQL5.5"></a>MySQL5.5</h3><p>出现一个页面，点击这个“MySQL Community Server”标签。<br><img src="/images/1909051.PNG" alt><br>然后点击标签：Looking for previous GA versions?<br>选择mysql5.5.62<br>下载文件：mysql-5.5.62-win32.msi<br>一路next</p><a id="more"></a><h3 id="MySQL8"><a href="#MySQL8" class="headerlink" title="MySQL8"></a>MySQL8</h3><p>安装完成后进入MySQL的安装目录，进入MySQL Sever：bin目录下保存了MySQL常用的命令工具以及管理工具、data目录是MySQL默认用来保存数据文件以及日志文件的地方、docs目录下是MySQL的帮助文档、include目录和lib目录是MySQL所依赖的头文件以及库文件、share目录下保存目录文件以及日志文件。</p><p>进入bin目录，按住shift键然后点击鼠标右键可以选择在该目录下打开命令窗口，或者在地址栏中输入cmd进入命令窗口。输入mysql -u root -p后回车，然后会提示输入密码，输入密码后就会进入MySQL的操作管理界面。<br>输入show databases；（注意末尾有分号）可以查看当前MySQL中的数据库列表，输入use test；可以进入test数据库（前提是要有此数据库），输入show tables可以查看test数据库中的所有表，输入quit可以退出MySQL的操作管理界面。<br> ————————————————<br><a href="https://blog.csdn.net/theLostLamb/article/details/78797643" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/theLostLamb/article/details/78797643</a></p><h2 id="Mysql安装提示one-more-product-requirements-have-not-been-satisified"><a href="#Mysql安装提示one-more-product-requirements-have-not-been-satisified" class="headerlink" title="Mysql安装提示one more product requirements have not been satisified"></a>Mysql安装提示one more product requirements have not been satisified</h2><p>点击否，先关掉对话框，一定要先点击Execute，会先安装所需要的插件<br>若不执行excute,并且本地没有安装环境，第一次点击next安装会失败<br>执行excute之后，点击next此时仍会提示，选择OK继续安装即可，此时会安装成功<br> ————————————————<br><a href="https://blog.csdn.net/weixin_41996632/article/details/84934635" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/weixin_41996632/article/details/84934635</a><br><a href="https://blog.csdn.net/m0_37860933/article/details/81981663" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/m0_37860933/article/details/81981663</a></p><h2 id="Tomcat服务器下载、安装、配置环境变量"><a href="#Tomcat服务器下载、安装、配置环境变量" class="headerlink" title="Tomcat服务器下载、安装、配置环境变量"></a>Tomcat服务器下载、安装、配置环境变量</h2><p>Windows键+R，输入cmd，回车<br>输入 startup.bat 后回车（你也可以到你解压的tomcat文件夹下的bin目录中点击startup.bat）<br>之后出现了Tomcat的启动窗口，若没有报错或者一闪而过，那么说明启动成功了，让黑窗口保持运行，不能关，否则你的服务器也就关闭了<br>可以直接点击进入<a href="http://localhost:8080/" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/</a><br> ————————————————<br><a href="https://blog.csdn.net/qq_40881680/article/details/83582484" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/qq_40881680/article/details/83582484</a></p><h2 id="Eclipse项目配置maven"><a href="#Eclipse项目配置maven" class="headerlink" title="Eclipse项目配置maven"></a>Eclipse项目配置maven</h2><p>没什么问题<br> ————————————————<br> <a href="https://blog.csdn.net/feidi7783/article/details/80523030" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/feidi7783/article/details/80523030</a></p><h2 id="Eclipse配置Tomcat找不到server或者eclipse不支持tomcat8、tomcat8-5、tomcat9-0"><a href="#Eclipse配置Tomcat找不到server或者eclipse不支持tomcat8、tomcat8-5、tomcat9-0" class="headerlink" title="Eclipse配置Tomcat找不到server或者eclipse不支持tomcat8、tomcat8.5、tomcat9.0"></a>Eclipse配置Tomcat找不到server或者eclipse不支持tomcat8、tomcat8.5、tomcat9.0</h2><p>不用安装JST Server AdaptersExtensions 没有用<br>直接重新安装下载eclipse时，版本选择要选javaEE而不是第一个，之后再打开什么都有了<br>官方网址：<a href="http://www.eclipse.org/downloads/" rel="external nofollow noopener noreferrer" target="_blank">http://www.eclipse.org/downloads/</a> </p><h2 id="Eclipse添加Tomcat"><a href="#Eclipse添加Tomcat" class="headerlink" title="Eclipse添加Tomcat"></a>Eclipse添加Tomcat</h2><p><img src="images/1908221.png" alt="结构"><br><a href="https://jingyan.baidu.com/article/e5c39bf5c8afd039d660335b.html" rel="external nofollow noopener noreferrer" target="_blank">https://jingyan.baidu.com/article/e5c39bf5c8afd039d660335b.html</a></p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前后端分离</title>
      <link href="/Front-and-back-end-separation.html"/>
      <url>/Front-and-back-end-separation.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前后端分离已成为互联网项目开发的业界标准使用方式，通过nginx+tomcat的方式（也可以中间加一个nodejs）有效的进行解耦，并且前后端分离会为以后的大型分布式架构、弹性计算架构、微服务架构、多端化服务（多种客户端，例如：浏览器，车载终端，安卓，IOS等等）打下坚实的基础。这个步骤是系统架构从猿进化成人的必经之路。</p><a id="more"></a><p>核心思想是前端html页面通过ajax调用后端的restuful api接口并使用json数据进行交互。</p><blockquote><p>  名词解释：<br>    在互联网架构中，<br>    web服务器：一般指像nginx，apache这类的服务器，他们一般只能解析静态资源。<br>    应用服务器：一般指像tomcat，jetty，resin这类的服务器可以解析动态资源也可以解析静态资源，但解析静态资源的能力没有web服务器好。<br>    一般都是只有web服务器才能被外网访问，应用服务器只能内网访问。</p></blockquote><h2 id="术业有专攻"><a href="#术业有专攻" class="headerlink" title="术业有专攻"></a>术业有专攻</h2><p>以前的JavaWeb项目大多数都是java程序员又当爹又当妈，又搞前端（ajax/jquery/js/html/css等等），又搞后端（java/mysql/oracle等等）。</p><p>随着时代的发展，渐渐的许多大中小公司开始把前后端的界限分的越来越明确，前端工程师只管前端的事情，后端工程师只管后端的事情。正所谓术业有专攻，一个人如果什么都会，那么他毕竟什么都不精。</p><p>大中型公司需要专业人才，小公司需要全才，但是对于个人职业发展来说，建议是分开。</p><h3 id="对于后端java工程师："><a href="#对于后端java工程师：" class="headerlink" title="对于后端java工程师："></a>对于后端java工程师：</h3><p>把精力放在java基础，设计模式，jvm原理，spring+springmvc原理及源码，linux，mysql事务隔离与锁机制，mongodb，http/tcp，多线程，分布式架构（dubbo，dubbox，spring cloud），弹性计算架构，微服务架构（springboot+zookeeper+docker+jenkins），java性能优化，以及相关的项目管理等等。</p><p>后端追求的是：三高（高并发，高可用，高性能），安全，存储，业务等等。</p><h3 id="对于前端工程师："><a href="#对于前端工程师：" class="headerlink" title="对于前端工程师："></a>对于前端工程师：</h3><p>把精力放在html5，css3，jquery，angularjs，bootstrap，reactjs，vuejs，webpack，less/sass，gulp，nodejs，Google V8引擎，javascript多线程，模块化，面向切面编程，设计模式，浏览器兼容性，性能优化等等。</p><p>前端追求的是：页面表现，速度流畅，兼容性，用户体验等等。</p><p>术业有专攻，这样你的核心竞争力才会越来越高，正所谓你往生活中投入什么，生活就会反馈给你什么。并且两端的发展都越来越高深，你想什么都会，那你毕竟什么都不精。</p><p>通过将team分成前后端team，让两边的工程师更加专注各自的领域，独立治理，然后构建出一个全栈式的精益求精的team。</p><h2 id="原始人时代（各种耦合）"><a href="#原始人时代（各种耦合）" class="headerlink" title="原始人时代（各种耦合）"></a>原始人时代（各种耦合）</h2><p>几曾何时，我们的JavaWeb项目都是使用了若干后台框架，springmvc/struts + spring + spring jdbc/hibernate/mybatis 等等。</p><p>大多数项目在java后端都是分了三层，控制层（controller/action），业务层（service/manage），持久层（dao）。控制层负责接收参数，调用相关业务层，封装数据，以及路由&amp;渲染到jsp页面。然后jsp页面上使用各种标签（jstl/el/struts标签等）或者手写java表达式（&lt;%=%&gt;）将后台的数据展现出来，玩的是MVC那套思路。</p><p>我们先看这种情况：需求定完了，代码写完了，测试测完了，然后呢？要发布了吧？你需要用maven或者eclipse等工具把你的代码打成一个war包，然后把这个war包发布到你的生产环境下的web容器（tomcat/jboss/weblogic/websphere/jetty/resin）里，对吧？</p><p>发布完了之后，你要启动你的web容器，开始提供服务，这时候你通过配置域名，dns等等相关，你的网站就可以访问了（假设你是个网站）。那我们来看，你的前后端代码是不是全都在那个war包里？包括你的js，css，图片，各种第三方的库，对吧？</p><p>好，下面在浏览器中输入你的网站域名<a href="http://www.xxx.com，之后发生了什么？（这个问题也是很多公司的面试题）我捡干的说了啊，基础不好的童鞋请自己去搜。" rel="external nofollow noopener noreferrer" target="_blank">www.xxx.com，之后发生了什么？（这个问题也是很多公司的面试题）我捡干的说了啊，基础不好的童鞋请自己去搜。</a></p><p>浏览器在通过域名通过dns服务器找到你的服务器外网ip,将http请求发送到你的服务器，在tcp3次握手之后（http下面是tcp/ip），通过tcp协议开始传输数据，你的服务器得到请求后，开始提供服务，接收参数，之后返回你的应答给浏览器，浏览器再通过content-type来解析你返回的内容，呈现给用户。</p><p>那么我们来看，我们先假设你的首页中有100张图片，此时，用户的看似一次http请求，其实并不是一次，用户在第一次访问的时候，浏览器中不会有缓存，你的100张图片，浏览器要连着请求100次http请求（有人会跟我说http长连短连的问题，不在这里讨论），你的服务器接收这些请求，都需要耗费内存去创建socket来玩tcp传输（消耗你服务器上的计算资源）。</p><p>重点来了，这样的话，你的服务器的压力会非常大，因为页面中的所有请求都是只请求到你这台服务器上，如果1个人还好，如果10000个人并发访问呢（先不聊服务器集群，这里就说是单实例服务器），那你的服务器能扛住多少个tcp连接？你的带宽有多大？你的服务器的内存有多大？你的硬盘是高性能的吗？你能抗住多少IO？你给web服务器分的内存有多大？会不会宕机？</p><p>这就是为什么，越是大中型的web应用，他们越是要解耦。理论上你可以把你的数据库+应用服务+消息队列+缓存+用户上传的文件+日志+等等都扔在一台服务器上，你也不用玩什么服务治理，也不用做什么性能监控，什么报警机制等等，就乱成一锅粥好了。但是这样就好像是你把鸡蛋都放在一个篮子里，隐患非常大。如果因为一个子应用的内存不稳定导致整个服务器内存溢出而hung住，那你的整个网站就挂掉了。</p><p>如果出意外挂掉，而恰好这时你们的业务又处于井喷式发展高峰期，那么恭喜你，业务成功被技术卡住，很可能会流失大量用户，后果不堪设想。（注意：技术一定是要走在业务前面的，否则你将错过最佳的发展期）</p><p>此外，你的应用全部都耦合在一起，相当于一个巨石，当服务端负载能力不足时，一般会使用负载均衡的方式，将服务器做成集群，这样其实你是在水平扩展一块块巨石，性能加速度会越来越低，要知道，本身负载就低的功能or模块是没有必要水平扩展的，在本文中的例子就是你的性能瓶颈不在前端，那干嘛要水平扩展前端呢？？？还有发版部署上线的时候，我明明只改了后端的代码，为什么要前端也跟着发布呢？？？</p><p>正常的互联网架构，是都要拆开的，你的web服务器集群，你的应用服务器集群+文件服务器集群+数据库服务器集群+消息队列集群+缓存集群等等。</p><h2 id="JSP的痛点"><a href="#JSP的痛点" class="headerlink" title="JSP的痛点"></a>JSP的痛点</h2><p>以前的javaWeb项目大多数使用jsp作为页面层展示数据给用户，因为流量不高，因此也没有那么苛刻的性能要求，但现在是大数据时代，对于互联网项目的性能要求是越来越高，因此原始的前后端耦合在一起的架构模式已经逐渐不能满足我们，因此我们需要需找一种解耦的方式，来大幅度提升我们的负载能力。</p><ol><li><p>动态资源和静态资源全部耦合在一起，服务器压力大，因为服务器会收到各种http请求，例如css的http请求，js的，图片的等等。一旦服务器出现状况，前后台一起玩完，用户体验极差。</p></li><li><p>UI出好设计图后，前端工程师只负责将设计图切成html，需要由java工程师来将html套成jsp页面，出错率较高（因为页面中经常会出现大量的js代码），修改问题时需要双方协同开发，效率低下。</p></li><li><p>jsp必须要在支持java的web服务器里运行（例如tomcat，jetty，resin等），无法使用nginx等（nginx据说单实例http并发高达5w，这个优势要用上），性能提不上来。</p></li><li><p>第一次请求jsp，必须要在web服务器中编译成servlet，第一次运行会较慢。</p></li><li><p>每次请求jsp都是访问servlet再用输出流输出的html页面，效率没有直接使用html高</p></li><li><p>jsp内有较多标签和表达式，前端工程师在修改页面时会捉襟见肘，遇到很多痛点。</p></li><li><p>如果jsp中的内容很多，页面响应会很慢，因为是同步加载。</p></li><li><p>需要前端工程师使用java的ide（例如eclipse），以及需要配置各种后端的开发环境，你们有考虑过前端工程师的感受吗。</p></li></ol><h2 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h2><p>以前老的方式是： </p><ol><li>产品经历/领导/客户提出需求 </li><li>UI做出设计图 </li><li>前端工程师做html页面 </li><li>后端工程师将html页面套成jsp页面（前后端强依赖，后端必须要等前端的html做好才能套jsp。如果html发生变更，就更痛了，开发效率低） </li><li>集成出现问题 </li><li>前端返工 </li><li>后端返工 </li><li>二次集成 </li><li>集成成功 </li><li>交付</li></ol><p>新的方式是： </p><ol><li>产品经历/领导/客户提出需求 </li><li>UI做出设计图 </li><li>前后端约定接口&amp;数据&amp;参数 </li><li>前后端并行开发（无强依赖，可前后端并行开发，如果需求变更，只要接口&amp;参数不变，就不用两边都修改代码，开发效率高） </li><li>前后端集成 </li><li>前端页面调整 </li><li>集成成功 </li><li>交付</li></ol><h2 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h2><p>以前老的方式是： </p><ol><li>客户端请求 </li><li>服务端的servlet或controller接收请求（后端控制路由与渲染页面，整个项目开发的权重大部分在后端） </li><li>调用service,dao代码完成业务逻辑 </li><li>返回jsp </li><li>jsp展现一些动态的代码</li></ol><p>新的方式是： </p><ol><li>浏览器发送请求 </li><li>直接到达html页面（前端控制路由与渲染页面，整个项目开发的权重前移） </li><li>html页面负责调用服务端接口产生数据（通过ajax等等，后台返回json格式数据，json数据格式因为简洁高效而取代xml） </li><li>填充html，展现动态效果，在页面上进行解析并操作DOM。<br>（有兴趣的童鞋可以访问一下阿里巴巴等大型网站，然后按一下F12，监控一下你刷新一次页面，他的http是怎么玩的，大多数都是单独请求后台数据，使用json传输数据，而不是一个大而全的http请求把整个页面包括动+静全部返回过来）</li></ol><p>总结一下新的方式的请求步骤：<br>大量并发浏览器请求—&gt;web服务器集群(nginx)—&gt;应用服务器集群(tomcat)—&gt;文件/数据库/缓存/消息队列服务器集群<br>同时又可以玩分模块，还可以按业务拆成一个个的小集群，为后面的架构升级做准备。</p><h2 id="前后分离的优势"><a href="#前后分离的优势" class="headerlink" title="前后分离的优势"></a>前后分离的优势</h2><ol><li><p>可以实现真正的前后端解耦，前端服务器使用nginx。前端/WEB服务器放的是css，js，图片等等一系列静态资源（甚至你还可以css，js，图片等资源放到特定的文件服务器，例如阿里云的oss，并使用cdn加速），前端服务器负责控制页面引用&amp;跳转&amp;路由，前端页面异步调用后端的接口，后端/应用服务器使用tomcat（把tomcat想象成一个数据提供者），加快整体响应速度。（这里需要使用一些前端工程化的框架比如nodejs，react，router，react，redux，webpack）</p></li><li><p>发现bug，可以快速定位是谁的问题，不会出现互相踢皮球的现象。页面逻辑，跳转错误，浏览器兼容性问题，脚本错误，页面样式等问题，全部由前端工程师来负责。接口数据出错，数据没有提交成功，应答超时等问题，全部由后端工程师来解决。双方互不干扰，前端与后端是相亲相爱的一家人。</p></li><li><p>在大并发情况下，我可以同时水平扩展前后端服务器，比如淘宝的一个首页就需要2000+台前端服务器做集群来抗住日均多少亿+的日均pv。（去参加阿里的技术峰会，听他们说他们的web容器都是自己写的，就算他单实例抗10万http并发，2000台是2亿http并发，并且他们还可以根据预知洪峰来无限拓展，很恐怖，就一个首页。。。）</p></li><li><p>减少后端服务器的并发/负载压力。除了接口以外的其他所有http请求全部转移到前端nginx上，接口的请求调用tomcat，参考nginx反向代理tomcat。且除了第一次页面请求外，浏览器会大量调用本地缓存。</p></li><li><p>即使后端服务暂时超时或者宕机了，前端页面也会正常访问，只不过数据刷不出来而已。</p></li><li><p>也许你也需要有微信相关的轻应用，那样你的接口完全可以共用，如果也有app相关的服务，那么只要通过一些代码重构，也可以大量复用接口，提升效率。（多端应用）</p></li><li><p>页面显示的东西再多也不怕，因为是异步加载。</p></li><li><p>nginx支持页面热部署，不用重启服务器，前端升级更无缝。</p></li><li><p>增加代码的维护性&amp;易读性（前后端耦在一起的代码读起来相当费劲）。</p></li><li><p>提升开发效率，因为可以前后端并行开发，而不是像以前的强依赖。</p></li><li><p>在nginx中部署证书，外网使用https访问，并且只开放443和80端口，其他端口一律关闭（防止黑客端口扫描），内网使用http，性能和安全都有保障。</p></li><li><p>前端大量的组件代码得以复用，组件化，提升开发效率，抽出来！</p></li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><p>在开需求会议的时候，前后端工程师必须全部参加，并且需要制定好接口文档，后端工程师要写好测试用例（2个维度），不要让前端工程师充当你的专职测试，推荐使用chrome的插件postman或soapui或jmeter，service层的测试用例拿junit写。ps：前端也可以玩单元测试吗？</p></li><li><p>上述的接口并不是java里的interface，说白了调用接口就是调用你controler里的方法。</p></li><li><p>加重了前端团队的工作量，减轻了后端团队的工作量，提高了性能和可扩展性。</p></li><li><p>我们需要一些前端的框架来解决类似于页面嵌套，分页，页面跳转控制等功能。（上面提到的那些前端框架）。</p></li><li><p>以前还有人在使用类似于velocity/freemarker等模板框架来生成静态页面，仁者见仁智者见智。</p></li><li><p>这篇文章主要的目的是说jsp在大型外网java web项目中被淘汰掉，可没说jsp可以完全不学，jsp/servlet等相关的java web基础还是要掌握牢的，不然你以为springmvc这种框架是基于什么来写的？</p></li><li><p>如果页面上有一些权限等等相关的校验，那么这些相关的数据也可以通过ajax从接口里拿。</p></li><li><p>对于既可以前端做也可以后端做的逻辑，我建议是放到前端，为什么？因为你的逻辑需要计算资源进行计算，如果放到后端去run逻辑，则会消耗带宽&amp;内存&amp;cpu等等计算资源，你要记住一点就是服务端的计算资源是有限的，而如果放到前端，使用的是客户端的计算资源，这样你的服务端负载就会下降（高并发场景）。类似于数据校验这种，前后端都需要做！</p></li><li><p>前端需要有机制应对后端请求超时以及后端服务宕机的情况，友好的展示给用户。</p></li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li><p>其实对于js，css，图片这类的静态资源可以考虑放到类似于阿里云的oss这类文件服务器上（如果是普通的服务器&amp;操作系统，存储在到达pb级的文件后，或者单个文件夹内的文件数量达到3-5万，io会有很严重的性能问题），再在oss上配cdn（全国子节点加速），这样你页面打开的速度像飞一样， 无论你在全国的哪个地方，并且你的nginx的负载会进一步降低。</p></li><li><p>如果你要玩轻量级微服务架构，要使用nodejs做网关，用nodejs的好处还有利于seo优化，因为nginx只是向浏览器返回页面静态资源，而国内的搜索引擎爬虫只会抓取静态数据，不会解析页面中的js，这使得应用得不到良好的搜索引擎支持。同时因为nginx不会进行页面的组装渲染，需要把静态页面返回到浏览器，然后完成渲染工作，这加重了浏览器的渲染负担。浏览器发起的请求经过nginx进行分发，URL请求统一分发到nodejs，在nodejs中进行页面组装渲染；API请求则直接发送到后端服务器，完成响应。</p></li><li><p>如果遇到跨域问题，spring4的CORS可以完美解决，但一般使用nginx反向代理都不会有跨域问题，除非你把前端服务和后端服务分成两个域名。JSONP的方式也被淘汰掉了。</p></li><li><p>如果想玩多端应用，注意要去掉tomcat原生的session机制，要使用token机制，使用缓存（因为是分布式系统），做单点，对于token机制的安全性问题，可以搜一下jwt。</p></li><li><p>前端项目中可以加入mock测试（构造虚拟测试对象来模拟后端，可以独立开发和测试），后端需要有详细的测试用例，保证服务的可用性与稳定性。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前后端分离并非仅仅只是一种开发模式，而是一种架构模式（前后端分离架构）。不要以为只有在撸代码的时候把前端和后端分开就是前后端分离了，需要区分前后端项目。前端项目与后端项目是两个项目，放在两个不同的服务器，需要独立部署，两个不同的工程，两个不同的代码库，不同的开发人员。前后端工程师需要约定交互接口，实现并行开发，开发结束后需要进行独立部署，前端通过ajax来调用http请求调用后端的restful api。前端只需要关注页面的样式与动态数据的解析&amp;渲染，而后端专注于具体业务逻辑。</p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://2014.jsconf.cn/slides/herman-taobaoweb/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://2014.jsconf.cn/slides/herman-taobaoweb/index.html</a><br><a href="https://mp.weixin.qq.com/s/bSl1FKWFznVzn_1wbBoOCA" rel="external nofollow noopener noreferrer" target="_blank">https://mp.weixin.qq.com/s/bSl1FKWFznVzn_1wbBoOCA</a><br><a href="https://zhuanlan.zhihu.com/p/20534796" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/20534796</a><br><a href="https://blog.csdn.net/dream_cat_forever/article/details/80709503" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/dream_cat_forever/article/details/80709503</a></p>]]></content>
      
      
      <categories>
          
          <category> 前后端分离 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cookie and session</title>
      <link href="/Cookie-and-session.html"/>
      <url>/Cookie-and-session.html</url>
      
        <content type="html"><![CDATA[<h2 id="Cookie的作用"><a href="#Cookie的作用" class="headerlink" title="Cookie的作用"></a>Cookie的作用</h2><p>Cookie是用来记录服务器和客户端的状态，或者说记录用户的登录信息。<br>我们的HTTP是无连接的，所以我们需要Cookie来进行用户和连接信息的记录。<br>利用cookie我们就可以跟踪用户了</p><a id="more"></a><ol><li>在HTTP响应报文中有一个cookie的首部行Set-Cookie</li><li>HTTP请求报文中有一个cookie的首部行，每次请求都会加上这个cookie</li><li>客户端保存一个cookie，用户浏览器管理</li><li>web站点服务器有一个数据库，当服务器解析接收到的请求报文中的cookie时就可以根据这个cookie中的值来判断是哪个用户或者说是哪个id，然后如果需要返回特定的信息就去数据库中获取然后返回给客户端。</li></ol><h3 id="Cookie的问题"><a href="#Cookie的问题" class="headerlink" title="Cookie的问题"></a>Cookie的问题</h3><p>我们单纯使用cookie来做用户认证，其实是非常大风险的。 因为服务器没有什么手段来判断这个cookie是不是我们的真实用户说发送的，很多第三方可以获取到这个cookie，里面的信息就可以被它用来伪造HTTP请求获取我们服务器的数据了。</p><h2 id="引入Session"><a href="#引入Session" class="headerlink" title="引入Session"></a>引入Session</h2><p>session会话机制。<br>Session一般是指浏览器这个页面打开到关闭的这段时间。所谓的使用session机制其实就是不把用户信息存到浏览器(客户端)而是全部存到服务器上，我们只存一个被称为sessionid的值作为cookie存在浏览器端。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Session原理是服务端端每一个session维护一份会话信息数据，客户端和服务端依靠一个全局唯一标识sesssion_id来访问会话信息数据。用户访问web应用时，服务端程序决定何时创建session。</p><p><strong>对于Java后台来说</strong><br>其实我们可以认为，Session是调用HttpServletRequest.getSession(true)这样的语句时才被创建。这里的Session就是一个Java对象了，提供给请求者使用。 服务器再次接受到请求的时候就会收到这个Sesssion_id，然后根据ID在内存中找到之前创建的session对象，提供给请求者使用。</p><p>Session一般放在内存中，一旦服务器重启或者进程停止就会被清空。设置了session持久化才能使得重启服务器都能拿到session。</p><h3 id="Session删除时间"><a href="#Session删除时间" class="headerlink" title="Session删除时间"></a>Session删除时间</h3><ol><li>Session超时：超时指的是连续一定时间服务器没有收到该Session所对应客户端的请求，并且这个时间超过了服务器设置的Session超时的最大时间。 </li><li>程序调用HttpSession.invalidate() </li><li>服务器关闭或服务停止</li></ol><p>session的id是从哪里来的，sessionID是如何使用的：当客户端第一次请求session对象时候，服务器会为客户端创建一个session，并将通过特殊算法算出一个session的ID，用来标识该session对象，当浏览器下次（session继续有效时）请求别的资源的时候，浏览器会将sessionID(实质是cookie)放置到请求头中，服务器接收到请求后就得到该请求的sessionID，服务器找到该id的session返还给请求者（Servlet）使用。一个会话只能有一个session对象，对session来说是只认id不认人。</p><p>对于Java后台来说，session是一个容器，可以存放会话过程中的任何对象</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>Session机制中，数据是存储在服务器上面，所以你不能伪造，你要获得这些数据就必须使用服务提供的sesssion_id，Cookie是保存在客户端的，安全性很难得到保证。</p><p>其实我们使用session的话session是不会因为浏览器的关闭而删除的。</p><h3 id="关于session-id的时效性"><a href="#关于session-id的时效性" class="headerlink" title="关于session_id的时效性"></a>关于session_id的时效性</h3><p>一般来说我们用session保持持久连接，也就是用户登录认证通过后，保持对这个用户的识别。 但是我们这个登录必须设置一个时效，也就是说登录了一段时间后我们要求用户重新登录。<br>其实也就是设置cookie(session_ID)的有效时间，当超过时了这个session_Id就无效了，我们就要再次登录，再次输入认证信息，然后服务器接收这些信息再次生成一个新的session，并把用户认证的信息存入这个session。<br>一般session也是有有效期的，可能是用户主要销毁，比如登出操作，这个session就销毁了。</p><h2 id="Session和Cookie过期的对比"><a href="#Session和Cookie过期的对比" class="headerlink" title="Session和Cookie过期的对比"></a>Session和Cookie过期的对比</h2><h3 id="首先Cookie过期"><a href="#首先Cookie过期" class="headerlink" title="首先Cookie过期"></a>首先Cookie过期</h3><p>Cookie一般有两种，一种是不设置过期时间，浏览器关闭就过期，一种是设置过期时间，存在硬盘中，下次打开浏览器仍然存在。<br>注意一般来说，cookie过期的话，再次打开浏览器就会被删除了.</p><h3 id="再者Session-id和session"><a href="#再者Session-id和session" class="headerlink" title="再者Session_id和session"></a>再者Session_id和session</h3><p>Session的话其实主要看session_id，大部分的会话机制是利用session_id(也是cookie)，如果cookie过期了也就是session_id过期了，那么显然服务器中的session也会结束生命周期(被销毁)。(如果浏览器没有删除cookie，你发送了一个过期的cookie，服务器需要判断然后就会拒绝你的请求)</p><h3 id="Session过期"><a href="#Session过期" class="headerlink" title="Session过期"></a>Session过期</h3><p>session自动失效：一般服务器也会设置Session的过期时间，一旦session过期了，就算客户端的cookie(session_id)没有过期，session照样会结束自己的生命周期。</p><h2 id="SessionID如何产生，由谁产生，保存在哪？"><a href="#SessionID如何产生，由谁产生，保存在哪？" class="headerlink" title="SessionID如何产生，由谁产生，保存在哪？"></a>SessionID如何产生，由谁产生，保存在哪？</h2><p><strong>创建：</strong><br>服务器端程序运行的过程中创建的，不同语言实现的应用程序有不同创建Session的方法，而在Java中是通过调用HttpServletRequest的getSession方法（使用true作为参数）创建的。</p><p><strong>sessionid生成算法</strong><br>tomcat的ManagerBase类提供创建sessionid的方法：随机数+时间+jvmid；</p><p><strong>存储在内存中。</strong></p><p><strong>如何持久化？</strong> cookie memcache redis 存到数据库中</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>No java virtual machine was found</title>
      <link href="/No-java-virtual-machine-was-found.html"/>
      <url>/No-java-virtual-machine-was-found.html</url>
      
        <content type="html"><![CDATA[<p>第一次运行Eclipse,经常会提示下面的问题:<br>… No java virtual machine  was found after searching the follwing locations”…./javaw.exe” in your current path。<br><img src="/images/1909061.jpg" alt></p><a id="more"></a><p>意思：在指定路径“…./javaw.exe”没有找到javaw.exe。因为Eclipse启动时需要javaw.exe来启动。先查找path中各个目录以后,没有找到；就会查看就会固定地在eclipse的安装目录(如d:javaeclipse)下查找。即：先找外面装了没有；若没有则找自己带了没有。如果都没有找到,就报上面的错误。</p><p>根据提示：Eclipse要javaw.exe才能运行。所以要设置path,让Eclipse通过path变量中的路径找到javaw.exe就可以了。<br>解决：</p><ol><li>在Path中设置javaw.exe的路径,如：</li><li>或修改eclipse.ini 文件，在最前面加上下面两行内容：<br> -vm<br> D:/java/jdk1.6.0_10/bin/javaw.exe</li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse解决editor does not contain a main type</title>
      <link href="/editor-does-not-contain-a-main-type.html"/>
      <url>/editor-does-not-contain-a-main-type.html</url>
      
        <content type="html"><![CDATA[<p>Eclipse／MyEclipse下有main函数类运行报错:Editor does not contain a main type<br>解决方法：在左侧的package explorer中右击这个class所在包的上一级目录–build path–use as source folder。这样就解决问题了。<br>出现这种问题的原因是，该java文件所在的包没有被MyEclipse认定为源码包。处理方法如下：</p><a id="more"></a><ol><li>打开Java Build Path窗口，并选择Source界面:<br><img src="images/1909062" alt></li><li>点击 Add Folder，在对话框中选择该类的根级包，后点确定：<br><img src="images/1909063" alt></li><li>之后点击确定，等待工作空间build好以后,该项目如下图所示，即为成功：<br><img src="images/1909064" alt></li><li>出现文件夹带 “田” 图标的就是成功了，现在就，可以运行改类的main方法了.</li></ol><p>最后，解释下，什么叫“在build path中”？你可以这么理解，eclipse中，在build path下的类可以被编译运行，在build path下的配置文件可以被类以相对路径直接读写。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>思想的转变</title>
      <link href="/change-of-mind.html"/>
      <url>/change-of-mind.html</url>
      
        <content type="html"><![CDATA[<h2 id="不要把自己当学生，而是要把自己当开发者"><a href="#不要把自己当学生，而是要把自己当开发者" class="headerlink" title="不要把自己当学生，而是要把自己当开发者"></a>不要把自己当学生，而是要把自己当开发者</h2><p>不同的身份认同感，最后会导致不同的行为模式，而这行为模式，会对你的编程学习造成非常大的影响。</p><a id="more"></a><h3 id="区别一：记笔记-VS-写技术文章"><a href="#区别一：记笔记-VS-写技术文章" class="headerlink" title="区别一：记笔记 VS 写技术文章"></a>区别一：记笔记 VS 写技术文章</h3><p>学生有一个特点，就是他们喜欢记笔记，但是开发者不怎么记笔记，而是会把自己学会的东西写成技术文章、教程的形式发表在技术博客或者知乎等网站上。</p><p>一个很有名的学习法叫做<b>费曼学习法</b>，这个学习方法简单地说，就是在学完一个东西之后，去给别人讲明白，注意，是讲给别人听，当你写成文章发表在网上的时候，你自然会去用更通俗的语言，更清晰的逻辑去讲述这个事物背后的逻辑，这个过程，是对自己学习的一个检验，也是加深映像，整理思路的重要过程。</p><p>那么如果你是去记笔记的话，很有可能，你不会去试图讲清楚这个东西，而是倾向于去照抄，或是不完全照抄，以“提纲”或是“知识点”的形式抄在本子上，说句实话，照抄的笔记，真的没用，因为现在搜索引擎的能力已经可以让你把大多数东西快速找到，你为什么还要照抄到笔记本上呢？</p><p>从功利的角度考虑，技术文章的写作，别人可以直接访问，也可以逐渐累积你的影响力，一个好的个人技术博客，会给你的简历加分很多，而一个厚厚的笔记本，没有人会管你记了什么。</p><h3 id="区别二：以学会XX为目标-VS-以做出XX为目标"><a href="#区别二：以学会XX为目标-VS-以做出XX为目标" class="headerlink" title="区别二：以学会XX为目标 VS 以做出XX为目标"></a>区别二：以学会XX为目标 VS 以做出XX为目标</h3><p>学生思维里面有一个重要的特点，就是他们总是特别关注自己“学会了什么”，不仅如此，他给自己定的目标，定的计划，永远都是”学会XX书第XX章内容“。</p><p><b>学生永远在准备, 而开发者早已动手。</b></p><p>学生思维是“这个学期我要学会XX课程”，而开发者思维是“这个学期我要做出XX”。</p><p>如果学Python，学生思维会拿起一本教材，开始从头到尾看，我不知道你们发现没有，几乎所有那种编程语言教材，长得都差不多，上来先是基本的语法，基本的整型变量，浮点型变量之类的，然后伴随着几个小的教学例子。</p><p>开发者学Python，他第一步绝对不是去书店买教材，而是先去了解，<b>Python</b>适合做什么，然后他了解到，Python适合做<b>爬虫，数据分析，AI，还能很轻松地搭建Web后端，</b>之后他逛了一下午<b>Github</b>，看了看那些Python高星项目都是做啥的，于是他给自己定下了这个目标：</p><p>半年时间内，我要用Python和Python周边的库搭建出一个网站，这个网站服务端运用爬虫技术爬取一些数据，可以提供知乎粉丝性别比例分析功能。</p><p>学生继续看书，一个个的知识点去记忆，拿着他的小本本去总结知识点，而开发者<b>上官网简单的看了下Reference Doc的简单交互式语法教程</b>后，便马上开始了<b>变做边学</b>的过程，有了一个<b>实际的项目目标</b>，朝着这个目标走，不断地发现自己不会这，不会那，然后有目的性的去补足知识，他了解到了beatuiful soup作为爬虫主库，flask作为后端web服务主库，然后会去看一些简单的教程，在这个过程中，基础语法得到了熟练，也训练了工程能力。</p><p><b>学生的成就感来源于学会了什么，开发者的成就感来源于做出来什么</b></p><p>开发者很功利，他们深知他们学会的所有东西都是为了开发出伟大的产品而服务的，所以他们绝对不会出现“在学一个东西，但是也不知道学这个用来干嘛”的窘境。</p><p></p><h3 id="区别三：厌恶不确定性-VS-接受不确定性"><a href="#区别三：厌恶不确定性-VS-接受不确定性" class="headerlink" title="区别三：厌恶不确定性 VS 接受不确定性"></a>区别三：厌恶不确定性 VS 接受不确定性</h3><p>学生们总是对“确定性”有一种几乎疯狂的追求，他们总问，“C语言学到什么程度就一定能被大厂录取？”，“掌握XX要几个月？”，“上课认真听讲，认真做笔记，考试是否一定能上80分？”</p><p>这种对确定性的追求，直接导致学生有一种下意识的举动：</p><p><b>干什么都等准备好了再去做，但是却“永远在准备”。</b></p><p>因为他们害怕那种不太会还要硬上带来的各种不确定性，他们渴求一种内功的修炼，寄希望于”把基础夯实了，就能顺畅的开发，所以还是先夯实基础吧！”</p><p>开发者选择接受这种不确定性，他们愿意”边学变做“，因为他们知道，最初学习敲键盘的时候，他们就是这么做的，边看某个按键在哪，边打字，做和学交叉进行，他们始终<b>抱有疑问</b>，他们又始终试图通过学习的延伸拓展去<b>解决疑问</b>，他们仿佛就像是拿着烛火在迷宫中行走的侠客，在游戏的一开始，对迷宫的结构一无所知，通过不断地摸索和碰壁，逐渐建立起对整个地图的认知.</p><p></p><h3 id="区别四-线性学习-VS-递归学习"><a href="#区别四-线性学习-VS-递归学习" class="headerlink" title="区别四: 线性学习 VS 递归学习"></a>区别四: 线性学习 VS 递归学习</h3><p>学生喜欢<b>线性的学习</b>，因为线性的学习（拿本教材从头到尾慢慢看）正是符合了他们对<b>确定性</b>的追求，可惜这违背了学习的本来面目</p><p>开发者知道，人脑最不擅长的就是<b>线性枚举</b>，即便我们认识几千个汉字，但是我们无法去<b>线性地去将所有认识的汉字枚举出来</b>，我们的大脑，本就不是用来进行线性思考的，而复杂度上了一定程度的知识，线性的掌握，基本不可能。</p><p>有难度的知识，往往是这样的：为了搞懂A，而去学B，为了学会B，而去学C，这叫<b>递归学习</b>，递归虽深，但有回溯，它最终会回溯到我们的起点。</p><p>所以开发者的学习更偏向于<b>递归式的学习</b>，而且可能会以一个知识点为起点，去完成树状知识外围的<b>遍历。</b>（有点像搜索引擎去爬虫）</p><p><b>知识是树状结构, 或者网状结构.</b></p><p>当我们试图遍历一个树的时候, 最简单直接的方式就是<b>递归</b>, 如果你非要去&#34;线性&#34;的学, 那就你是把编程学习当成了链表, 还是“单向”的，这种算法怎么可能用来遍历树呢？</p><h3 id="区别五：拿会XX定义自己-VS-拿XX项目作者定义自己"><a href="#区别五：拿会XX定义自己-VS-拿XX项目作者定义自己" class="headerlink" title="区别五：拿会XX定义自己 VS 拿XX项目作者定义自己"></a>区别五：拿会XX定义自己 VS 拿XX项目作者定义自己</h3><p>linus 从来不说自己精通 c 语言, 与其说他不需要, 不如说他不关心, 因为他是 linux 和 git 的作者.</p><p>linus 这个程序员之神就是一个典型的<b>开发者</b>思维的人.</p><p>我希望所有计算机专业的同学们, 等你们毕业了之后, 你的github应该是绿油油的, 而不是贫瘠的一片白.</p><p>我希望你们用你们的简历里写的是&#34;<b>用c语言实现了一个XX引擎, github链接...</b></p><p>而不是&#34;<b>精通c</b>&#34;.</p><p>我希望学生们明白, 任何一个像样子的项目, 制作周期至少是按月计, 你的大学有四年时间, 哪怕一个项目做一年, 你也能拿出两三个好项目, 不一定有多少star, 但是要完整, 文档, 测试, 一应俱全.</p><p>我希望学生们知道, 做项目和写课后习题不一样, 课后习题一个小时, 而项目是长期不断努力, 不断学习突破的过程, 需要你每天都搞, 善始善终, 最终拿出成果来.</p><p>我希望学生们明白, 这个世界衡量一个人的成就, 从来都是&#34;他做了什么&#34;, 而不是&#34;他学会了什么&#34;, 不要总用修炼内功去感动自己, 必要时, 也请你为开源世界贡献一点自己的力量.</p><p>我希望学生们明白, 考上985, 拿奖学金, 这都不叫成就, 因为<b>和别人没关系</b>, 只有真正影响到别人的东西, 让这个世界变得更好的东西, 才是值得去&#34;秀&#34;的.</p><p>最后送给学生们一句话:</p><p><b>愿你早日忘记学生的身份, 以开发者的姿态, 面对这个世界。</b></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java this关键字(调用属性，调用方法，调用当前对象)</title>
      <link href="/JAVA-this.html"/>
      <url>/JAVA-this.html</url>
      
        <content type="html"><![CDATA[<h3 id="this关键字主要有三个应用："><a href="#this关键字主要有三个应用：" class="headerlink" title="this关键字主要有三个应用："></a>this关键字主要有三个应用：</h3><p><img src="/images/1908131.png" alt="应用"></p><a id="more"></a><p><strong>调用属性(代码示例):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class thisDemo01 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">BlueMoon bm=new BlueMoon(&quot;渣渣辉&quot;, 100);</span><br><span class="line">System.out.println(bm.getInfo());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class BlueMoon &#123;</span><br><span class="line">private String name;</span><br><span class="line">private int level;</span><br><span class="line"> </span><br><span class="line">public BlueMoon(String name, int level) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.level = level;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public String getInfo() &#123;</span><br><span class="line">return &quot;大家好!我是&quot; + this.name + &quot;，我是贪玩蓝月的战士，等级：&quot; + this.level;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用方法-普通方法与构造方法"><a href="#调用方法-普通方法与构造方法" class="headerlink" title="调用方法(普通方法与构造方法)"></a>调用方法(普通方法与构造方法)</h3><ul><li><p>调用普通方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class thisDemo01 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">BlueMoon bm = new BlueMoon(&quot;渣渣辉&quot;, 100);</span><br><span class="line">System.out.println(bm.getInfo());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class BlueMoon &#123;</span><br><span class="line">private String name;</span><br><span class="line">private int level;</span><br><span class="line"> </span><br><span class="line">public BlueMoon(String name, int level) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.level = level;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public void print() &#123;</span><br><span class="line">System.out.println(&quot;************************&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public String getInfo() &#123;</span><br><span class="line">this.print();//调用普通方法</span><br><span class="line">return &quot;大家好!我是&quot; + this.name + &quot;，我是贪玩蓝月的战士，等级：&quot; + this.level;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用构造方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class thisDemo01 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">BlueMoon bm1 = new BlueMoon();</span><br><span class="line">BlueMoon bm2 = new BlueMoon(&quot;古天乐&quot;);</span><br><span class="line">BlueMoon bm3 = new BlueMoon(&quot;小志传奇&quot;, &quot;陈赫&quot;, &quot;法师&quot;);</span><br><span class="line"> </span><br><span class="line">System.out.println(bm1.getInfo());</span><br><span class="line">System.out.println(bm2.getInfo());</span><br><span class="line">System.out.println(bm3.getInfo());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class BlueMoon &#123;</span><br><span class="line">private String game;</span><br><span class="line">private String name;</span><br><span class="line">private String title;</span><br><span class="line">private int level;</span><br><span class="line"> </span><br><span class="line">public BlueMoon() &#123;</span><br><span class="line">this(&quot;贪玩蓝月&quot;, &quot;无名氏&quot;, &quot;未定&quot;, 0);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public BlueMoon(String name) &#123;</span><br><span class="line">this(&quot;贪玩蓝月&quot;, name, &quot;剑士&quot;, 90);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public BlueMoon(String game, String name) &#123;</span><br><span class="line">this(game, name, &quot;战士&quot;, 100);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public BlueMoon(String game, String name, String title) &#123;</span><br><span class="line">this();</span><br><span class="line">this.game = game;</span><br><span class="line">this.name = name;</span><br><span class="line">this.title = title;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public BlueMoon(String game, String name, String title, int level) &#123;</span><br><span class="line">this.game = game;</span><br><span class="line">this.name = name;</span><br><span class="line">this.title = title;</span><br><span class="line">this.level = level;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public String getInfo() &#123;</span><br><span class="line">return &quot;欢迎来到&quot; + this.game + &quot;！我是&quot; + this.name + &quot;,职业:&quot; + this.title + &quot;,等级:&quot; + this.level + &quot;级&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="当前对象调用"><a href="#当前对象调用" class="headerlink" title="当前对象调用:"></a>当前对象调用:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class BlueMoon &#123;</span><br><span class="line">public void print() &#123;</span><br><span class="line">//哪个对象调用了print()方法,this就自动与此对象指向同一块内存地址</span><br><span class="line">System.out.println(&quot;this=&quot; + this);//this 就是当前调用对象</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class thisDemo02 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">BlueMoon bm = new BlueMoon();</span><br><span class="line">BlueMoon bm2 = new BlueMoon();</span><br><span class="line">System.out.println(&quot;bm=&quot; + bm);</span><br><span class="line">bm.print();</span><br><span class="line">System.out.println(&quot;---------------------&quot;);</span><br><span class="line">System.out.println(&quot;bm2=&quot; + bm2);</span><br><span class="line">bm.print();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="images/1908133.png" alt></p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://blog.csdn.net/yanwenwennihao/article/details/79375611" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/yanwenwennihao/article/details/79375611</a><br><a href="https://blog.csdn.net/ikv1989/article/details/79182432" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/ikv1989/article/details/79182432</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式数据库与区块链的区别</title>
      <link href="/Distributed-Database-and-Block-Chain.html"/>
      <url>/Distributed-Database-and-Block-Chain.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>区块链技术也被称为分布式账本技术，我认为他和传统分布式数据库的主要区别是“”“信任”，区块链是去中心化的，任何节点都不是leader，都不被充分信任（trustless），区块链内的任何节点都可以修改数据，修改完数据会向整个链内进行广播，其它节点接受到广播并不是立马同步修改记录数据，会对修改的数据保持怀疑，会根据共识机制，密码算法去验证这个数据的修改是否是合法的，如果不合法就丢弃掉，如果合法就记录下来，而一般传统的分布式数据库节点之间是相互信任的，数据复制（数据的修改同步）没有类似区块链的一套验证，讲究实时同步，所以类似银行，支付宝转账基本都是瞬间到账，而如比特币的买卖到账时间都不是实时的，区块链这套机制本质上是牺牲了一定的效率而换取了安全性。</p><a id="more"></a><p>扯些题外话，目前来看区块链技术的发展还处于早期，目前主要的应用场景就是各种发币，币圈也是越来越热，现在各国政府对区块链都是拥抱的态度，但是对比特币等数字火币应该还是没有想清楚如何应对和监管，各国对数字火币的态度也不尽相同。</p><p>另外一点，关于区块链去中心化这个事情，目前已经被很多人当成政治正确，一直被强调，我个人并不是很赞同。</p><p>去中心化看似是一个公平，普世的东西，但是在实际操作层面会有很多问题，比如在金融行业，金融体系对一个国家来说是命脉所在，去中心化如何监管，仅仅靠区块链的共识机制，制度设计是不是就不会出现问题？</p><p>这些都是需要回答的问题，尤其在当前的中国，中国改革开放40年来取得的经济奇迹和国家的体制有密切的关系，我们是民主集中式领导，强调中心，核心，从哲学思想上说，完全的去中心化在中国更难获得成功。总之个人认为去中心化和中心化需要有个最佳的妥协才能在现实世界发挥价值，任何技术和理念必须产生实际价值才有意义。</p><hr><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><ul><li><p>分布式数据库<br>  应对互联网条件下大规模数据的增删改查需求，解决传统数据库面临的通信开销大、性能差、容量可扩展性差和可靠性低的问题</p><p>  通信开销大：假设只有一个数据库，并且放在北京，那么纽约的用户就需要等待网络从纽约到北京的往返通信延迟</p><p>  性能差：查不了——用户太多，大家都要查询数据库，自然性能就跟不上了</p><p>  容量可扩展性差：存不下——数据太多，一台机子放不下，升级设备又太贵</p><p>  可靠性低：丢不起——一个数据库挂掉，那么系统就宕了</p></li><li><p>区块链<br>在假设大部分成员可信的情况下，构建去中心化的可避免双花的数字货币</p></li></ul><p>比特币是区块链的原型，最开始就是想构建一个去中心化的数字货币</p><blockquote><p>在20世纪80年代后期，当密码学开始越来越广泛地使用并被理解时，许多研究人员开始尝试使用密码学来建立数字通货。这些早期的数字通货项目发行的数字货币，通常倚靠一种国家通货或像黄金一样的贵金属。<br>虽然这些早期的数字通货成型了，他们却是中心化的，因此，他们很容易遭受到政府和黑客的攻击。早期的数字通货使用了一个中央结算所来处理所有的定期交易，就像一个传统的银行系统。<br>为了坚定的抵制对手的介入，无论这些对手是合法的政府或是犯罪分子，去中心化的数字货币需要的是避免单节点攻击。比特币正是这样的系统，设计完全去中心化，不被任何中央政权或中央点控制，这样的货币系统是不会遭受攻击，也不会变得腐败。<br>（上述文字来自于《精通比特币》第1章 介绍 · 精通比特币-巴比特图书）</p></blockquote><h3 id="数据体系架构"><a href="#数据体系架构" class="headerlink" title="数据体系架构"></a>数据体系架构</h3><p>数据体系架构有两个评判点，其一是数据在多节点间如何分配，其二是数据如何分片存储</p><ul><li><p>数据分配<br>分割分配 每个节点只保存部分数据<br>  分布式数据库：<br>  全复制分配 每个节点都保存所有数据<br>  混合结构 有分割，有冗余，一般都用这种</p><p>  区块链：全复制分配</p></li><li><p>数据分片<br>水平分片 对表按行拆分，每个分片都有完整字段<br>  分布式数据库：<br>  垂直分片 对表按列拆分，每个分片都有某字段完整数据<br>  混合结构 有水平，有垂直 </p><p>  区块链：无分片，所有节点都是完整数据</p></li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>全局数据字典 记录哪些数据存在哪个节点</p><ul><li><p>分布式数据库：<br>全局数据库管理系统 控制总入口，管理各局部数据库<br>局部数据库管理系统 管理单个节点的数据库<br>共识机制 协调各节点更新区块链</p></li><li><p>区块链： 局部数据库管理系统 管理单个节点的数据库</p></li></ul><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><ul><li>分布式数据库：查询由全局数据库管理系统下发到各节点，结合各节点数据并计算</li><li>区块链：任何单点(全节点)均可独立完成查询</li></ul><h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><p>在数据库中，对数据的一系列操作在逻辑上可以看成一个整体的操作，这个整体的操作就叫事务。更新操作即可以理解为由事务构成。</p><p>事务需要满足ACID特性，即Atomicity（原子性）Consistency（一致性）Isolation（隔离性）Durability（持久性）<br>为避免理解混乱，这里简单介绍一下其定义</p><ul><li><p>Atomicity（原子性）<br>原子性要求每个事务中的所有操作要么全部完成，要么就像全部没有发生一样</p></li><li><p>Consistency（一致性）<br>单点数据库的一致性：一致性确保了任何事务都会使数据库从一种合法的状态变为另一种合法的状态。<br>分布式数据库的一致性：在分布式系统中的所有数据备份，在同一时刻是否同样的值</p></li><li><p>Isolation（隔离性）<br>隔离性保证了并发执行多个事务对系统的状态的影响和串行化执行多个事务对系统的状态的影响是一样的。</p></li><li><p>Durability（持久性）<br>持久性保证了一个事务一旦被提交以后，其对系统的影响是永久的。</p></li></ul><p><strong>下面分别针对ACID特性对分布式数据库和区块链进行对比</strong></p><ul><li><p>Atomicity（原子性）<br>分布式数据库：由全局数据库管理系统控制，保证所有节点均完成或均失败</p><p>  区块链：由共识机制、分叉理论和最长链原则共同控制。</p><p>  共识机制尽可能保证所有节点数据的原子性，但也会因为网络延迟和节点作恶导致部分节点更新失败。  </p><p>  如果出现有的节点更新数据成功，有的节点更新数据失败的情况，则发生分叉，各节点根据最长链原则更新自己的数据</p></li><li><p>Consistency（一致性）</p><p>  分布式数据库：由业务层或全局数据库管理系统控制</p><p>  区块链：共识机制控制各节点在一定时间窗口内“同步”更新，更新不成功即分叉</p></li><li><p>Isolation（隔离性）</p><p>  分布式数据库：全局管理系统中维护事务序列号，根据序列号判定执行顺序</p><p>  区块链：不存在隔离性问题。在共识机制控制下，单个时间点只有一个主体完成对区块链的更新操作，因此不存在并发事务操作。</p></li><li><p>Durability（持久性）</p><p>  分布式数据库与区块链的单点都是传统的数据库，因此能保证持久性</p></li></ul><h3 id="篡改"><a href="#篡改" class="headerlink" title="篡改"></a>篡改</h3><ul><li><p>分布式数据库：<br>单个节点能独立管理自己存储的数据；<br>已经提交的数据可以被修改或抹除，但修改或抹除会留下可删除的日志</p></li><li><p>区块链：<br>单个节点无法独立管理数据，如果任意更新的话即成为“恶意节点”，此类节点可以通过与其他节点的数据比对发现<br>不可篡改，已经提交的数据会被永久保留，无法被修改或抹除</p></li></ul><h3 id="中心化控制程度"><a href="#中心化控制程度" class="headerlink" title="中心化控制程度"></a>中心化控制程度</h3><ul><li>分布式数据库：由全局数据库管理系统统一控制，DBA(数据库管理员)有“生杀大权”；</li><li>区块链：去中心化，不存在DBA的角色</li></ul><h3 id="节点间的关系"><a href="#节点间的关系" class="headerlink" title="节点间的关系"></a>节点间的关系</h3><ul><li>分布式数据库各节点之间的关系是：信任，协作。</li><li>区块链各节点之间的关系是：怀疑，制约。</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src="/images/duibi.jpg" alt></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>分布式数据库是在互联网背景下应对大数据量和分布式请求的需求下产生的，其在中心化控制下假设每个节点都诚实，从而由多节点共同维护一个具有逻辑整体性的分布式数据库。其主要解决的是节点宕机或节点间通信不可靠的问题</p><p>区块链由多个节点共同维护一个分布式账本，没有中心化控制机构。区块链假设任何一个单点均不可靠但系统内诚实节点占大多数，由此搭建起了一个无需信任的信任体系。其主要解决的是节点本身不可靠的问题。</p><p>区块链应该属于分布式数据库的一种，它以牺牲一致性为代价把CAP定理中的Availability（可用性）和Partition tolerance（分区容错性）落实到了极致。当然，虽然区块链读取速度很快，但是其写入速度一直有严重瓶颈，如何在多方需求间找到均衡点，应该就是区块链创业者的使命了</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://sq.163yun.com/ask/question/126512025407713280" rel="external nofollow noopener noreferrer" target="_blank">https://sq.163yun.com/ask/question/126512025407713280</a><br><a href="https://zhuanlan.zhihu.com/p/33995237" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/33995237</a></p><h3 id="爱立示区块链业务"><a href="#爱立示区块链业务" class="headerlink" title="爱立示区块链业务"></a>爱立示区块链业务</h3><p><a href="https://www.sohu.com/a/119207104_115475" rel="external nofollow noopener noreferrer" target="_blank">给数据贴上“电子标签”, 爱立示用无钥签名防范信息被篡改 </a><br><a href="http://www.1000thinktank.com/ztbd/26519.jhtml" rel="external nofollow noopener noreferrer" target="_blank">基于数据而非信任，无钥签名为数据安全保驾护航</a></p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HEXO 搭建过程总结及注意事项 1</title>
      <link href="/hexo-establish1.html"/>
      <url>/hexo-establish1.html</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo博客框架发布文章流程"><a href="#Hexo博客框架发布文章流程" class="headerlink" title="Hexo博客框架发布文章流程"></a>Hexo博客框架发布文章流程</h2><p>Hexo clean：清空资源文件</p><p>hexo g：重新生成资源文件</p><p>hexo d：发布文章到github.io</p><a id="more"></a><h2 id="创建Tag页面"><a href="#创建Tag页面" class="headerlink" title="创建Tag页面"></a>创建Tag页面</h2><p><code>$ hexo new page &quot;tags&quot;</code><br>编辑刚新建的页面，将页面的类型设置为tags，主题将自动为这个页面显示标签云。页面内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: Tagcloud</span><br><span class="line">date: 2017-06-22 12:39:04</span><br><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure><p>注意：如果有启用多说 或者Disqus评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: Tagcloud</span><br><span class="line">date: 2017-06-22 12:39:04</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><h2 id="添加分类页面"><a href="#添加分类页面" class="headerlink" title="添加分类页面"></a>添加分类页面</h2><p>使用： <code>hexo new page categories</code> 新建一个 分类 页面<br>主题的 _config.yml 文件中的 menu 中进行匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /      //主页</span><br><span class="line">  categories: /categories //分类        （添加此行即可）</span><br><span class="line">  archives: /archives   //归档</span><br><span class="line">  tags: /tags   //标签                  </span><br><span class="line">  about: /about   //关于</span><br></pre></td></tr></table></figure><p>底下代码是一篇包含 分类 文章的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: 分类测试</span><br><span class="line">categories:</span><br><span class="line">- hexo                       （这个就是文章的分类了）</span><br></pre></td></tr></table></figure><h2 id="添加-时间线页面"><a href="#添加-时间线页面" class="headerlink" title="添加 时间线页面"></a>添加 时间线页面</h2><p>使用： <code>hexo new page timeline</code>新建一个 归档 页面。</p><p>主题的 _config.yml 文件中的 menu 中进行匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /      //主页</span><br><span class="line">  categories: /categories //分类        </span><br><span class="line">  archives: /archives   //归档             （添加此行即可）</span><br><span class="line">  tags: /tags   //标签    </span><br><span class="line">-page: history   (时间线)</span><br><span class="line">     directory: timeline/</span><br><span class="line">      icon: fa-history              </span><br><span class="line">  about: /about   //关于</span><br></pre></td></tr></table></figure><p>修改timeline对应的列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">timeline:</span><br><span class="line">  - num: 1</span><br><span class="line">    word: 2018/08/16-Start </span><br><span class="line">  - num: 2</span><br><span class="line">    word: writing</span><br><span class="line">  - num: 3</span><br><span class="line">    word: More</span><br></pre></td></tr></table></figure><h2 id="添加-自定义页面"><a href="#添加-自定义页面" class="headerlink" title="添加 自定义页面"></a>添加 自定义页面</h2><p>使用： <code>hexo new page &quot;guestbook&quot;</code> 新建一个 自定义 页面。<br>主题的 _config.yml 文件中的 menu 中进行匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /      //主页</span><br><span class="line">  categories: /categories //分类        </span><br><span class="line">  archives: /archives   //归档   </span><br><span class="line">  tags: /tags   //标签                  </span><br><span class="line">  about: /about   //关于</span><br><span class="line">  guestbook: /guestbook    //自定义             （添加此行即可）</span><br></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/qq_42249896/article/details/84378291" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/qq_42249896/article/details/84378291</a></p><p><a href="https://www.jianshu.com/p/3d2e7b3ec182" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/3d2e7b3ec182</a></p><p><a href="https://www.jianshu.com/p/ebbbc8edcc24" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/ebbbc8edcc24</a></p>]]></content>
      
      
      <categories>
          
          <category> HEXO </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>初学者应该如何开启自己的编程生涯？</title>
      <link href="/how-to-begin.html"/>
      <url>/how-to-begin.html</url>
      
        <content type="html"><![CDATA[<h2 id="探索编程的世界把我们带到了3个主要平台面前："><a href="#探索编程的世界把我们带到了3个主要平台面前：" class="headerlink" title="探索编程的世界把我们带到了3个主要平台面前："></a>探索编程的世界把我们带到了3个主要平台面前：</h2><ol><li><strong>Web</strong>（Google Search、Facebook、Amazon、Twitter等）</li><li><strong>桌面</strong>（Dropbox、Photoshop、Visual Studio、Skype等）</li><li><strong>移动</strong>（SoloLearn、Instagram、Uber等）<br>上述大多数服务在这三个平台都有。比方说Skype就是一个桌面、移动和web（虽然做得很糟糕）应用。Twitter是一个web和移动应用等等。<a id="more"></a><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3></li></ol><p>在这个上下文背景下web本身就是一个很大的概念，为了讲清楚情况，我们会把他分成所谓的前端和后端，后者是我个人很喜欢的一块。前端是你看到的东西，后端是跑应用的服务器，负责处理用户请求、数据库请求等等。</p><p><strong>前端</strong>。如果你希望掌握外观，比方说开发好看到让用户爱上的网站，你就应该了解HTML（样子），CSS（外观与感觉），JavaScript（感觉）。不过这还不够，利用纯粹的JavaScript在今天已经不够了，你必须选择合适的框架，比如目前流行的Angular、React和Vue。要选择哪一种主要取决于你最喜欢哪一家公司，是Google还是Facebook？如果你喜欢Google的话，那就用Angular，如果喜欢Facebook的话就用React。如果这两个你都不喜欢（很怪异），那就用Vue吧。简单！除了这些，你还应该掌握一些基本概念，比如HTTP协议的内部工作机制，要熟悉web服务器（至少不应该被Apache或者Nginx这样的名字吓着）。身为一名前端开发者意味着你从后端拿到要渲染（为了用户而装点）的数据，所以要对什么是API有最小限度的理解，对JSON（以及为什么它比XML好）的认知是必须的。</p><p><strong>后端</strong>。看不见的真相，未透露的故事。在过去，知道PHP足以自称为后端开发者，然后微软引入了ASP.NET。这两个就开始打架，直到Node.js冒出来把东西整理得井然有序。一些事件驱动开发的概念在Node.js上得到了最好的应用，所以如果你选择这个的话，你就是帮了你的项目大忙了。</p><p>后端令人困惑的一部分是语言的多样性，在后端你可以采用任何想要的语言，关键是，“后端”其实是“查询数据库、处理书、对客户端进行响应并且尽可能高效执行”的简称。，而选择“合适”的语言/技术/数据库并非选项。尽管一些开发者钟情MySQL或者PostgreSQL这类的关系数据库，但新进入者却选择黑暗面，NoSQL（比如Cassandra 或者MongoDB）。这个选择完全是个人的，但是我有一个简单的方程式。你有没有给你的数据制订严格的计划并且在不远的将来它都不会有太大的变化？如果是的话选择关系式数据库。你是不是每分钟的访问量超过了100万次？那就选NoSQL（很痛苦）。你的产品是不是频繁变更？那就选NoSQL。现在，假设你选好数据库，但是你又打算具体选择什么样的技术呢？你喜欢微软吗？有Windows Server吗？那就选MsSQL。你喜欢Oracle？那就选Oracle。你对Oracle没意见，但是很讨厌微软？选MySQL。你只是不想伤害任何人？那就选PostgreSQL吧。</p><p>NoSQL这玩意儿其实挺棘手的。这东西要取决于你的服务和数据架构。你得到的只是文档以及其中的一些弱连接？选MongoDB。你需要存储一大堆的键值对？选Redis。你正致力于类似图的结构（Facebook的朋友图谱，Google的知识图谱等）？选择Neo4j。其实你也不确定自己究竟想要什么，但是觉得这些全都需要？选ArangoDB吧。</p><p>数据库保存了所有的必要数据，但是你得客户端要想读/写该数据库却要你定义一个API。这里最有用的选项是Node.js，尽管你也可以用PHP或者ASP.NET、Ruby、Python，但我的个人推荐还是Node.js。好吧，Facebook后端用的是PHP，算是吧。他们用C++重写了PHP的很大一部分。一些人用Python而有的则喜欢用Ruby。诚然，你几乎可以用任何一种语言写后端，比方说Google用的是C++、Java和Python（以及Go）。对于底层的数据处理，C++是最合适的，对于像更新用户朋友推荐这样的后台任务，Java是一个好的选项。对于数据分析或者自然语言处理或者目前红得发紫额AI相关任务，你极有可能用的是Python。</p><p>再次地，后端除了各种语言、框架、数据库以外，你还需要掌握一些核心概念。</p><ul><li>缓存（Caching）。从CPU缓存（有不同的级别）开始，到浏览器缓存结束，缓存无所不在。对于像Google Search或者Facebook这样的高负载服务来说，缓存是极其必要的。</li><li>服务器（Server）。你可能会认为这个跟硬件有关（如果你懂得如何设置几台服务器让它们成为一个整体去存储和处理数据的话当然很棒），不过对于后端开发者来说服务器意味着web服务器。当今流行的web服务器是Nginx，知道如何安装和配置这个玩意儿的话会对你今后大有裨益。</li><li>套接字（Sockets）。套接字是网络编程的基石。你通过网络发送/接收所有东西都是通过套接字进行的。了解套接字编程的底层细节对于你的技能军火库来说是非常有用的补充（知道TCP套接字、UDP套接字之间的区别，以及什么是WebSockets更是锦上添花）。</li><li>数据库设计。不管你选择了什么样的DBMS，对数据进行操作都会是你的主要任务之一。看清数据全貌，对数据进行可视化，并且将数据单元连接起来，这是你在编程生涯中需要掌握的一项技能。</li><li>安全。就像前面提到的其他概念一样，这个概念也非常宽泛。你无法彻底掌握其中的任何一种，所以至少你应该熟悉一些最佳实践，比如存储面哈希值而不是明文。通过API令牌检查请求，要对每一项请求验证用户许可等等。</li></ul><h3 id="桌面"><a href="#桌面" class="headerlink" title="桌面"></a>桌面</h3><p>我们会讨论桌面应用中令其成为桌面应用的那部分内容。在桌面平台上需要特殊技能组合的应用数不胜数，比方说，Photoshop处理的是图像，如果你想写类似Photoshop这样的东西的话，了解图像处理算法和技术就是必须。如果你想写类似Dropbox这样的东西，了解套接字编程就是必须。如果你想编写编译器或者类似Visual Studio这样的IDE，则知道如何设计编译器就是必须。具体细节这里就不谈了，我们就先探讨一下如果要做桌面平台的东西的话，你最有可能会用到的语言吧。</p><p>说到桌面应用的语言，开发者得在C++、Java或者C#之中做出艰难选择。不过这里有一个简单的公式帮你做出正确选择：如果你喜欢微软，用C#。如果你喜欢Oracle，用Java。如果你认为语言不应该从属于从何一家公司，用C++。如果这个的帮助作用不大，我们就讨论一下具体的子平台。如果你编写的软件只是给Windows用户用的，C#是最佳选择。理由很显然，这两个都是微软的产品，自然也会是最佳拍档。尽管C#的开发者坚称在发布了.Net Core之后，其实C#也可以用于Linux环境，但我个人建议是如果你也想覆盖Linux的话，那就用C++。其关键是，C++本身就是作为跨平台编程语言开发出来的，在所有操作系统中都表现得很好（是的，甚至在MacOS上）。在这个上下文中跨平台会假设你要把你的C++项目在各个操作系统中都要独立地进行编译，从而在具体的OS中交付“不同”的应用可执行文件。还有，说实话C++缺乏任何的GUI。实际上，这一点最大的借口可以说“C++是给铁杆开发者准备的，而铁杆开发者除了Terminal（命令行接口）以外什么都不用。”然而，一群很友好的开发者聚到一起开发出了Qt，这是完美适配C++的跨平台GUI库。</p><p>最后，如果你对C++的复杂性以及你得连接像Qt这样的独立库用户才能拥有完整的GUI体验感到愤怒，并且你讨厌要为不同的OS给你的产品编译和交付不同的可执行文件的话，那就用Java。Java有一个虚机，所以交付可执行文件很容易。你的应用在任何安装了JVM（Java虚拟机器）的OS都能工作得一样好。</p><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p>说到Java，第一个想到的东西就是Android。在Kotlin被引进之前很久时，Java是实现Android app事实上的标准语言。而在今天，Kotlin俘获了开发者的心，使得Android平台的应用开发体验变得更好。所以，如果你想要制作Android app的话，你应该在Java和Kotlin之间进行选择。为了做出正确的选择，我们应该看看幕后的东西。关键是，Google对Oracle不太感冒。Java是Oracle的，而Java统治着Google的Android，所以为了让自己有点灵活性，Google在明面上必须引入一个选项（或者在暗面上，这取决于你），而引入Kotlin的目的就是“哇哦，如果有这么个好东西的话为什么要用Java呢。”如果你刚开始你的Android开发者生涯的话，我个人建议你从Kotlin开始，尽管要想在市场上成为一名胜任的开发者，你必须支持此前已经用Java实现的app，所以，知道Java的话对你的简历会是个加分项。</p><p>最后是iOS。iLand完全是另一个故事。很长一段时间以来，Objective-C是iOS的统治性语言，而且说实话，掌握Objective-C需要非常认真，要有一些好耐性。这也是look开发者数量相对较少的主要原因之一，所以苹果最终做出了正确的选择，引入了Swift。Swift掌握起来要比Objective-C容易多了，这使得iOS的开发者数量出现了增加。所以，要想成为一名iOS开发者，你需要跟进Swift，但要想成为一名真正自信的开发者，建议你掌握Objective-C，从而为app（无数app都是用Objective-C写的）提供支持。</p><p>这里我还必须提一提React Native，因为它允许你只用JavaScript编写同时支持Android和iOS平台的app，然而，作为这个市场一个新的变化节奏很快的玩家，我们知道有这么一个东西，而如果你只知道JavaScript的话自己就能写简单的app了。</p><h3 id="准备编码面试"><a href="#准备编码面试" class="headerlink" title="准备编码面试"></a>准备编码面试</h3><p>在编程世界有些概念是基础。大多数技术面试的目的都是为了发现你的问题解决技能以及看看你是否了解那些概念，所以除了掌握一门编程语言之外，你应该熟悉一些在程序员军火库中必须的一些概念。</p><p>要想为编码面试做好成功准备，你应该对以下领域有自信：</p><ol><li>算法与数据结构</li><li>计算机组织&amp;操作系统</li><li>编码</li><li>系统设计</li></ol><p><strong>算法&amp;数据结构</strong></p><p>这是程序眼最迫切需要的技能集。以下是每一位程序员都应该熟悉的主题：</p><ul><li><p>算法复杂性：大O的概念以及如何计算算法复杂性；基于复杂性知道哪一种算法更好，比方说O(N) vs O(logN)。</p></li><li><p>基本数据结构&amp;适配器：数组、链接表、堆栈、队列。</p></li><li><p>排序&amp;搜索：知道各种排序算法可帮助你识别项目的最佳的实现。作为练习，不妨试着实现以下插入排序选择排序或者合并排序，然后识别线性搜索与折半搜索的不同。</p></li><li><p>数&amp;图：树和图无所不在，可以从Facebook的“朋友图谱”和Google Search的“知识图谱”开始。</p></li><li><p>哈希表：作为世界上最有效的数据结构之一，哈希表一直都是一个好选择。你应该能够实现一个哈希表并且熟悉解决冲突的技巧。</p></li></ul><p><strong>计算机组织&amp;操作系统</strong></p><p>强烈建议你要熟悉的主题包括：</p><ul><li>逐位运算</li><li>CPU是如何执行机器代码的</li><li>RAM与动态RAM之间的区别时什么</li><li>有哪些类型的OS内核</li><li>“互斥”与“信号量”之间的区别是什么</li><li>什么是死锁，什么是活锁</li></ul><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>你应该至少对一门语言有着非常好的了解。要知道你喜欢的语言所有的优缺点，最佳实践，这有助于你写出优雅高效可读性强的代码。</p><p>高度推荐你通过解决有挑战性的问题来进练习，比如：</p><ul><li>约瑟夫斯问题</li><li>汉诺塔</li><li>字符串压缩</li><li>平衡括号（Balanced Parenthesis）</li><li>孪生素数</li></ul><h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><p>知道面向对象编程对现代程序员来说是必须的。</p><p>系统设计意味着要考虑整个系统，能够设计其架构、对其按类进行详细分析，定义对象的交互。</p><p>要准备好回答下述问题：</p><p>——让你设计Google Search的话你会怎么设计？如果每秒钟有数百万的并发请求该怎么办？</p><p>——你会如何去实现Facebook的朋友查找？</p><p>——为什么你需要使用关系式数据库管理系统？</p><p>——为什么你要使用NoSQL DB？</p><p>高度建议你了解和使用正确的设计模式。比方说，你应该知道Composite（组成）与Decorator（装饰）这两种结构型模式的不同。</p><p>尽管初级开发者基本上需要的是有好的问题解决技能，而且你的第一份工作不会要求你上述所有的东西都懂，但是这个列表对于你的职业生涯规划还是会起到很好的帮助作用。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://baijiahao.baidu.com/s?id=1601249211609135023&amp;wfr=spider&amp;for=pc" rel="external nofollow noopener noreferrer" target="_blank">https://baijiahao.baidu.com/s?id=1601249211609135023&amp;wfr=spider&amp;for=pc</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world.html"/>
      <url>/hello-world.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" rel="external nofollow noopener noreferrer" target="_blank">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" rel="external nofollow noopener noreferrer" target="_blank">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" rel="external nofollow noopener noreferrer" target="_blank">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" rel="external nofollow noopener noreferrer" target="_blank">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" rel="external nofollow noopener noreferrer" target="_blank">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" rel="external nofollow noopener noreferrer" target="_blank">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
