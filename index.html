<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="en">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="google-site-verification" content="I0jUNsp40jMLLvChVvaEUlXNcTs1cSJSG4ktU1HF5-M">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">
  <meta name="google-site-verification" content="true">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta name="description" content="Keep Learning">
<meta property="og:type" content="website">
<meta property="og:title" content="Aaron&#39;s blog">
<meta property="og:url" content="https://zhishui0501.github.io/index.html">
<meta property="og:site_name" content="Aaron&#39;s blog">
<meta property="og:description" content="Keep Learning">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Aaron&#39;s blog">
<meta name="twitter:description" content="Keep Learning">
  <link rel="canonical" href="https://zhishui0501.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Aaron's blog</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  <div class="container sidebar-position-left">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Aaron's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories<span class="badge">11</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives<span class="badge">29</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content page-home">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhishui0501.github.io/数据结构与算法2-数组.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="Keep Learning">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/数据结构与算法2-数组.html" class="post-title-link" itemprop="url">数据结构与算法2-数组</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-13 10:55:52 / Modified: 11:20:28" itemprop="dateCreated datePublished" datetime="2019-09-13T10:55:52+08:00">2019-09-13</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>数组是应用最广泛的数据存储结构。它被植入到大部分编程语言中。大部分数据结构都有最基本的四个操作：插入、删除、查找、修改。对于这四种操作每一种数据结构都有相应的算法。算法和数据结构因此就是非常紧密的相联系的。</p>
<h2 id="数组例子"><a href="#数组例子" class="headerlink" title="数组例子"></a>数组例子</h2><p>数组的每一个元素必须是连续，也就是中间没有洞。就是说第一个元素和第三个元素有值，但不允许第二个元素是空的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class Array &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        //创建一个数组</span><br><span class="line">        long[] arr;</span><br><span class="line">        arr = new long[100];</span><br><span class="line">        int nElems = 10;</span><br><span class="line">        int j;</span><br><span class="line">        long searchKey;</span><br><span class="line">        arr[0] = 99;</span><br><span class="line">        arr[1] = 11;</span><br><span class="line">        arr[2] = 22;</span><br><span class="line">        arr[3] = 33;</span><br><span class="line">        arr[4] = 55;</span><br><span class="line">        arr[5] = 66;</span><br><span class="line">        arr[6] = 44;</span><br><span class="line">        arr[7] = 77;</span><br><span class="line">        arr[8] = 23;</span><br><span class="line">        arr[9] = 88;</span><br><span class="line">        nElems = 10;</span><br><span class="line">        //输出前10位数组元素</span><br><span class="line">        for(j = 0; j &lt; nElems; j++)&#123;</span><br><span class="line">            System.out.print(arr[j] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        //查找数组的一个元素值为55的元素</span><br><span class="line">        searchKey = 55;</span><br><span class="line">        for(j = 0; j &lt; arr.length; j++)&#123;</span><br><span class="line">            if(arr[j] == searchKey)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(j == nElems)&#123;</span><br><span class="line">            System.out.println(&quot;Can&apos;t find the element&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;find the element &quot; + searchKey + &quot; at index &quot; + (j + 1) );</span><br><span class="line">        &#125;</span><br><span class="line">        //删除指定元素</span><br><span class="line">        searchKey = 66;</span><br><span class="line">        for(j = 0; j &lt; arr.length; j++)&#123;</span><br><span class="line">            if(arr[j] == searchKey)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int k = j; k &lt; nElems; k++)&#123;</span><br><span class="line">            arr[k] = arr[k+1];</span><br><span class="line">        &#125;</span><br><span class="line">        nElems--;</span><br><span class="line">        //输出删除后的数组</span><br><span class="line">        for(j = 0; j &lt; nElems; j++)&#123;</span><br><span class="line">            System.out.print(arr[j] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">99 11 22 33 55 66 44 77 23 88 </span><br><span class="line">find the element 55 at index 5</span><br><span class="line">99 11 22 33 55 44 77 23 88</span><br></pre></td></tr></table></figure>

<h2 id="将程序划分成类"><a href="#将程序划分成类" class="headerlink" title="将程序划分成类"></a>将程序划分成类</h2><p>上面的程序包含了一个很大的方法，通过将程序划分成类以后，并且将其中的方法模块化，这样程序看起来更加有条理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line">class ArrayMethod&#123;</span><br><span class="line">    private long[] arr;</span><br><span class="line">    private int nElems;</span><br><span class="line">    public ArrayMethod(int max)&#123;</span><br><span class="line">        arr = new long[max];</span><br><span class="line">        nElems = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    public void insert(long value)&#123;</span><br><span class="line">        arr[nElems] = value;</span><br><span class="line">        nElems++;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean find(long searchKey)&#123;</span><br><span class="line">        //查找数组的一个元素值为searchKey的元素</span><br><span class="line">        int j;</span><br><span class="line">        for(j = 0; j &lt; arr.length; j++)&#123;</span><br><span class="line">            if(arr[j] == searchKey)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(j == nElems)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;    </span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //删除指定元素</span><br><span class="line">    public boolean delete(long searchKey)&#123;</span><br><span class="line">        int j;</span><br><span class="line">        for(j = 0; j &lt; arr.length; j++)&#123;</span><br><span class="line">            if(arr[j] == searchKey)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int k = j; k &lt; nElems; k++)&#123;</span><br><span class="line">            arr[k] = arr[k+1];</span><br><span class="line">        &#125;</span><br><span class="line">        nElems--;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //输出数组</span><br><span class="line">    public void display()&#123;</span><br><span class="line">        //输出前10位数组元素</span><br><span class="line">        for(int j = 0; j &lt; nElems; j++)&#123;</span><br><span class="line">            System.out.print(arr[j] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class HighArray &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int maxSize = 100;</span><br><span class="line">        ArrayMethod arr = new ArrayMethod(maxSize);</span><br><span class="line">        arr.insert(99);</span><br><span class="line">        arr.insert(11);</span><br><span class="line">        arr.insert(22);</span><br><span class="line">        arr.insert(33);</span><br><span class="line">        arr.insert(55);</span><br><span class="line">        arr.insert(66);</span><br><span class="line">        arr.insert(44);</span><br><span class="line">        arr.insert(77);</span><br><span class="line">        arr.insert(23);</span><br><span class="line">        arr.insert(88);</span><br><span class="line">        //输出数组</span><br><span class="line">        arr.display();</span><br><span class="line">        //查找值为55的元素</span><br><span class="line">        long searchKey = 55;</span><br><span class="line">        if(arr.find(searchKey))&#123;</span><br><span class="line">            System.out.println(&quot;find the element &quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;Can&apos;t find the element&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //删除指定元素</span><br><span class="line">        searchKey = 22;</span><br><span class="line">        if(arr.delete(searchKey))&#123;</span><br><span class="line">            System.out.println(&quot;Delete the element successfully &quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;Can&apos;t find the element&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //输出删除元素后的数组</span><br><span class="line">        arr.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h2><p>假设一个数组，其中的数据项按关键字升序排列，即最小值在下标为0的单元上，每一个单元都比前一个单元的值大。这种数组被称为有序数组。</p>
<p>当向这种数组中插入数据项时，需要为插入操作找到正确的位置：刚好在稍小值的后面，稍大值的前面。然后将所有比待茶数据项的值向后移以便腾出空间。<br>将数据按顺序排列的好处之一就是可以通过二分法查找显著地提高查找速度。但缺点是降低了插入操作的速度。</p>
<h2 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h2><p>默认情况下是线性查找，线性查找和未经排序的数组的查找操作相似。</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>当使用二分查找时就体现有序数组的好处，这种查找比线性查找快很多，尤其是对大数组来说更为显著。<br>二分查找首先从要查找的范围确定一个中位数，然后比较要找的数和中位数的大小关系，确定更小的范围，依次递归，知道找到那个数。<br><img src="images/1909131.PNG" alt></p>
<h3 id="有序数组的二分搜索代码"><a href="#有序数组的二分搜索代码" class="headerlink" title="有序数组的二分搜索代码"></a>有序数组的二分搜索代码</h3><p>二分查找是将数组数据项范围不断对半分隔来查找特定的数据项。方法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line">class ArrayMethod&#123;</span><br><span class="line">    private long[] arr;</span><br><span class="line">    private int nElems;</span><br><span class="line">    public ArrayMethod(int max)&#123;</span><br><span class="line">        arr = new long[max];</span><br><span class="line">        nElems = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    public void insert(long value)&#123;</span><br><span class="line">        arr[nElems] = value;</span><br><span class="line">        nElems++;</span><br><span class="line">    &#125;</span><br><span class="line">    //二分查找法</span><br><span class="line">    public int halfFind (long searchKey)&#123;</span><br><span class="line">        int lowerBound = 0;</span><br><span class="line">        int upperBound = nElems - 1;</span><br><span class="line">        int curIn;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            curIn = (lowerBound + upperBound)/2;</span><br><span class="line">            if(arr[curIn] == searchKey)&#123;</span><br><span class="line">                return curIn;</span><br><span class="line">            &#125;else if(lowerBound &gt;= upperBound)&#123;</span><br><span class="line">                return nElems;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(arr[curIn] &gt; searchKey)&#123;</span><br><span class="line">                    upperBound = curIn - 1;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    lowerBound = curIn + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int size()&#123;</span><br><span class="line">        return nElems;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean find(long searchKey)&#123;</span><br><span class="line">        //查找数组的一个元素值为searchKey的元素</span><br><span class="line">        int j;</span><br><span class="line">        for(j = 0; j &lt; arr.length; j++)&#123;</span><br><span class="line">            if(arr[j] == searchKey)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(j == nElems)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;    </span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //删除指定元素</span><br><span class="line">    public boolean delete(long searchKey)&#123;</span><br><span class="line">        int j;</span><br><span class="line">        for(j = 0; j &lt; arr.length; j++)&#123;</span><br><span class="line">            if(arr[j] == searchKey)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int k = j; k &lt; nElems; k++)&#123;</span><br><span class="line">            arr[k] = arr[k+1];</span><br><span class="line">        &#125;</span><br><span class="line">        nElems--;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //输出数组</span><br><span class="line">    public void display()&#123;</span><br><span class="line">        //输出前10位数组元素</span><br><span class="line">        for(int j = 0; j &lt; nElems; j++)&#123;</span><br><span class="line">            System.out.print(arr[j] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class HighArray &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int maxSize = 100;</span><br><span class="line">        ArrayMethod arr = new ArrayMethod(maxSize);</span><br><span class="line">        arr.insert(99);</span><br><span class="line">        arr.insert(11);</span><br><span class="line">        arr.insert(22);</span><br><span class="line">        arr.insert(33);</span><br><span class="line">        arr.insert(55);</span><br><span class="line">        arr.insert(66);</span><br><span class="line">        arr.insert(44);</span><br><span class="line">        arr.insert(77);</span><br><span class="line">        arr.insert(23);</span><br><span class="line">        arr.insert(88);</span><br><span class="line">        //输出数组</span><br><span class="line">        arr.display();</span><br><span class="line">        //查找值为55的元素</span><br><span class="line">        long searchKey = 35;</span><br><span class="line">//        if(arr.find(searchKey))&#123;</span><br><span class="line">//            System.out.println(&quot;find the element &quot;);</span><br><span class="line">//        &#125;else&#123;</span><br><span class="line">//            System.out.println(&quot;Can&apos;t find the element&quot;);</span><br><span class="line">//        &#125;</span><br><span class="line">        //二分法查找</span><br><span class="line">        if(arr.halfFind(searchKey) != arr.size())&#123;</span><br><span class="line">            System.out.println(&quot;Find it&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;Can&apos;t find it&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">//        //删除指定元素</span><br><span class="line">//        searchKey = 22;</span><br><span class="line">//        if(arr.delete(searchKey))&#123;</span><br><span class="line">//            System.out.println(&quot;Delete the element successfully &quot;);</span><br><span class="line">//        &#125;else&#123;</span><br><span class="line">//            System.out.println(&quot;Can&apos;t find the element&quot;);</span><br><span class="line">//        &#125;</span><br><span class="line">        //输出删除元素后的数组</span><br><span class="line">        arr.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有序数组的优点"><a href="#有序数组的优点" class="headerlink" title="有序数组的优点"></a>有序数组的优点</h3><p>使用有序数组最主要的好处是查找的速度比无序数组快多了。不好的方面是在插入操作中由于所有靠后的数据都需要移动以腾开空间，所以速度较慢。有序数组和无序数组中的删除操作都很慢，这是因为数据项必须向前移动来填补已删除数据项的洞。有序数组在查找频繁的情况下十分有用，但若是插入和删除较为频繁时，则无法高效工作。</p>
<h2 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h2><p>计算机科学中评价算法效率的方法称为大O表示法。比较算法时候通常会说”算法A比算法B快2倍”，这种说法意义不大。因为数据项的变化会对排序造成一定很大影响。有可能数据项增加50%，算法A就比B快了3倍，或者可能只有一半的数据项，A和B的速度是相同的。</p>
<h3 id="无序数组的插入：常数"><a href="#无序数组的插入：常数" class="headerlink" title="无序数组的插入：常数"></a>无序数组的插入：常数</h3><p>无序数组的插入是我们到现在为止所见过的算法中唯一一个与数组项个数无关的算法。新数据项总被放在下一个有空的地方,a[nElems]，然后nElems增加。无论数组中的数据项个数N有多大，一次插入总是用相同的时间。我们可以说向一个无序数组中插入一个数据项的时间T是一个常数K<br>T=K<br>在现实情况中，插入所需的实际时间与以下这些因素有关：微处理器，编译程序生成程序代码的效率，等等。</p>
<h3 id="线性查找：与N成正比"><a href="#线性查找：与N成正比" class="headerlink" title="线性查找：与N成正比"></a>线性查找：与N成正比</h3><p>在数组数据项的线性查找中，我们已经发现寻找特定数据项所需的比较平均次数为数据项总数的一半。因此设N为数据项总数，搜索时间T与N的一半成正比：<br>T=K*N/2<br>同插入一样，若要得到方程中K的值，首先需要对某个N值的查找进行计时，然后用T来计算K。当得到K后，便可以对任意N的值来计算T。将2并入K可以得到更方便的公式，新K值等于原先的K除以2即<br>T=KN<br>这个方程说明平均线性查找时间与数组的大小成正比。即如果一个数组增大两倍，则所花费的查找时间也会相应地增长两倍。</p>
<h3 id="二分查找-与log-N-成正比"><a href="#二分查找-与log-N-成正比" class="headerlink" title="二分查找:与log(N)成正比"></a>二分查找:与log(N)成正比</h3><p>同样，我们可以为二分查找指定出一个与T和N有关的公式:T=Klog2(N)<br>实际上，由于所有的对数和其他对数成比例(比如从底数2转换到底数为10需乘以3.322)，也可以将这个为常数的底数也并入K。由此不必指定底数:<br>T=Klog(N)<br>不要常数<br>大O表示法同上面的公式比较类似，但它省去了常数K。当比较算法时，并不在乎具体的微处理器或编译器；真正需要比较的是对应不同的N值，T是如何变化的，而不是具体的数字，因此不需要常数。<br>大O表示法使用大写字母O，可以认为其含义是order of(大约是)。我们可以使用大O表示法来描述线性查找使用了O(N)级时间，二分查找使用了O(logN)级时间。向一个无序数组中的插入使用了O(1)，或常数级时间。</p>
<p>下表总结的是讨论过的算法的运行时间<br><img src="images/1909132.PNG" alt><br>大O表示法的实质并不是对运行时间给出实际值，而是表达了运行时间是如何受数据项个数所影响的。除了实际安装后真正去测量一次算法的运行时间之外，这可能是对算法进行比较的最有意义的方法了。</p>
<h2 id="为什么不用数组表示一切？"><a href="#为什么不用数组表示一切？" class="headerlink" title="为什么不用数组表示一切？"></a>为什么不用数组表示一切？</h2><p>仅使用数组似乎就可以完成所有工作，为什么不用它们来进行所有数据存储呢？我们已经见到了许多关于数组的缺点。在一个无序数组中可以很快进行插入(O(1))，但是查找却要花费较慢的O(N)时间。在一个有序数组中可以查找得很快，用O(logN)的时间，但插入却花费了O(N)时间。对于这两种数组而言，由于平均半数的数据项为了填补”空洞”必须移动，所以删除操作平均需要O(N)时间。<br>如果有一种数据结构进行任何如插入、删除和查找的操作都很快(理想的O(1)或是O(logN)时间)，那就好了。后面我们会介绍类似的数组，但这是以程序的复杂度为代价的。<br>另外数组被创建后，占用内存长度是确定的，无法进行修改，这样的话，如果创建的长度过大，但是实际需要的很少就会造成内存浪费，如果创建的长度过小，就会造成溢出，无法弹性使用。</p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhishui0501.github.io/数据结构与算法1-综述.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="Keep Learning">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/数据结构与算法1-综述.html" class="post-title-link" itemprop="url">数据结构与算法1--综述</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-12 16:14:07 / Modified: 16:42:06" itemprop="dateCreated datePublished" datetime="2019-09-12T16:14:07+08:00">2019-09-12</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="数据结构和算法起到的作用"><a href="#数据结构和算法起到的作用" class="headerlink" title="数据结构和算法起到的作用"></a>数据结构和算法起到的作用</h2><p>数据结构是对计算机内存中(有时在磁盘中)的数据的一种安排。数据结构是存放数据物理结构在逻辑上的形式体现，常见的数据结构有数组、链表、栈、二叉树、哈希表等等。算法对这些结构中的数据进行各种处理，例如，查找一条特殊的数据项或对数据进行排序。数据结构和处理技术(即算法)可以解决如下问题</p>
<h3 id="现实世界数据的存储"><a href="#现实世界数据的存储" class="headerlink" title="现实世界数据的存储"></a>现实世界数据的存储</h3><p>现实世界中有很多信息，有些信息是强相关的，比如一个人的身高、体重、年龄等等，这些信息不是随便放的，就像你不会把厨房里的锅放在卧室里面，铲子放到卫生间里面，我们需要一个统一地方存放这些信息，在物理上就是放在存储空间里面，比如硬盘或内存，在逻辑形式上就是上面提到的各种数据结构，比如数组、链表等等。</p>
<h3 id="现实世界的建模"><a href="#现实世界的建模" class="headerlink" title="现实世界的建模"></a>现实世界的建模</h3><p>一些数据具有很强的实用性，就是与相应的事件对应起来，比如队列可以模拟顾客在银行中排队等待。</p>
<h2 id="数据结构的概述"><a href="#数据结构的概述" class="headerlink" title="数据结构的概述"></a>数据结构的概述</h2><p>数据结构与算法就是讨论这些数据结构的实现以及在数据结构上进行一些操作。<br>下面列出了一些数据结构优点和缺点</p>
<ul>
<li>数组　　　　　　<br>插入快，如果知道下标，可以非常快地存取　　　　　　　　　　 查找慢，删除慢，大小固定</li>
<li>有序数组    　　<br>比无序的数组查找快    　　　　　　　　　　　　　　　　　　　 删除和插入慢，大小固定</li>
<li>栈　　　　　　<br>提供后进先出方式的存取　　　　　　　　　　　　　　　　　　 存取其他项很慢</li>
<li>队列    　　　　<br>提供先进先出方式的存取　　　　　　　　　　　　　　　　　　 存取其他项很慢</li>
<li>链表    　　　　<br>插入快，删除快    　　　　　　　　　　　　　　　　　　　　　 查找慢</li>
<li>二叉树    　　　　<br>查找、插入、删除都快(如果树保持平衡)    　　　　　　　　　删除算法复杂</li>
<li>红-黑树    　　　　<br>查找、插入、删除都快，树总是平衡的    　　　　　　　　　　　 算法复杂</li>
<li>2-3-4树    　　　<br>查找、插入、删除都快，树总是平衡的，树对磁盘存储有用　　　 算法复杂</li>
<li>哈希表    　　　　<br>如果关键字已知则存取极快，插入快    　　　　　　　　　　　　删除慢，如果不知道关键字则存取很慢，对存储空间使用不充分</li>
<li>堆    　　　　　　<br>插入、删除快，对最大数据项的存取很快    　　　　　　　　　　对其他数据项存取慢</li>
<li>图    　　　　　　<br>对现实世界建模    　　　　　　　　　　　　有些算法慢且复杂</li>
</ul>
<p>数据结构除了数组之外都可以被认为是抽象数据结构(ADT)，主要是数据的存储物理结构与逻辑结构并非拓扑结构上一致。</p>
<h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><p>许多将要讨论到的算法直接适用于某些特殊的数据结构，对大多数数据结构来说，都需要实现以下功能</p>
<ol>
<li>插入一条新的数据项</li>
<li>查找某一特定的数据项</li>
<li>删除某一特定的数据项</li>
<li>给数据结构里的数据排序</li>
<li>其他<h2 id="过程性语言的问题"><a href="#过程性语言的问题" class="headerlink" title="过程性语言的问题"></a>过程性语言的问题</h2>面向对象编程语言的产生是由于发现过程性语言在处理大小的复杂问题时有些力不从心。具体是哪些问题呢？<br>有两类问题：一是程序与现实世界缺乏对应关系，二是程序内部的结果出现了问题。</li>
</ol>
<ul>
<li>对现实世界建模的无能为力<br>使用过程语言对现实世界问题进行抽象即概念化十分困难：方法执行任务，而后数据存储信息，但是现实世界中的事物是对二者同时进行操作。</li>
<li>粗糙的组织结构<br>解决程序的内部组织结构是一个更微妙而且事关重大的问题。面向过程的程序被划分为一个个方法，这种基于方法组织形式的一个巨大问题是它仅仅考虑了方法，而没有重视数据。当不得不面对数据时，它没有太多的选择。简而言之，数据可以是一个特定的方法的局部量，也可以是所有方法都可以存取的全局量，就是无法规定一个变量只允许某些方法存取而不允许另一些方法存取。</li>
</ul>
<h2 id="Java数据结构的类库"><a href="#Java数据结构的类库" class="headerlink" title="Java数据结构的类库"></a>Java数据结构的类库</h2><p>Java.util包中含有诸如向量(一个可扩充的数组)、栈、库和哈希表等类型的数据结构。这些数据结构已经被实现并提供了相关操作方法。但是我们仍然需要学习别的数据结构，提供的数据结构是不够的。</p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhishui0501.github.io/有了IP为什么还要有MAC.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="Keep Learning">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/有了IP为什么还要有MAC.html" class="post-title-link" itemprop="url">有了IP为什么还要有MAC</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-11 21:19:22 / Modified: 21:43:01" itemprop="dateCreated datePublished" datetime="2019-09-11T21:19:22+08:00">2019-09-11</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机网络/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="为什么有了MAC地址，还需要IP地址？"><a href="#为什么有了MAC地址，还需要IP地址？" class="headerlink" title="为什么有了MAC地址，还需要IP地址？"></a>为什么有了MAC地址，还需要IP地址？</h2><p>Mac地址是物理层的地址，但它是以太网的物理地址。互联网是由很多异构的物理网络通过路由器联接起来的，不同的物理网络，寻址方式很可能是不同的，可能根本不使用MAC地址。如果只用MAC地址，不同的物理网络进行寻址时会非常困难，因为彼此的数据帧格式不一样相互不兼容。所以，我们需要一个公用的标准去遵循，这个标准就是IP地址。这里也体现了计算机网络中分层的好处，让你不再去考虑两个不同的实现方式的物理网之间如何通讯。它屏蔽了下层的东西，让所有的网络都建立在IP地址之上，整个互联网在第三层看起来就像是一个巨大的IP网，而不用去管底层物理网络是什么。</p>
<h2 id="只有IP地址，不要MAC地址？"><a href="#只有IP地址，不要MAC地址？" class="headerlink" title="只有IP地址，不要MAC地址？"></a>只有IP地址，不要MAC地址？</h2><p>1.IP地址是有限的，根本就不够用，不可能为全球每台计算机都分配一个IP地址。<br>2.MAC地址全球固定而且唯一的，有了MAC地址就能准确的找到你的计算。<br>3.如果IP层抢了第二层的饭碗，你就不得不考虑第二层的很多东西了，这就让IP层的实现变得十分困难。</p>
<p>IP地址就不用说了也就是一个逻辑地址，至于MAC地址的定义就是一个设备的物理地址。好了，为什么有了IP还要有MAC？在网上看了看了很久每一个能回答好点的，最好的也就是有了IP可以屏蔽掉各个链路的差异。拿实际来讲，若是没有MAC地址，就用IP地址来充当MAC。首先，有个问题要说清楚的是IP地址肯定是在不停的变化的，比如你从A走到了B，A和B有不同的网络，那么你在用手机上网的时候，IP地址在不停的变化，那么就说这个数据，若是下雨天什么情况的话，当你在A点的时候玩亡者农药，数据发出去了，由于天气原因，手机显示420ms导致数据传输不过，这时，你换到了B点，重新获得了IP地址，wo吼，恭喜您成功解锁由于接收不到数据被举报，而导致制裁！为什么？因为IP地址换了，所以之前的数据一脸懵逼不知道转送给谁，若是某某人链接到了之前的IP（你之前链接的IP），那就是传送给了那个某某人了。所以没有MAC只是有IP，不仅有接收不到数据的可能，同时还极大的消耗CPU的资源，这就不太好了。</p>
<p>那有了MAC为什么还要有IP地址？在很久很久以前，那是没有路由，交换机的时代，若是两台电脑要通信，可以一根线直接连接就ok了，比如电话。若是有多台怎么通信？？这时就出现了集线器，只需要在消息里面附加上对方的MAC地址就可以了，集线器就会广播消息，每个设备接收消息并对照自己的MAC，是不是一样的，若是一样的收下。这样的广播比较麻烦就出现了交换机，交换机会把MAC地址与某一个端口一一对应，比如主机A要与主机B通信，主机A发送附带主机B的MAC地址的消息发送到交换机，交换机根据对应表查找到相应的端口号，并把消息发送到B，这就比如，你坐公交一样，各个站点的路线信息就相当于集线器告诉你公交是怎么走的。那么也就是意味着交换机与各个站牌中的信息一样要记录所有与它连接设备的MAC地址，那么问题来了，比如A是中国某一地区的主机，B是台湾的某一地区的主机，假设A直接连接到中国这一个大子网，B直接连接到台湾这一个大子网，两个大子网的链接是用交换机相连接的，A要与B通信，由于交换机记录与它链接的设备的地址，中国这一个大子网的交换机只会记录台湾的一个交换机的MAC地址，所以A附带B的MAC地址的信息，无法通过中国这一个大子网的换交换机的，除非A和B在同一个子网中。所以就出现 了IP这个逻辑地址来解决以上不能通信的问题。</p>
<p>可能会想到的是，把MAC地址像IP地址一样来对待，用一个交换机来构成多个子MAC进而构成多个子网，那问题是MAC地址要被有规则的被分配的话，那由谁来管理，再说MAC是厂商制造的，那肯定由厂商自己决定MAC地址是多少，那么多的选择方式。当然MAC是唯一的了。</p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhishui0501.github.io/二层交换机与三层交换机区别.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="Keep Learning">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/二层交换机与三层交换机区别.html" class="post-title-link" itemprop="url">二层交换机与三层交换机区别</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-09 21:34:40 / Modified: 22:03:53" itemprop="dateCreated datePublished" datetime="2019-09-09T21:34:40+08:00">2019-09-09</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机网络/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>我们习惯说，在二层网络环境中相同VLAN（Virtual Local Area Network）之间可以通信，不同vlan之间不可以通信，如果想通信必须借助三层设备，所以说三层交换机必须要做的事情是路由转发，但是二、三层交换机具体有什么区别呢？</p>
<h2 id="二层交换机"><a href="#二层交换机" class="headerlink" title="二层交换机"></a>二层交换机</h2><p>二层交换机工作于OSI模型的第2层(数据链路层)，故而称为二层交换机。二层交换技术发展比较成熟，二层交换机属数据链路层设备，可以识别数据包中的MAC地址信息，根据MAC地址进行转发，并将这些MAC地址与对应的端口记录在自己内部的一个地址表中。具体的工作流程如下：</p>
<ol>
<li><p>当交换机从某个端口收到一个数据包，它先读取包头中的源MAC地址，这样它就知道源MAC地址的机器是连在哪个端口上的；</p>
</li>
<li><p>再去读取包头中的目的MAC地址，并在地址表中查找相应的端口；</p>
</li>
<li><p>如表中有与这目的MAC地址对应的端口，把数据包直接复制到这端口上；</p>
</li>
<li><p>如表中找不到相应的端口则把数据包广播到所有端口上，当目的机器对源机器回应时，交换机又可以学习一目的MAC地址与哪个端口对应，在下次传送数据时就不再需要对所有端口进行广播了。</p>
</li>
</ol>
<p>不断的循环这个过程，对于全网的MAC地址信息都可以学习到，二层交换机就是这样建立和维护它自己的地址表。</p>
<p>二层交换技术从网桥发展到VLAN（虚拟局域网），在局域网建设和改造中得到了广泛的应用。第二层交换技术是工作在OSI七层网络模型中的第二层，即数据链路层。它按照所接收到数据包的目的MAC地址来进行转发，对于网络层或者高层协议来说是透明的。它不处理网络层的IP地址，不处理高层协议的诸如TCP、UDP的端口地址，它只需要数据包的物理地址即MAC地址，数据交换是靠硬件来实现的，其速度相当快，这是二层交换的一个显著的优点。但是，它不能处理不同IP子网之间的数据交换。传统的路由器可以处理大量的跨越IP子网的数据包，但是它的转发效率比二层低，因此要想利用二层转发效率高这一优点，又要处理三层IP数据包，三层交换技术就诞生了。</p>
<h2 id="三层交换机"><a href="#三层交换机" class="headerlink" title="三层交换机"></a>三层交换机</h2><h3 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h3><p>传统交换技术是在OSI网络标准模型第二层–数据链路层进行操作的，而三层交换技术是在网络模型中的第三层实现了数据包的高速转发，既可实现网络路由功能，又可根据不同网络状况做到最优网络性能。</p>
<p>二层交换技术从网桥发展到VLAN（虚拟局域网），在局域网建设和改造中得到了广泛的应用。第二层交换技术是工作在OSI七层网络模型中的第二层，即数据链路层。它按照所接收到数据包的目的MAC地址来进行转发，对于网络层或者高层协议来说是透明的。</p>
<p>它不处理网络层的IP地址，不处理高层协议的诸如TCP、UDP的端口地址，它只需要数据包的物理地址即MAC地址，数据交换是靠硬件来实现的，其速度相当快，这是二层交换的一个显著的优点。但是，它不能处理不同IP子网之间的数据交换。传统的路由器可以处理大量的跨越IP子网的数据包，但是它的转发效率比二层低，因此要想利用二层转发效率高这一优点，又要处理三层IP数据包，三层交换技术就诞生了。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>三层交换（也称多层交换技术，或IP交换技术）是相对于传统交换概念而提出的。众所周知，传统的交换技术是在OSI网络标准模型中的第二层——数据链路层进行操作的，而三层交换技术是在网络模型中的第三层实现了数据包的高速转发。三层交换机就是具有部分路由器功能的交换机，三层交换机的最重要目的是加快大型局域网内部的数据交换，所具有的路由功能也是为这目的服务的，能够做到一次路由，多次转发。对于数据包转发等规律性的过程由硬件高速实现，而像路由信息更新、路由表维护、路由计算、路由确定等功能，由软件实现。简单地说，三层交换技术就是：二层交换技术＋三层转发技术。<br><img src="images/1909091.PNG" alt><br>三层交换机就是具有部分路由器功能的交换机。</p>
<p>三层交换机的最重要目的是加快大型局域网内部的数据交换，所具有的路由功能也是为这目的服务的，能够做到一次路由，多次转发。对于数据包转发等规律性的过程由硬件高速实现，而像路由信息更新、路由表维护、路由计算、路由确定等功能，由软件实现。三层交换技术就是二层交换技术+三层转发技术。</p>
<p>三层交换技术的出现，解决了局域网中网段划分之后，网段中子网必须依赖路由器进行管理的局面，解决了传统路由器低速、复杂所造成的网络瓶颈问题。<br><img src="images/1909092.PNG" alt><br>交换机在判断出目的IP不是自己的时候是不是一定就去查看路由表呢 ？不是，这个就是交换机的关键所在了，交换机此时不会查看路由表，不会查看arp表，不会查看mac地址表；那交换机会查看什么表？</p>
<p>交换机此时会查看自己集成在ASIC硬件转发卡中的硬件转发表，那这个硬件转发表都包含了什么内容呢？</p>
<ul>
<li>当第一个包过来的时候，发现硬件转发表并没有什么表项，所以此时必须将数据包交由路由进程处理，一旦交由cpu处理，必然会消耗cpu资源，此时会查看路由表，然后发现此IP地址和自己是直连的，此时就去查看arp找出此地址对应的mac地址，就可以转发出去了</li>
<li>在决定转发出去过程中，交换机至少会做三件事情，一，修改IP包头的ttl值；二，修改原mac地址，改成自己出接口mac地址；三，建立交换机硬件转发表，包括目的IP地址，目的IP地址（下一跳）对应的mac地址，mac地址对应的vlan，以及对应的端口（这个每个厂家有自己的理解）</li>
<li>这样当一下包过来的时候，交换机就会查看硬件转发表直接转发而不会在经过路由表的查询了，也即是交换机的一次路由，多次交换机原理。</li>
</ul>
<h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p>假设两个使用IP协议的站点A、B通过第三层交换机进行通信，发送站点A在开始发送时，把自己的IP地址与B站的IP地址比较，判断B站是否与自己在同一子网内。若目的站B与发送站A在同一子网内，则进行二层的转发。若两个站点不在同一子网内，如发送站A要与目的站B通信，发送站A要向“缺省网关”发出ARP(地址解析)封包，而“缺省网关”的IP地址其实是三层交换机的三层交换模块。</p>
<p>当发送站A对“缺省网关”的IP地址广播出一个ARP请求时，如果三层交换模块在以前的通信过程中已经知道B站的MAC地址，则向发送站A回复B的MAC地址。否则三层交换模块根据路由信息向B站广播一个ARP请求，B站得到此ARP请求后向三层交换模块回复其MAC地址，三层交换模块保存此地址并回复给发送站A,同时将B站的MAC地址发送到二层交换引擎的MAC地址表中。</p>
<p>从这以后，当A向B发送的数据包便全部交给二层交换处理，信息得以高速交换。由于仅仅在路由过程中才需要三层处理，绝大部分数据都通过二层交换转发，因此三层交换机的速度很快，接近二层交换机的速度，同时比相同路由器的价格低很多。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单点来说，二层和三层交换机最基本的区别就是，三层交换机具有路由功能，可以看作是网络层的设备（当然，也可以做二层用）。二层交换机是数据链路层的设备，不具备路由功能。</p>
<p>总之，二层交换机用于小型的局域网络。这个就不用多言了，在小型局域网中，广播包影响不大，二层交换机的快速交换功能、多个接入端口和低廉价格为小型网络用户提供了很完善的解决方案。</p>
<p>而三层交换机的最重要的功能是加快大型局域网络内部的数据的快速转发，加入路由功能也是为这个目的服务的。如果把大型网络按照部门，地域等等因素划分成一个个小局域网，这将导致大量的网际互访，单纯的使用二层交换机不能实现网际互访；如单纯的使用路由器，由于接口数量有限和路由转发速度慢，将限制网络的速度和网络规模，采用具有路由功能的快速转发的三层交换机就成为首选。</p>
<p>一般来说，在内网数据流量大，要求快速转发响应的网络中，如全部由三层交换机来做这个工作，会造成三层交换机负担过重，响应速度受影响，将网间的路由交由路由器去完成，充分发挥不同设备的优点，不失为一种好的组网策略，当然，前提是你的腰包很鼓，不然就退而求其次，让三层交换机也兼为网际互连。</p>
<p>传统交换技术是在OSI网络标准模型第二层–数据链路层进行操作的，而三层交换技术是在网络模型中的第三层实现了数据包的高速转发，既可实现网络路由功能，又可根据不同网络状况做到最优网络性能。</p>
<h2 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h2><p>二层交换机和三层交换机都属于以太网交换机。</p>
<p>以太网交换机是基于以太网传输数据的交换机，以太网采用共享总线型传输媒体方式的局域网。以太网交换机的结构是每个端口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。</p>
<p>以太网交换机应用最为普遍，价格也较便宜，档次齐全。因此，应用领域非常广泛，在大大小小的局域网都可以见到它们的踪影。</p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhishui0501.github.io/TCP-and-UDP.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="Keep Learning">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/TCP-and-UDP.html" class="post-title-link" itemprop="url">TCP and UDP</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-08 09:34:26 / Modified: 11:20:35" itemprop="dateCreated datePublished" datetime="2019-09-08T09:34:26+08:00">2019-09-08</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机网络/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP（User Data Protocol，用户数据报协议）它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去。<br>UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。比如，我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。例如，在默认状态下，一次“ping”操作发送4个数据包。发送的数据包数量是4包，收到的也是4包（因为对方主机收到后会发回一个确认收到的数据包）。这充分说明了UDP协议是面向非连接的协议，没有建立连接的过程。正因为UDP协议没有连接的过程，所以它的通信效果高；但也正因为如此，它的可靠性不如TCP协议高。QQ就使用UDP发消息，因此有时会出现收不到消息的情况。</p>
<p>我们来看一下 UDP 的包头<br><img src="images/1909081.PNG" alt><br>由上图可以看出，UDP 除了端口号，基本啥都没有了。如果没有这两个端口号，数据就不知道该发给哪个应用。<br>所以 UDP 特别简单，有如下三个特点</p>
<ol>
<li>沟通简单，不需要大量的数据结构，处理逻辑和包头字段</li>
<li>轻信他人。它不会建立连接，但是会监听这个地方，谁都可以传给它数据，它也可以传给任何人数据，甚至可以同时传给多个人数据。</li>
<li>愣头青，做事不懂变通。不会根据网络的情况进行拥塞控制，无论是否丢包，它该怎么发还是怎么发</li>
</ol>
<p>因为 UDP 是”小孩子”，所以处理的是一些没那么难的项目，并且就算失败的也能接收。基于这些特点的话，UDP 可以使用在如下场景中</p>
<ol>
<li>需要资源少，网络情况稳定的内网，或者对于丢包不敏感的应用，比如 DHCP 就是基于 UDP 协议的。</li>
<li>不需要一对一沟通，建立连接，而是可以广播的应用。因为它不面向连接，所以可以做到一对多，承担广播或者多播的协议。</li>
<li>需要处理速度快，可以容忍丢包，但是即使网络拥塞，也毫不退缩，一往无前的时候</li>
</ol>
<h3 id="UDP-的几个例子"><a href="#UDP-的几个例子" class="headerlink" title="UDP 的几个例子"></a>UDP 的几个例子</h3><ol>
<li>直播。直播对实时性的要求比较高，宁可丢包，也不要卡顿的，所以很多直播应用都基于 UDP 实现了自己的视频传输协议</li>
<li>实时游戏。游戏的特点也是实时性比较高，在这种情况下，采用自定义的可靠的 UDP 协议，自定义重传策略，能够把产生的延迟降到最低，减少网络问题对游戏造成的影响</li>
<li>物联网。一方面，物联网领域中断资源少，很可能只是个很小的嵌入式系统，而维护 TCP 协议的代价太大了；另一方面，物联网对实时性的要求也特别高。比如 Google 旗下的 Nest 简历 Thread Group，推出了物联网通信协议 Thread，就是基于 UDP 协议的</li>
</ol>
<h3 id="UDP的优点"><a href="#UDP的优点" class="headerlink" title="UDP的优点"></a>UDP的优点</h3><p>快，比TCP稍安全<br>    UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，udp是一个无状态的传输协议，所以他在传输数据时非常快。M没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。UDP也是无法避免攻击的，比如：UDP flood攻击。。。</p>
<h3 id="UDP的缺点"><a href="#UDP的缺点" class="headerlink" title="UDP的缺点"></a>UDP的缺点</h3><p>不可靠，不稳定<br>    因为UDP没有TCP的那些可靠机制，在网络质量不好时很容易丢包。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP（Transmission Control Protocol，传输控制协议）<br>首先是 TCP 的包头格式<br><img src="images/1909082.PNG" alt></p>
<ol>
<li>首先，源端口和目标端口是不可少的。</li>
<li>接下来是包的序号。主要是为了解决乱序问题。不编好号怎么知道哪个先来，哪个后到</li>
<li>确认序号。发出去的包应该有确认，这样能知道对方是否收到，如果没收到就应该重新发送，这个解决的是不丢包的问题</li>
<li>状态位。SYN 是发起一个链接，ACK 是回复，RST 是重新连接，FIN 是结束连接。因为 TCP 是面向连接的，因此需要双方维护连接的状态，这些状态位的包会引起双方的状态变更<br>窗口大小，TCP 要做流量控制，需要通信双方各声明一个窗口，标识自己当前的处理能力。</li>
</ol>
<p>通过对 TCP 头的解析，我们知道要掌握 TCP 协议，应该重点关注以下问题：</p>
<ul>
<li>顺序问题</li>
<li>丢包问题</li>
<li>连接维护</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
<h3 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h3><p>所有的问题，首先都要建立连接，所以首先是连接维护的问题</p>
<p>TCP 的建立连接称为三次握手，可以简单理解为下面这种情况</p>
<blockquote>
<p>A：您好，我是 A<br>    B：您好 A，我是 B<br>    A：您好 B</p>
</blockquote>
<p>对于 A 来说它发出请求，并收到了 B 的响应，对于 B 来说它响应了 A 的请求，并且也接收到了响应。</p>
<blockquote>
<p>TCP 的三次握手除了建立连接外，主要还是为了沟通 TCP 包的序号问题。</p>
</blockquote>
<p>A 告诉 B，我发起的包的序号是从哪个号开始的，B 同样也告诉 A，B 发起的 包的序号是从哪个号开始的。<br>双方建立连接之后需要共同维护一个状态机，在建立连接的过程中，双方的状态变化时序图如下所示<br><img src="images/1909083.PNG" alt><br>这是网上经常见到的一张图，刚开始的时候，客户端和服务器都处于 CLOSED 状态，先是服务端主动监听某个端口，处于 LISTEN 状态。然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态。服务端接收了发起的连接，返回 SYN，并且 ACK ( 确认 ) 客户端的 SYN，之后处于 SYN-SENT 状态。客户端接收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后就处于 ESTAVLISHED 状态，因为它一发一收成功了。服务端收到 ACK 的 ACK 之后，也处于 ESTABLISHED 状态，因为它也一发一收了。</p>
<h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><p>说完建立连接，再说下断开连接，也被称为四次挥手，可以简单理解如下</p>
<blockquote>
<p>A：B 啊，我不想玩了<br>    B：哦，你不想玩了啊，我知道了<br>    这个时候，只是 A 不想玩了，即不再发送数据，但是 B 可能还有未发送完的数据，所以需要等待 B 也主动关闭。<br>    B：A 啊，好吧，我也不玩了，拜拜<br>    A：好的，拜拜</p>
</blockquote>
<p>这样整个连接就关闭了，当然上面只是正常的状态，也有些非正常的状态（比如 A 说完不玩了，直接跑路，B 发起的结束得不到 A 的回答，不知道该怎么办或则 B 直接跑路 A 不知道该怎么办），TCP 协议专门设计了几个状态来处理这些非正常状态<br><img src="images/1909084.PNG" alt><br>断开的时候，当 A 说不玩了，就进入 FIN_WAIT_1 的状态，B 收到 A 不玩了的消息后，进入 CLOSE_WAIT 的状态。</p>
<p>A 收到 B 说知道了，就进入 FIN_WAIT_2 的状态，如果 B 直接跑路，则 A 永远处与这个状态。TCP 协议里面并没有对这个状态的处理，但 Linux 有，可以调整 tcp_fin_timeout 这个参数，设置一个超时时间。</p>
<p>如果 B 没有跑路，A 接收到 B 的不玩了请求之后，从 FIN_WAIT_2 状态结束，按说 A 可以跑路了，但是如果 B 没有接收到 A 跑路的 ACK 呢，就再也接收不到了，所以这时候 A 需要等待一段时间，因为如果 B 没接收到 A 的 ACK 的话会重新发送给 A，所以 A 的等待时间需要足够长。</p>
<h3 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h3><blockquote>
<p>TCP 如何实现可靠传输?<br>首先为了保证顺序性，每个包都有一个 ID。在建立连接的时候会商定起始 ID 是什么，然后按照 ID 一个个发送，为了保证不丢包，需要对发送的包都要进行应答，当然，这个应答不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这种模式成为累计应答或累计确认。</p>
</blockquote>
<p>为了记录所有发送的包和接收的包，TCP 需要发送端和接收端分别来缓存这些记录，发送端的缓存里是按照包的 ID 一个个排列，根据处理的情况分成四个部分</p>
<ul>
<li>发送并且确认的</li>
<li>发送尚未确认的</li>
<li>没有发送等待发送的</li>
<li>没有发送并且暂时不会发送的</li>
</ul>
<p>这里的第三部分和第四部分就属于流量控制的内容</p>
<p>在 TCP 里，接收端会给发送端报一个窗口大小，叫 Advertised window。这个窗口应该等于上面的第二部分加上第三部分，超过这个窗口，接收端做不过来，就不能发送了</p>
<p>于是，发送端要保持下面的数据结构<br><img src="images/1909085.PNG" alt></p>
<p>对于接收端来讲，它的缓存里面的内容要简单一些</p>
<ul>
<li>接收并且确认过的</li>
<li>还没接收，但是马上就能接收的</li>
<li>还没接收，但也无法接收的<br>对应的数据结构如下<br><img src="images/1909086.PNG" alt></li>
</ul>
<h3 id="顺序问题和丢包问题"><a href="#顺序问题和丢包问题" class="headerlink" title="顺序问题和丢包问题"></a>顺序问题和丢包问题</h3><p>结合上面的图看，在发送端，1、2、3 已发送并确认；4、5、6、7、8、9 都是发送了还没确认；10、11、12 是还没发出的；13、14、15 是接收方没有空间，不准备发的。</p>
<p>在接收端来看，1、2、3、4、5 是已经完成 ACK 但是还没读取的；6、7 是等待接收的；8、9 是已经接收还没有 ACK 的。<br>发送端和接收端当前的状态如下：</p>
<ul>
<li>1、2、3 没有问题，双方达成了一致</li>
<li>4、5 接收方说 ACK 了，但是发送方还没收到</li>
<li>6、7、8、9 肯定都发了，但是 8、9 已经到了，6、7 没到，出现了乱序，缓存着但是没办法 ACK。<br>根据这个例子可以知道顺序问题和丢包问题都有可能存在，所以我们先来看确认与重传机制。</li>
</ul>
<p>假设 4 的确认收到了，5 的 ACK 丢了，6、7 的数据包丢了，该怎么办？</p>
<p>一种方法是超时重试，即对每一个发送了但是没有 ACK 的包设定一个定时器，超过了一定的事件就重新尝试。这个时间必须大于往返时间，但也不宜过长，否则超时时间变长，访问就变慢了。</p>
<p>如果过一段时间，5、6、7 都超时了就会重新发送。接收方发现 5 原来接收过，于是丢弃 5；6 收到了，发送 ACK，要求下一个是 7，7 不幸又丢了。当 7 再次超时的时候，TCP 的策略是超时间隔加倍。每当遇到一次超时重传的时候，都会讲下一次超时时间间隔设为先前值的两倍。</p>
<p>超时重传的机制是超时周期可能相对较长，是否有更快的方式呢？</p>
<p>有一个快速重传的机制，即当接收方接收到一个序号大于期望的报文段时，就检测到了数据流之间的间隔，于是发送三个冗余的 ACK，客户端接收到之后，知道数据报丢失，于是重传丢失的报文段。</p>
<p>例如，接收方发现 6、8、9 都接收了，但是 7 没来，所以肯定丢了，于是发送三个 6 的 ACK，要求下一个是 7。客户端接收到 3 个，就会发现 7 的确又丢了，不等超时，马上重发。</p>
<h3 id="流量控制的问题"><a href="#流量控制的问题" class="headerlink" title="流量控制的问题"></a>流量控制的问题</h3><p>在流量控制的机制里面，在对于包的确认中，会携带一个窗口的大小</p>
<p>简单的说一下就是接收端在发送 ACK 的时候会带上缓冲区的窗口大小，但是一般在窗口达到一定大小才会更新窗口，因为每次都更新的话，刚空下来就又被填满了</p>
<h3 id="拥塞控制的问题"><a href="#拥塞控制的问题" class="headerlink" title="拥塞控制的问题"></a>拥塞控制的问题</h3><p>也是通过窗口的大小来控制的，但是检测网络满不满是个挺难的事情，所以 TCP 发送包经常被比喻成往水管里灌水，所以拥塞控制就是在不堵塞，不丢包的情况下尽可能的发挥带宽。</p>
<p>水管有粗细，网络有带宽，即每秒钟能发送多少数据；水管有长度，端到端有时延。理想状态下，水管里面的水 = 水管粗细 * 水管长度。对于网络上，通道的容量 = 带宽 * 往返时延。</p>
<p>如果我们设置发送窗口，使得发送但未确认的包为通道的容量，就能撑满整个管道。<br><img src="images/1909087.PNG" alt><br>如图所示，假设往返时间为 8 秒，去 4 秒，回 4 秒，每秒发送一个包，已经过去了 8 秒，则 8 个包都发出去了，其中前四个已经到达接收端，但是 ACK 还没返回，不能算发送成功，5-8 后四个包还在路上，还没被接收，这个时候，管道正好撑满，在发送端，已发送未确认的 8 个包，正好等于带宽，也即每秒发送一个包，也即每秒发送一个包，乘以来回时间 8 秒。</p>
<p>如果在这个基础上调大窗口，使得单位时间可以发送更多的包，那么会出现接收端处理不过来，多出来的包会被丢弃，这个时候，我们可以增加一个缓存，但是缓存里面的包 4 秒内肯定达不到接收端课，它的缺点会增加时延，如果时延达到一定程度就会超时重传</p>
<p>TCP 拥塞控制主要来避免两种现象，包丢失和超时重传，一旦出现了这些现象说明发送的太快了，要慢一点。</p>
<p>具体的方法就是发送端慢启动，比如倒水，刚开始倒的很慢，渐渐变快。然后设置一个阈值，当超过这个值的时候就要慢下来</p>
<p>慢下来还是在增长，这时候就可能水满则溢，出现拥塞，需要降低倒水的速度，等水慢慢渗下去。</p>
<p>拥塞的一种表现是丢包，需要超时重传，这个时候，采用快速重传算法，将当前速度变为一半。所以速度还是在比较高的值，也没有一夜回到解放前。</p>
<h3 id="Tcp的优点"><a href="#Tcp的优点" class="headerlink" title="Tcp的优点"></a>Tcp的优点</h3><p>可靠，稳定<br>    TCP的可靠性体现在传输数据之前，三次握手建立连接（四次挥手释放连接），并且在数据传递时，有确认、窗口、重传、拥塞控制机制，数据传完之后，断开连接用来节省系统资源。</p>
<h3 id="TCP的缺点"><a href="#TCP的缺点" class="headerlink" title="TCP的缺点"></a>TCP的缺点</h3><p>慢，效率低，占用系统资源高，易被攻击<br>    传数据之前建立连接，这样会消耗时间，而且在消息传递时，确认机制、重传机制和拥塞控制机制都会消耗大量的时间，而且要在每台设备上维护所有的传输连接。而每个连接都会占用系统的CPU、内存等硬件软件资源。并且TCP的取而机制、三次握手，这些也导致TCP容易被人利用，实现DOS，DDOS攻击。</p>
<h2 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2><p>UDP 是一种面向无连接，且不可靠的协议，在通信过程中，它并不像 TCP 那样需要先建立一个连接，只要（目的地址，端口号，源地址，端口号）确定了，就可以直接发送信息报文，并且不需要确保服务端一定能收到或收到完整的数据。它仅仅提供了校验和机制来保障一个报文是否完整，若校验失败，则直接丢弃报文，不做任何处理。</p>
<p>TCP和UDP都是传输层协议，但是两者具有不同的特性和应用场景</p>
<ol>
<li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。</li>
<li>UDP程序结构较简单</li>
<li>TCP 是面向字节流的，UDP 是基于数据报的</li>
<li>TCP 保证数据正确性，UDP 可能丢包</li>
<li>TCP 保证数据顺序，UDP 不保证</li>
<li>TCP要求系统资源较多，UDP较少。</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。</li>
<li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。</li>
<li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。</li>
<li>TCP首部开销20字节;UDP的首部开销小，只有8个字节。</li>
<li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。<br><img src="images/1909088.PNG" alt></li>
</ol>
<p><strong>名词解释</strong><br><strong>面向报文和面向字节流</strong><br>面向报文的传输方式是应用层交给UDP多长的报文，UDP就发送多长的报文，即一次发送一个报文。因此应用程序必须选择大小合适的报文。报文太长，则IP层需要分片，降低效率。</p>
<p>面向字节流的传输方式是应用程序和TCP的交互是一次一个数据块（大小不等），TCP把这些数据块看成是一连串无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就会把它分割成多块传送。<br><strong>双工性</strong><br>全双工：是指在发送数据的同时也能够接收数据，两者同步进行，这好像我们平时打电话一样，说话的同时也能够听到对方的声音。目前的网卡一般都支持全双工。</p>
<p>半双工：所谓半双工就是指一个时间段内只有一个动作发生，举个简单例子，一条窄窄的马路，同时只能有一辆车通过，当目前有两量车对开，这种情况下就只能一辆先过，等到头儿后另一辆再开，这个例子就形象的说明了半双工的原理。</p>
<h2 id="TCP-UDP编程模型"><a href="#TCP-UDP编程模型" class="headerlink" title="TCP/UDP编程模型"></a>TCP/UDP编程模型</h2><p>从程序实现的角度来看，可以用下图来进行描述。<br><img src="images/1909089.PNG" alt><br>从上图也能清晰的看出，TCP通信需要服务器端侦听listen、接收客户端连接请求accept，等待客户端connect建立连接后才能进行数据包的收发（recv/send）工作。而UDP则服务器和客户端的概念不明显，服务器端即接收端需要绑定端口，等待客户端的数据的到来。后续便可以进行数据的收发（recvfrom/sendto）工作。</p>
<p>前面提到了UDP保留了报文的边界，下面我们来谈谈TCP和UDP中报文的边界问题。在默认的阻塞模式下，TCP无边界，UDP有边界。</p>
<p>对于TCP协议，客户端连续发送数据，只要服务端的这个函数的缓冲区足够大，会一次性接收过来，即客户端是分好几次发过来，是有边界的，而服务端却一次性接收过来，所以证明是无边界的；</p>
<p>而对于UDP协议，客户端连续发送数据，即使服务端的这个函数的缓冲区足够大，也只会一次一次的接收，发送多少次接收多少次，即客户端分几次发送过来，服务端就必须按几次接收，从而证明，这种UDP的通讯模式是有边界的。</p>
<h2 id="TCP-与-UDP-的应用场景"><a href="#TCP-与-UDP-的应用场景" class="headerlink" title="TCP 与 UDP 的应用场景"></a>TCP 与 UDP 的应用场景</h2><p><img src="images/19090810.jpg" alt><br><img src="images/19090811.jpg" alt><br>从特点上我们已经知道，TCP 是可靠的但传输速度慢 ，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。</p>
<p>若通信数据完整性需让位与通信实时性，则应该选用 TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。</p>
<h3 id="什么时候应该使用TCP"><a href="#什么时候应该使用TCP" class="headerlink" title="什么时候应该使用TCP"></a>什么时候应该使用TCP</h3><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。</p>
<p>在日常生活中，常见使用TCP协议的应用如下：</p>
<ul>
<li>浏览器，用的HTTP</li>
<li>FlashFXP，用的FTP</li>
<li>Outlook，用的POP、SMTP</li>
<li>Putty，用的Telnet、SSH</li>
<li>QQ文件传输</li>
</ul>
<h3 id="什么时候应该使用UDP"><a href="#什么时候应该使用UDP" class="headerlink" title="什么时候应该使用UDP"></a>什么时候应该使用UDP</h3><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。<br>比如，日常生活中，常见使用UDP协议的应用如下：</p>
<ul>
<li>QQ语音</li>
<li>QQ视频</li>
<li>TFTP</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="什么是面向连接，什么是面向无连接"><a href="#什么是面向连接，什么是面向无连接" class="headerlink" title="什么是面向连接，什么是面向无连接"></a>什么是面向连接，什么是面向无连接</h3><p>在互通之前，面向连接的协议会先建立连接，如 TCP 有三次握手，而 UDP 不会</p>
<h3 id="TCP-为什么是可靠连接"><a href="#TCP-为什么是可靠连接" class="headerlink" title="TCP 为什么是可靠连接"></a>TCP 为什么是可靠连接</h3><ul>
<li>通过 TCP 连接传输的数据无差错，不丢失，不重复，且按顺序到达。</li>
<li>TCP 报文头里面的序号能使 TCP 的数据按序到达</li>
<li>报文头里面的确认序号能保证不丢包，累计确认及超时重传机制</li>
<li>TCP 拥有流量控制及拥塞控制的机制<br>TCP 的顺序问题，丢包问题，流量控制都是通过滑动窗口来解决的<br>拥塞控制时通过拥塞窗口来解决的</li>
</ul>
<p>两种协议都是传输层协议，为应用层提供信息载体。TCP协议是基于连接的可靠协议，有流量控制和差错控制，也正因为有可靠性的保证和控制手段，所以传输效率比UDP低；UDP协议是基于无连接的不可靠协议，没有控制手段，仅仅是将数据发送给对方，因此效率比TCP要高。</p>
<p>基于上述特性，不难得到结论，TCP协议适用于对效率要求相对低，但对准确性要求相对高的场景下，或者是有一种连接概念的场景下；而UDP协议适用于对效率要求相对高，对准确性要求相对低的场景。</p>
<p>几个应用的例子。TCP一般用于文件传输（FTP HTTP 对数据准确性要求高，速度可以相对慢），发送或接收邮件（POP IMAP SMTP 对数据准确性要求高，非紧急应用），远程登录（TELNET SSH 对数据准确性有一定要求，有连接的概念）等等；UDP一般用于即时通信（QQ聊天 对数据准确性和丢包要求比较低，但速度必须快），在线视频（RTSP 速度一定要快，保证视频连续，但是偶尔花了一个图像帧，人们还是能接受的），网络语音电话（VoIP 语音数据包一般比较小，需要高速发送，偶尔断音或串音也没有问题）等等。<br>一些其他应用。比如，TCP可以用于网络数据库，分布式高精度计算系统的数据传输；UDP可以用于服务系统内部之间的数据传输，因为数据可能比较多，内部系统局域网内的丢包错包率又很低，即便丢包，顶多是操作无效，这种情况下，UDP经常被使用。</p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhishui0501.github.io/CDN.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="Keep Learning">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/CDN.html" class="post-title-link" itemprop="url">CDN</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-07 22:59:05 / Modified: 23:11:31" itemprop="dateCreated datePublished" datetime="2019-09-07T22:59:05+08:00">2019-09-07</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机网络/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CDN(Content Delivery Network)是指内容分发网络，也称为内容传送网络，这个概念始于1996年，是美国麻省理工学院的一个研究小组为改善互联网的服务质量而提出的。为了能在传统IP网上发布丰富的宽带媒体内容，他们提出在现有互联网基础上建立一个内容分发平台专门为网站提供服务，并于1999年成立了专门的CDN服务公司，为Yahoo提供专业服务。由于CDN是为加快网络访问速度而被优化的网络覆盖层，因此被形象地称为“网络加速器”。 </p>
<p>CDN网络的诞生大大地改善了互联网的服务质量，因此传统的大型网络运营商纷纷开始建设自己的CDN网络，如AT&amp;T、德国电信、中国电信等。随着市场需求的不断增加，甚至出现了纯粹的CDN网络运营商，美国的Akamai就是其中最大的一个，拥有分布在世界各地的1000多个节点。我国第一家纯粹的CDN网络服务公司是北京蓝汛公司，已从2000年开始建立了一个专门的CDN服务网络一ChinaCache。目前CDN网络已经突破50个节点，覆盖中国六大骨干网络一中国电信、中国网通、中国移动、中国联通、中国铁通网络以及中国教育网，带宽资源储备超过35G，服务的客户数量达到300多家。</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>CDN网络中包含的功能实体包括内容缓存设备、内容交换机、内容路由器、CDN内容管理系统等组成。<br>内容缓存为CDN网络节点，位于用户接入点，是面向最终用户的内容提供设备，可缓存静态Web内容和流媒体内容，实现内容的边缘传播和存储，以便用户的就近访问。<br>内容交换机处于用户接入集中点，可以均衡单点多个内容缓存设备的负载，并对内容进行缓存负载平衡及访问控制。<br>内容路由器负责将用户的请求调度到适当的设备上。内容路由通常通过负载均衡系统来实现，动态均衡各个内容缓存站点的载荷分配，为用户的请求选择最佳的访问站点，同时提高网站的可用性。内容路由器可根据多种因素制定路由，包括站点与用户的临近度、内容的可用性、网络负载、设备状况等。负载均衡系统是整个CDN的核心。负载均衡的准确性和效率直接决定了整个CDN的效率和性能。<br>内容管理系统负责整个CDN的管理，是可选部件，作用是进行内容管理，如内容的注入和发布、内容的分发、内容的审核、内容的服务等。</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol>
<li>节省骨干网带宽，减少带宽需求量；</li>
<li>提供服务器端加速，解决由于用户访问量大造成的服务器过载问题</li>
<li>服务商能使用Web Cache技术在本地缓存用户访问过的Web页面和对象，实现相同对象的访问无须占用主干的出口带宽，并提高用户访问因特网页面的相应时间的需求；</li>
<li>能克服网站分布不均的问题，并且能降低网站自身建设和维护成本；</li>
<li>降低“通信风暴”的影响，提高网络访问的稳定性。</li>
</ol>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</p>
<p>CDN的基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</p>
<h2 id="服务模式"><a href="#服务模式" class="headerlink" title="服务模式"></a>服务模式</h2><p>内容分发网络（CDN）是一种新型网络构建方式，它是为能在传统的IP网发布宽带丰富媒体而特别优化的网络覆盖层；而从广义的角度，CDN代表了一种基于质量与秩序的网络服务模式。<br>简单地说，内容分发网络（CDN）是一个经策略性部署的整体系统，包括分布式存储、负载均衡、网络请求的重定向和内容管理4个要件，而内容管理和全局的网络流量管理（Traffic Management）是CDN的核心所在。通过用户就近性和服务器负载的判断，CDN确保内容以一种极为高效的方式为用户的请求提供服务。<br>总的来说，内容服务基于缓存服务器，也称作代理缓存（Surrogate），它位于网络的边缘，距用户仅有”一跳”（Single Hop）之遥。同时，代理缓存是内容提供商源服务器（通常位于CDN服务提供商的数据中心）的一个透明镜像。这样的架构使得CDN服务提供商能够代表他们客户，即内容供应商，向最终用户提供尽可能好的体验，而这些用户是不能容忍请求响应时间有任何延迟的。   </p>
<h2 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h2><ol>
<li>本地Cache加速：提高了企业站点（尤其含有大量图片和静态页面站点）的访问速度，并大大提高以上性质站点的稳定性。    </li>
<li>镜像服务：消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。    </li>
<li>远程加速：远程访问用户根据DNS负载均衡技术智能自动选择Cache服务器，选择最快的Cache服务器，加快远程访问的速度。    </li>
<li>带宽优化：自动生成服务器的远程Mirror（镜像）cache服务器，远程用户访问时从cache服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点WEB服务器负载等功能。    </li>
<li>集群抗攻击：广泛分布的CDN节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种D.D.o.S攻击对网站的影响，同时保证较好的服务质量 。</li>
</ol>
<h2 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h2><h3 id="内容发布"><a href="#内容发布" class="headerlink" title="内容发布"></a>内容发布</h3><p>它借助于建立索引、缓存、流分裂、组播（Multicast）等技术，将内容发布或投递到距离用户最近的远程服务点（POP）处。<br>内容分发包含从内容源到CDN边缘的Cache的过程。从实现上，有两种主流的内容分发技术：PUSH和PULL。<br>PUSH是一种主动分发的技术。通常，PUSH由内容管理系统发起，将内容从源或者中心媒体资源库分发到各边缘的 Cache节点。分发的协议可以采用 Http/ftp等。通过PUSH分发的内容一般是比较热点的内容，这些内容通过PUSH方式预分发（ Preload）到边缘Cache，可以实现有针对的内容提供。对于PUSH分发需要考虑的主要问题是分发策略，即在什么时候分发什么内容。一般来说，内容分发可以由CP（内容提供商）或者CDN内容管理员人工确定，也可以通过智能的方式决定，即所谓的智能分发，它根据用户访问的统计信息，以及预定义的内容分发的规则，确定内容分发的过程PULL是一种被动的分发技术，PULL分发通常由用户请求驱动。当用户请求的内容在本地的边缘 Cache上不存在（未命中）时， Cache启动PUL方法从内容源或者其他CDN节点实时获取内容。在PULL方式下，内容的分发是按需的。</p>
<h3 id="内容路由"><a href="#内容路由" class="headerlink" title="内容路由"></a>内容路由</h3><p>它是整体性的网络负载均衡技术，通过内容路由器中的重定向（DNS）机制，在多个远程POP上均衡用户的请求，以使用户请求得到最近内容源的响应。</p>
<p>CDN负载均衡系统实现CDN的内容路由功能。它的作用是将用户的请求导向整个CDN网络中的最佳节点。最佳节点的选定可以根据多种策略，例如距离最近、节点负载最轻等。负载均衡系统是整个CDN的核心，负载均衡的准确性和效率直接决定了整个CDN的效率和性能。通常负载均衡可以分为两个层次:全局负载均衡（GSLB）和本地负载均衡（SLB）。全局负载均衡主要的目的是在整个网络范围内将用户的请求定向到最近的节点（或者区域）。因此，就近性判断是全局负载均衡的主要功能。本地负载均衡一般局限于一定的区域范围内，其目标是在特定的区域范围内寻找一台最适合的节点提供服务，因此，CDN节点的健康性、负载情况、支持的媒体格式等运行状态是本地负载均衡进行决策的主要依据。</p>
<h3 id="内容存储"><a href="#内容存储" class="headerlink" title="内容存储"></a>内容存储</h3><p>对于CDN系统而言，需要考虑两个方面的内容存储问题。一个是内容源的存储，一个是内容在 Cache节点中的存储。<br>对于内容源的存储，由于内容的规模比较大（通常可以达到几个甚至几十个TB），而且内容的吞吐量较大，因此，通常采用海量存储架构，如NAS和SON。对于在 Cache节点中的存储，是 Cache设计的一个关键问题。需要考虑的因素包括功能和性能两个方面:功能上包括对各种内容格式的支持，对部分缓存的支持;在性能上包括支持的容量、多文件吞吐率、可靠性、稳定性。<br>其中，多种内容格式的支持要求存储系统根据不同文件格式的读写特点进行优化，以提高文件内容读写的效率。特别是对针对流媒体文件的读写。部分缓存能力指流媒体内容可以以不完整的方式存储和读取。部分缓存的需求来自用户访问行为的随机性，因为许多用户并不会完整地收看整个流媒体节目。事实上，许多用户访问单个流媒体节目的时间不超过10分钟。因此，部分缓存能力能够大大提高存储空间的利用率，并有效提高用户请求的响应时间。但是部分缓存可能导致内容的碎片问题，需要进行良好的设计和控制。<br>Cache存储的另一个重要因素是存储的可靠性，目前，多数存储系统都采用了独立磁盘冗余阵列（RAID）技术进行可靠存储。但是不同设备使用的RAID方式各有不同。</p>
<h3 id="内容管理"><a href="#内容管理" class="headerlink" title="内容管理"></a>内容管理</h3><p>它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能（如包丢失、延时、平均带宽、启动时间、帧速率等），保证网络处于最佳的运行状态。<br>内容管理在广义上涵盖了从内容的发布、注入、分发、调整、传递等一系列过程。在这里，内容管理重点强调内容进人 Cache点后的内容管理，称其为本地内容管理。本地内容管理主要针对一个ODN节点（有多个 CDN Cache设备和一个SLB设备构成）进行。本地内容管理的主要目标是提高内容服务的效率，提高本地节点的存储利用率。通过本地内容管理，可以在CDN节点实现基于内容感知的调度，通过内容感知的调度，可以避免将用户重定向到没有该内容的 Cache设备上，从而提高负载均衡的效率。通过本地内容管理还可以有效实现在ODN节点内容的存储共享，提高存储空间的利用率。</p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhishui0501.github.io/abstract抽象类和interface接口有什么区别.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="Keep Learning">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/abstract抽象类和interface接口有什么区别.html" class="post-title-link" itemprop="url">abstract class抽象类和interface接口有什么区别</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-04 15:58:53 / Modified: 18:24:57" itemprop="dateCreated datePublished" datetime="2019-09-04T15:58:53+08:00">2019-09-04</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>含有 abstract 修饰符 class 即为抽象类，抽象类不能创建实际对象，含有抽象方法的抽象类必须定义为 abstract class。</p>
<p>接口可以说成是一种特殊的抽象类，接口中的所有方法都必须是抽象的，接口中的方法定义默认为 public abstract 类型，接口中的成员产量类型默认为 public static final。<br>两者的区别:</p>
<ol>
<li><p>抽象类可以有构造方法，接口中不能有构造方法。</p>
</li>
<li><p>抽象类中可以有普通成员变量，接口中没有普通成员变量。</p>
</li>
<li><p>抽象类中可以包含非抽象普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的方法。</p>
</li>
<li><p>抽象类中的抽象方法的访问权限可以是 public、protected 和(默认类型，虽然 eclipse 不报错，但也不能用，默认类型子类不能继承)，接口中的抽象方法只能是 public 类型的，并且默认即为 public abstract 类型。</p>
</li>
<li><p>抽象类中可以包含静态方法，在 JDK1.8 之前接口中不能不包含静态方法，JDK1.8 以后可以包含。</p>
</li>
<li><p>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问权限可以是任意的，但接口中定义的变量只能是 public static final 类型的，并且默认即为 public static final 类型。</p>
</li>
<li><p>一个类可以实现多个接口，用逗号隔开，但只能继承一个抽象类，接口不可以实现接口，但可以继承接口，并且可以继承多个接口，用逗号隔开。</p>
</li>
</ol>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhishui0501.github.io/Java中ArrayList与LinkedList的区别.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="Keep Learning">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/Java中ArrayList与LinkedList的区别.html" class="post-title-link" itemprop="url">Java中ArrayList与LinkedList的区别</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-03 22:33:02 / Modified: 22:52:10" itemprop="dateCreated datePublished" datetime="2019-09-03T22:33:02+08:00">2019-09-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol>
<li><p>ArrayList的实现是基于数组，LinkedList的实现是基于双向链表。 </p>
</li>
<li><p>对于随机访问，ArrayList优于LinkedList</p>
</li>
<li><p>对于插入和删除操作，LinkedList优于ArrayList</p>
</li>
<li><p>LinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</p>
<h2 id="在时间复杂度上的区别"><a href="#在时间复杂度上的区别" class="headerlink" title="在时间复杂度上的区别"></a>在时间复杂度上的区别</h2><p>假设我们有两个很大的列表，它们里面的元素已经排好序了，这两个列表分别是ArrayList类型和LinkedList类型的，现在我们对这两个列表来进行二分查找(binary search)，比较它们的查找速度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> 1 package com.demo;</span><br><span class="line"> 2 </span><br><span class="line"> 3 import java.util.ArrayList;</span><br><span class="line"> 4 import java.util.Collections;</span><br><span class="line"> 5 import java.util.LinkedList;</span><br><span class="line"> 6 import java.util.List;</span><br><span class="line"> 7 </span><br><span class="line"> 8 public class Demo1 &#123;</span><br><span class="line"> 9     static List&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;();</span><br><span class="line">10     static List&lt;Integer&gt; linked = new LinkedList&lt;Integer&gt;();</span><br><span class="line">11 </span><br><span class="line">12     public static void main(String[] args) &#123;</span><br><span class="line">13 </span><br><span class="line">14         for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">15             array.add(i);</span><br><span class="line">16             linked.add(i);</span><br><span class="line">17         &#125;</span><br><span class="line">18         System.out.println(&quot;ArrayList访问消耗的时间：&quot; + getTime(array));</span><br><span class="line">19         System.out.println(&quot;LinkedList访问消耗的时间：&quot; + getTime(linked));</span><br><span class="line">20     &#125;</span><br><span class="line">21 </span><br><span class="line">22     public static long getTime(List list) &#123;</span><br><span class="line">23         long time = System.currentTimeMillis();</span><br><span class="line">24         for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">25             int index = Collections.binarySearch(list, list.get(i));</span><br><span class="line">26             if (index != i) &#123;</span><br><span class="line">27                 System.out.println(&quot;ERROR!&quot;);</span><br><span class="line">28             &#125;</span><br><span class="line">29         &#125;</span><br><span class="line">30         return System.currentTimeMillis() - time;</span><br><span class="line">31     &#125;</span><br><span class="line">32 </span><br><span class="line">33 &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList访问消耗的时间：10</span><br><span class="line">LinkedList访问消耗的时间：383</span><br></pre></td></tr></table></figure>

<p>可以看出，对于随机访问，ArrayList的访问速度更快。 </p>
<p>ArrayList和LinkedList的插入数据耗时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> 1 package com.demo;</span><br><span class="line"> 2 </span><br><span class="line"> 3 import java.util.ArrayList; </span><br><span class="line"> 4 import java.util.LinkedList;</span><br><span class="line"> 5 import java.util.List;</span><br><span class="line"> 6 </span><br><span class="line"> 7 public class Demo2 &#123;</span><br><span class="line"> 8     static List&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;();</span><br><span class="line"> 9     static List&lt;Integer&gt; linked = new LinkedList&lt;Integer&gt;();</span><br><span class="line">10 </span><br><span class="line">11     public static void main(String[] args) &#123;</span><br><span class="line">12 </span><br><span class="line">13         for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">14             array.add(i);</span><br><span class="line">15             linked.add(i);</span><br><span class="line">16         &#125;</span><br><span class="line">17         System.out.println(&quot;ArrayList插入消耗的时间：&quot; + insertTime(array));</span><br><span class="line">18         System.out.println(&quot;LinkedList插入消耗的时间：&quot; + insertTime(linked));</span><br><span class="line">19     &#125;</span><br><span class="line">20 </span><br><span class="line">21     public static long insertTime(List list) &#123;</span><br><span class="line">22         long time = System.currentTimeMillis();</span><br><span class="line">23         for (int i = 100; i &lt; 10000; i++) &#123;</span><br><span class="line">24             list.add(10, i); // 在索引为10的位置插入i</span><br><span class="line">25         &#125;</span><br><span class="line">26         return System.currentTimeMillis() - time;</span><br><span class="line">27     &#125;</span><br><span class="line">28 &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList插入消耗的时间：31</span><br><span class="line">LinkedList插入消耗的时间：4</span><br></pre></td></tr></table></figure>

<p>可以看出，对于插入操作，LinkedList 的速度更快</p>
<h2 id="在空间复杂度上的区别"><a href="#在空间复杂度上的区别" class="headerlink" title="在空间复杂度上的区别"></a>在空间复杂度上的区别</h2><p>在LinkedList中有一个私有的内部类，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static class Entry &#123;   </span><br><span class="line">         Object element;   </span><br><span class="line">         Entry next;   </span><br><span class="line">         Entry previous;   </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>LinkedList中的每一个元素中还存储了它的前一个元素的索引和后一个元素的索引。</p>
<p>ArrayList使用一个内置的数组来存储元素，这个数组的起始容量是10，当数组需要增长时，新的容量按如下公式获得：新容量 = 旧容量*1.5 + 1，也就是说每一次容量大概会增长50% </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>ArrayList的实现是基于数组，LinkedList的实现是基于双向链表。 </p>
</li>
<li><p>对于随机访问，ArrayList优于LinkedList，ArrayList可以根据下标以O(1)时间复杂度对元素进行随机访问。而LinkedList的每一个元素都依靠地址指针和它后一个元素连接在一起，在这种情况下，查找某个元素的时间复杂度是O(n) </p>
</li>
<li><p>对于插入和删除操作，LinkedList优于ArrayList，因为当元素被添加到LinkedList任意位置的时候，不需要像ArrayList那样重新计算大小或者是更新索引。 </p>
</li>
<li><p>LinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</p>
</li>
</ol>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhishui0501.github.io/数据结构.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="Keep Learning">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/数据结构.html" class="post-title-link" itemprop="url">数据结构</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-02 20:48:33 / Modified: 21:05:43" itemprop="dateCreated datePublished" datetime="2019-09-02T20:48:33+08:00">2019-09-02</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的逻辑结构和数据的物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构。</p>
<p>数据的逻辑结构和物理结构是数据结构的两个密切相关的方面，同一逻辑结构可以对应不同的存储结构。算法的设计取决于数据的逻辑结构，而算法的实现依赖于指定的存储结构。</p>
<p>数据结构的研究内容是构造复杂软件系统的基础，它的核心技术是分解与抽象。通过分解可以划分出数据的3个层次；再通过抽象，舍弃数据元素的具体内容，就得到逻辑结构。类似地，通过分解将处理要求划分成各种功能，再通过抽象舍弃实现细节，就得到运算的定义。上述两个方面的结合可以将问题变换为数据结构。这是一个从具体（即具体问题）到抽象（即数据结构）的过程。然后，通过增加对实现细节的考虑进一步得到存储结构和实现运算，从而完成设计任务。这是一个从抽象（即数据结构）到具体（即具体实现）的过程。</p>
<h2 id="常用的数据结构"><a href="#常用的数据结构" class="headerlink" title="常用的数据结构"></a>常用的数据结构</h2><p>数组(Array)<br>数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。数组可以说是最基本的数据结构，在各种编程语言中都有对应。一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等。数组还可以有一维、二维以及多维等表现形式。   </p>
<p>栈( Stack)<br>栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。栈按照后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。   </p>
<p>队列(Queue)<br>队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列。   </p>
<p>链表( Linked List)<br>链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。   </p>
<p>树( Tree)<br>树是典型的非线性结构，它是包括，2个结点的有穷集合K。在树结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有聊个后继结点，m≥0。   </p>
<p>图(Graph)<br>图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。   </p>
<p>堆(Heap)<br>堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构。   </p>
<p>散列表(Hash)<br>散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。   </p>
<h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><p>数据结构研究的内容：就是如何按一定的逻辑结构，把数据组织起来，并选择适当的存储表示方法把逻辑结构组织好的数据存储到计算机的存储器里。研究的目的是为了更有效的处理数据，提高数据运算效率。数据的运算是定义在数据的逻辑结构上，但运算的具体实现要在存储结构上进行。一般有以下几种常用运算：<br>(1)检索。检索就是在数据结构里查找满足一定条件的节点。一般是给定一个某字段的值，找具有该字段值的节点。<br>(2)插入。往数据结构晕增加新的节点。<br>(3)删除。把指定的结点从数据结构中去掉。<br>(4)更新。改变指定节点的一个或多个字段的值。<br>(5)排序。把节点按某种指定的顺序重新排列。例如递增或递减。</p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhishui0501.github.io/活活气死的一个晚上.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="Keep Learning">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/活活气死的一个晚上.html" class="post-title-link" itemprop="url">活活气死的一个晚上</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-01 10:10:08 / Modified: 11:10:26" itemprop="dateCreated datePublished" datetime="2019-09-01T10:10:08+08:00">2019-09-01</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/HEXO/" itemprop="url" rel="index"><span itemprop="name">HEXO</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>本来今天高高兴兴，网站成功被谷歌收录了，别人可以搜到我了<br>结果一打开发现图片挂掉了<br><img src="images/%E6%B0%94%E6%AD%BB.PNG" alt><br>投一次见这么诡异的bug，图片地址莫名其妙多了html后缀，而且。。为啥只有htm<br>?????????????????????????????????????<br>百度谷歌都搜不出来的bug<br>我l被吃了?????????????????????????????????</p>
<h2 id="原本通过相对路径"><a href="#原本通过相对路径" class="headerlink" title="原本通过相对路径"></a>原本通过相对路径</h2><p>通过配置博客根目录下的_config.yml来生成。<br><code>post_asset_folder: true</code><br>在hexo的目录下执行<code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code><br>将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。_posts/post_name/image.jpg这张照片可以用以下方式访问：<br><code>![](image.jpg)</code></p>
<blockquote>
<p>本来没有问题，突然就挂掉了</p>
</blockquote>
<p>上述markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。</p>
<blockquote>
<p>都不能显示</p>
</blockquote>
<p>如果希望图片在文章和首页中同时显示，可以使用标签插件语法。_posts/post_name/image.jpg这张照片可以用以下方式访问：<br><code>{% asset_img image.jpg This is an image %}</code></p>
<blockquote>
<p>这里又出了新bug{}里的内容无法显示，转义也不行，应该是hexo解析问题，通过使用{% raw %}{% endraw %}解决</p>
</blockquote>
<blockquote>
<p>官网说：通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo3的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。</p>
<ol>
<li>但是使用{}这种方式也并没有解决我的问题</li>
<li>修改hexo—assert-images插件也没有任何作用，我都不觉得这东西有什么用</li>
<li>我甚至直接修改对应html文件，竟然都没用(改动github对应html倒是可以，但总不能部署一次改一次吧??)</li>
</ol>
</blockquote>
<h2 id="问题解决-绝对路径"><a href="#问题解决-绝对路径" class="headerlink" title="问题解决 绝对路径"></a>问题解决 绝对路径</h2><p>当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。对于source/images/image.jpg这张图片可以用以下语法访问到<br><code>![](/images/image.jpg)</code><br>图片既可以在首页内容中访问到，也可以在文章正文中访问到</p>
<blockquote>
<p>成功</p>
</blockquote>
<h2 id="CDN引用"><a href="#CDN引用" class="headerlink" title="CDN引用"></a>CDN引用</h2><p>除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。因国内访问github速度较慢，所以将突破放到国内图床上，然后引用外链是常用的方法。<br>常用图床总结：<a href="https://sspai.com/post/40499" rel="external nofollow noopener noreferrer" target="_blank">https://sspai.com/post/40499</a></p>
<p>图床，也就是专门提供存储图片的地方，我们只要通过图床提供的 API 接口，把图片上传上去，就可以通过外链访问了，根本不用操心图片是怎么存的，硬盘空间不够了，硬盘坏了，访问速度比较慢等等问题，这些图床都会帮我们搞定，他们会用各种技术帮我们做图片相关的优化和服务，比如多机互备、CDN 加速、图片处理、图片鉴黄、文本识别等等。</p>
<p>当然，图床也是有缺点的，当所有人都把图片存在同一个图床上，万一有一天图床真挂了，那所有图片就都无法访问了，虽然这种情况的概率很低，但并不等于不会发生</p>
<p>目前图床可以分为两种，一种是公共图床，一种是自建图床。公共图床也就是利用公共服务的图片上传接口，来提供图片外链的服务，比如新浪微博。自建图床，也就是利用各大云服务商提供的存储空间或者自己在 VPS 上使用开源软件来搭建图床，存储图片，生成外链提供访问，比如七牛、Lychee 开源自建图床方案。</p>
<p>微博图床（Chrome浏览器有个“新浪微博图床”插件，可以自动生成markdown链接）简单方便<br>七牛：测试域名30天，哭<br>腾讯云等云存储服务，需要先将照片放到云盘，然后找到超链接，然后粘贴到文章。太麻烦，放弃。<br>【强烈推荐！！！】ipic 工具，具体用法请谷歌，支持监控剪贴板，一键上传到微博图床，免费版默认是微博图床，支持七牛云等，下载地址: <a href="https://itunes.apple.com/cn/app/id1101244278?mt=12" rel="external nofollow noopener noreferrer" target="_blank">https://itunes.apple.com/cn/app/id1101244278?mt=12</a></p>
<h2 id="使用GitHub"><a href="#使用GitHub" class="headerlink" title="使用GitHub"></a>使用GitHub</h2><p>使用github存储博客图片</p>
<ol>
<li>创建一个空的repo</li>
<li>然后将图片push到repo中</li>
<li>点击图片进去，有个download，右键复制链接</li>
<li>将链接插入文章<br><code>![logo](https://github.com/xxxx/xx.jpg)</code></li>
</ol>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" src="/images/touxiang.jpg" alt="Aaron">
  <p class="site-author-name" itemprop="name">Aaron</p>
  <div class="site-description motion-element" itemprop="description">Keep Learning</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/zhishui0501" title="GitHub &rarr; https://github.com/zhishui0501" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:876944049@qq.com" title="E-Mail &rarr; mailto:876944049@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Aaron</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="external nofollow noopener noreferrer" target="_blank">NexT.Gemini</a> v7.3.0</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="Total Visitors">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="Total Views">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>


  <script src="/js/affix.js?v=7.3.0"></script>
  <script src="/js/schemes/pisces.js?v=7.3.0"></script>



<script src="/js/next-boot.js?v=7.3.0"></script>




  




























  

  

  


  
</body>
</html>
