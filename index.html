<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="en">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="google-site-verification" content="I0jUNsp40jMLLvChVvaEUlXNcTs1cSJSG4ktU1HF5-M">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">
  <meta name="google-site-verification" content="true">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta name="description" content="Keep Learning">
<meta property="og:type" content="website">
<meta property="og:title" content="Aaron&#39;s blog">
<meta property="og:url" content="https://zhishui0501.github.io/index.html">
<meta property="og:site_name" content="Aaron&#39;s blog">
<meta property="og:description" content="Keep Learning">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Aaron&#39;s blog">
<meta name="twitter:description" content="Keep Learning">
  <link rel="canonical" href="https://zhishui0501.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Aaron's blog</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  <div class="container sidebar-position-left">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Aaron's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories<span class="badge">12</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives<span class="badge">25</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content page-home">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhishui0501.github.io/TCP-and-UDP.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="Keep Learning">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/TCP-and-UDP.html" class="post-title-link" itemprop="url">TCP and UDP</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-08 09:34:26 / Modified: 11:20:35" itemprop="dateCreated datePublished" datetime="2019-09-08T09:34:26+08:00">2019-09-08</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机网络/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP（User Data Protocol，用户数据报协议）它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去。<br>UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。比如，我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。例如，在默认状态下，一次“ping”操作发送4个数据包。发送的数据包数量是4包，收到的也是4包（因为对方主机收到后会发回一个确认收到的数据包）。这充分说明了UDP协议是面向非连接的协议，没有建立连接的过程。正因为UDP协议没有连接的过程，所以它的通信效果高；但也正因为如此，它的可靠性不如TCP协议高。QQ就使用UDP发消息，因此有时会出现收不到消息的情况。</p>
<p>我们来看一下 UDP 的包头<br><img src="images/1909081.PNG" alt><br>由上图可以看出，UDP 除了端口号，基本啥都没有了。如果没有这两个端口号，数据就不知道该发给哪个应用。<br>所以 UDP 特别简单，有如下三个特点</p>
<ol>
<li>沟通简单，不需要大量的数据结构，处理逻辑和包头字段</li>
<li>轻信他人。它不会建立连接，但是会监听这个地方，谁都可以传给它数据，它也可以传给任何人数据，甚至可以同时传给多个人数据。</li>
<li>愣头青，做事不懂变通。不会根据网络的情况进行拥塞控制，无论是否丢包，它该怎么发还是怎么发</li>
</ol>
<p>因为 UDP 是”小孩子”，所以处理的是一些没那么难的项目，并且就算失败的也能接收。基于这些特点的话，UDP 可以使用在如下场景中</p>
<ol>
<li>需要资源少，网络情况稳定的内网，或者对于丢包不敏感的应用，比如 DHCP 就是基于 UDP 协议的。</li>
<li>不需要一对一沟通，建立连接，而是可以广播的应用。因为它不面向连接，所以可以做到一对多，承担广播或者多播的协议。</li>
<li>需要处理速度快，可以容忍丢包，但是即使网络拥塞，也毫不退缩，一往无前的时候</li>
</ol>
<h3 id="UDP-的几个例子"><a href="#UDP-的几个例子" class="headerlink" title="UDP 的几个例子"></a>UDP 的几个例子</h3><ol>
<li>直播。直播对实时性的要求比较高，宁可丢包，也不要卡顿的，所以很多直播应用都基于 UDP 实现了自己的视频传输协议</li>
<li>实时游戏。游戏的特点也是实时性比较高，在这种情况下，采用自定义的可靠的 UDP 协议，自定义重传策略，能够把产生的延迟降到最低，减少网络问题对游戏造成的影响</li>
<li>物联网。一方面，物联网领域中断资源少，很可能只是个很小的嵌入式系统，而维护 TCP 协议的代价太大了；另一方面，物联网对实时性的要求也特别高。比如 Google 旗下的 Nest 简历 Thread Group，推出了物联网通信协议 Thread，就是基于 UDP 协议的</li>
</ol>
<h3 id="UDP的优点"><a href="#UDP的优点" class="headerlink" title="UDP的优点"></a>UDP的优点</h3><p>快，比TCP稍安全<br>    UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，udp是一个无状态的传输协议，所以他在传输数据时非常快。M没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。UDP也是无法避免攻击的，比如：UDP flood攻击。。。</p>
<h3 id="UDP的缺点"><a href="#UDP的缺点" class="headerlink" title="UDP的缺点"></a>UDP的缺点</h3><p>不可靠，不稳定<br>    因为UDP没有TCP的那些可靠机制，在网络质量不好时很容易丢包。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP（Transmission Control Protocol，传输控制协议）<br>首先是 TCP 的包头格式<br><img src="images/1909082.PNG" alt></p>
<ol>
<li>首先，源端口和目标端口是不可少的。</li>
<li>接下来是包的序号。主要是为了解决乱序问题。不编好号怎么知道哪个先来，哪个后到</li>
<li>确认序号。发出去的包应该有确认，这样能知道对方是否收到，如果没收到就应该重新发送，这个解决的是不丢包的问题</li>
<li>状态位。SYN 是发起一个链接，ACK 是回复，RST 是重新连接，FIN 是结束连接。因为 TCP 是面向连接的，因此需要双方维护连接的状态，这些状态位的包会引起双方的状态变更<br>窗口大小，TCP 要做流量控制，需要通信双方各声明一个窗口，标识自己当前的处理能力。</li>
</ol>
<p>通过对 TCP 头的解析，我们知道要掌握 TCP 协议，应该重点关注以下问题：</p>
<ul>
<li>顺序问题</li>
<li>丢包问题</li>
<li>连接维护</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
<h3 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h3><p>所有的问题，首先都要建立连接，所以首先是连接维护的问题</p>
<p>TCP 的建立连接称为三次握手，可以简单理解为下面这种情况</p>
<blockquote>
<p>A：您好，我是 A<br>    B：您好 A，我是 B<br>    A：您好 B</p>
</blockquote>
<p>对于 A 来说它发出请求，并收到了 B 的响应，对于 B 来说它响应了 A 的请求，并且也接收到了响应。</p>
<blockquote>
<p>TCP 的三次握手除了建立连接外，主要还是为了沟通 TCP 包的序号问题。</p>
</blockquote>
<p>A 告诉 B，我发起的包的序号是从哪个号开始的，B 同样也告诉 A，B 发起的 包的序号是从哪个号开始的。<br>双方建立连接之后需要共同维护一个状态机，在建立连接的过程中，双方的状态变化时序图如下所示<br><img src="images/1909083.PNG" alt><br>这是网上经常见到的一张图，刚开始的时候，客户端和服务器都处于 CLOSED 状态，先是服务端主动监听某个端口，处于 LISTEN 状态。然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态。服务端接收了发起的连接，返回 SYN，并且 ACK ( 确认 ) 客户端的 SYN，之后处于 SYN-SENT 状态。客户端接收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后就处于 ESTAVLISHED 状态，因为它一发一收成功了。服务端收到 ACK 的 ACK 之后，也处于 ESTABLISHED 状态，因为它也一发一收了。</p>
<h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><p>说完建立连接，再说下断开连接，也被称为四次挥手，可以简单理解如下</p>
<blockquote>
<p>A：B 啊，我不想玩了<br>    B：哦，你不想玩了啊，我知道了<br>    这个时候，只是 A 不想玩了，即不再发送数据，但是 B 可能还有未发送完的数据，所以需要等待 B 也主动关闭。<br>    B：A 啊，好吧，我也不玩了，拜拜<br>    A：好的，拜拜</p>
</blockquote>
<p>这样整个连接就关闭了，当然上面只是正常的状态，也有些非正常的状态（比如 A 说完不玩了，直接跑路，B 发起的结束得不到 A 的回答，不知道该怎么办或则 B 直接跑路 A 不知道该怎么办），TCP 协议专门设计了几个状态来处理这些非正常状态<br><img src="images/1909084.PNG" alt><br>断开的时候，当 A 说不玩了，就进入 FIN_WAIT_1 的状态，B 收到 A 不玩了的消息后，进入 CLOSE_WAIT 的状态。</p>
<p>A 收到 B 说知道了，就进入 FIN_WAIT_2 的状态，如果 B 直接跑路，则 A 永远处与这个状态。TCP 协议里面并没有对这个状态的处理，但 Linux 有，可以调整 tcp_fin_timeout 这个参数，设置一个超时时间。</p>
<p>如果 B 没有跑路，A 接收到 B 的不玩了请求之后，从 FIN_WAIT_2 状态结束，按说 A 可以跑路了，但是如果 B 没有接收到 A 跑路的 ACK 呢，就再也接收不到了，所以这时候 A 需要等待一段时间，因为如果 B 没接收到 A 的 ACK 的话会重新发送给 A，所以 A 的等待时间需要足够长。</p>
<h3 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h3><blockquote>
<p>TCP 如何实现可靠传输?<br>首先为了保证顺序性，每个包都有一个 ID。在建立连接的时候会商定起始 ID 是什么，然后按照 ID 一个个发送，为了保证不丢包，需要对发送的包都要进行应答，当然，这个应答不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这种模式成为累计应答或累计确认。</p>
</blockquote>
<p>为了记录所有发送的包和接收的包，TCP 需要发送端和接收端分别来缓存这些记录，发送端的缓存里是按照包的 ID 一个个排列，根据处理的情况分成四个部分</p>
<ul>
<li>发送并且确认的</li>
<li>发送尚未确认的</li>
<li>没有发送等待发送的</li>
<li>没有发送并且暂时不会发送的</li>
</ul>
<p>这里的第三部分和第四部分就属于流量控制的内容</p>
<p>在 TCP 里，接收端会给发送端报一个窗口大小，叫 Advertised window。这个窗口应该等于上面的第二部分加上第三部分，超过这个窗口，接收端做不过来，就不能发送了</p>
<p>于是，发送端要保持下面的数据结构<br><img src="images/1909085.PNG" alt></p>
<p>对于接收端来讲，它的缓存里面的内容要简单一些</p>
<ul>
<li>接收并且确认过的</li>
<li>还没接收，但是马上就能接收的</li>
<li>还没接收，但也无法接收的<br>对应的数据结构如下<br><img src="images/1909086.PNG" alt></li>
</ul>
<h3 id="顺序问题和丢包问题"><a href="#顺序问题和丢包问题" class="headerlink" title="顺序问题和丢包问题"></a>顺序问题和丢包问题</h3><p>结合上面的图看，在发送端，1、2、3 已发送并确认；4、5、6、7、8、9 都是发送了还没确认；10、11、12 是还没发出的；13、14、15 是接收方没有空间，不准备发的。</p>
<p>在接收端来看，1、2、3、4、5 是已经完成 ACK 但是还没读取的；6、7 是等待接收的；8、9 是已经接收还没有 ACK 的。<br>发送端和接收端当前的状态如下：</p>
<ul>
<li>1、2、3 没有问题，双方达成了一致</li>
<li>4、5 接收方说 ACK 了，但是发送方还没收到</li>
<li>6、7、8、9 肯定都发了，但是 8、9 已经到了，6、7 没到，出现了乱序，缓存着但是没办法 ACK。<br>根据这个例子可以知道顺序问题和丢包问题都有可能存在，所以我们先来看确认与重传机制。</li>
</ul>
<p>假设 4 的确认收到了，5 的 ACK 丢了，6、7 的数据包丢了，该怎么办？</p>
<p>一种方法是超时重试，即对每一个发送了但是没有 ACK 的包设定一个定时器，超过了一定的事件就重新尝试。这个时间必须大于往返时间，但也不宜过长，否则超时时间变长，访问就变慢了。</p>
<p>如果过一段时间，5、6、7 都超时了就会重新发送。接收方发现 5 原来接收过，于是丢弃 5；6 收到了，发送 ACK，要求下一个是 7，7 不幸又丢了。当 7 再次超时的时候，TCP 的策略是超时间隔加倍。每当遇到一次超时重传的时候，都会讲下一次超时时间间隔设为先前值的两倍。</p>
<p>超时重传的机制是超时周期可能相对较长，是否有更快的方式呢？</p>
<p>有一个快速重传的机制，即当接收方接收到一个序号大于期望的报文段时，就检测到了数据流之间的间隔，于是发送三个冗余的 ACK，客户端接收到之后，知道数据报丢失，于是重传丢失的报文段。</p>
<p>例如，接收方发现 6、8、9 都接收了，但是 7 没来，所以肯定丢了，于是发送三个 6 的 ACK，要求下一个是 7。客户端接收到 3 个，就会发现 7 的确又丢了，不等超时，马上重发。</p>
<h3 id="流量控制的问题"><a href="#流量控制的问题" class="headerlink" title="流量控制的问题"></a>流量控制的问题</h3><p>在流量控制的机制里面，在对于包的确认中，会携带一个窗口的大小</p>
<p>简单的说一下就是接收端在发送 ACK 的时候会带上缓冲区的窗口大小，但是一般在窗口达到一定大小才会更新窗口，因为每次都更新的话，刚空下来就又被填满了</p>
<h3 id="拥塞控制的问题"><a href="#拥塞控制的问题" class="headerlink" title="拥塞控制的问题"></a>拥塞控制的问题</h3><p>也是通过窗口的大小来控制的，但是检测网络满不满是个挺难的事情，所以 TCP 发送包经常被比喻成往水管里灌水，所以拥塞控制就是在不堵塞，不丢包的情况下尽可能的发挥带宽。</p>
<p>水管有粗细，网络有带宽，即每秒钟能发送多少数据；水管有长度，端到端有时延。理想状态下，水管里面的水 = 水管粗细 * 水管长度。对于网络上，通道的容量 = 带宽 * 往返时延。</p>
<p>如果我们设置发送窗口，使得发送但未确认的包为通道的容量，就能撑满整个管道。<br><img src="images/1909087.PNG" alt><br>如图所示，假设往返时间为 8 秒，去 4 秒，回 4 秒，每秒发送一个包，已经过去了 8 秒，则 8 个包都发出去了，其中前四个已经到达接收端，但是 ACK 还没返回，不能算发送成功，5-8 后四个包还在路上，还没被接收，这个时候，管道正好撑满，在发送端，已发送未确认的 8 个包，正好等于带宽，也即每秒发送一个包，也即每秒发送一个包，乘以来回时间 8 秒。</p>
<p>如果在这个基础上调大窗口，使得单位时间可以发送更多的包，那么会出现接收端处理不过来，多出来的包会被丢弃，这个时候，我们可以增加一个缓存，但是缓存里面的包 4 秒内肯定达不到接收端课，它的缺点会增加时延，如果时延达到一定程度就会超时重传</p>
<p>TCP 拥塞控制主要来避免两种现象，包丢失和超时重传，一旦出现了这些现象说明发送的太快了，要慢一点。</p>
<p>具体的方法就是发送端慢启动，比如倒水，刚开始倒的很慢，渐渐变快。然后设置一个阈值，当超过这个值的时候就要慢下来</p>
<p>慢下来还是在增长，这时候就可能水满则溢，出现拥塞，需要降低倒水的速度，等水慢慢渗下去。</p>
<p>拥塞的一种表现是丢包，需要超时重传，这个时候，采用快速重传算法，将当前速度变为一半。所以速度还是在比较高的值，也没有一夜回到解放前。</p>
<h3 id="Tcp的优点"><a href="#Tcp的优点" class="headerlink" title="Tcp的优点"></a>Tcp的优点</h3><p>可靠，稳定<br>    TCP的可靠性体现在传输数据之前，三次握手建立连接（四次挥手释放连接），并且在数据传递时，有确认、窗口、重传、拥塞控制机制，数据传完之后，断开连接用来节省系统资源。</p>
<h3 id="TCP的缺点"><a href="#TCP的缺点" class="headerlink" title="TCP的缺点"></a>TCP的缺点</h3><p>慢，效率低，占用系统资源高，易被攻击<br>    传数据之前建立连接，这样会消耗时间，而且在消息传递时，确认机制、重传机制和拥塞控制机制都会消耗大量的时间，而且要在每台设备上维护所有的传输连接。而每个连接都会占用系统的CPU、内存等硬件软件资源。并且TCP的取而机制、三次握手，这些也导致TCP容易被人利用，实现DOS，DDOS攻击。</p>
<h2 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2><p>UDP 是一种面向无连接，且不可靠的协议，在通信过程中，它并不像 TCP 那样需要先建立一个连接，只要（目的地址，端口号，源地址，端口号）确定了，就可以直接发送信息报文，并且不需要确保服务端一定能收到或收到完整的数据。它仅仅提供了校验和机制来保障一个报文是否完整，若校验失败，则直接丢弃报文，不做任何处理。</p>
<p>TCP和UDP都是传输层协议，但是两者具有不同的特性和应用场景</p>
<ol>
<li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。</li>
<li>UDP程序结构较简单</li>
<li>TCP 是面向字节流的，UDP 是基于数据报的</li>
<li>TCP 保证数据正确性，UDP 可能丢包</li>
<li>TCP 保证数据顺序，UDP 不保证</li>
<li>TCP要求系统资源较多，UDP较少。</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。</li>
<li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。</li>
<li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。</li>
<li>TCP首部开销20字节;UDP的首部开销小，只有8个字节。</li>
<li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。<br><img src="images/1909088.PNG" alt></li>
</ol>
<p><strong>名词解释</strong><br><strong>面向报文和面向字节流</strong><br>面向报文的传输方式是应用层交给UDP多长的报文，UDP就发送多长的报文，即一次发送一个报文。因此应用程序必须选择大小合适的报文。报文太长，则IP层需要分片，降低效率。</p>
<p>面向字节流的传输方式是应用程序和TCP的交互是一次一个数据块（大小不等），TCP把这些数据块看成是一连串无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就会把它分割成多块传送。<br><strong>双工性</strong><br>全双工：是指在发送数据的同时也能够接收数据，两者同步进行，这好像我们平时打电话一样，说话的同时也能够听到对方的声音。目前的网卡一般都支持全双工。</p>
<p>半双工：所谓半双工就是指一个时间段内只有一个动作发生，举个简单例子，一条窄窄的马路，同时只能有一辆车通过，当目前有两量车对开，这种情况下就只能一辆先过，等到头儿后另一辆再开，这个例子就形象的说明了半双工的原理。</p>
<h2 id="TCP-UDP编程模型"><a href="#TCP-UDP编程模型" class="headerlink" title="TCP/UDP编程模型"></a>TCP/UDP编程模型</h2><p>从程序实现的角度来看，可以用下图来进行描述。<br><img src="images/1909089.PNG" alt><br>从上图也能清晰的看出，TCP通信需要服务器端侦听listen、接收客户端连接请求accept，等待客户端connect建立连接后才能进行数据包的收发（recv/send）工作。而UDP则服务器和客户端的概念不明显，服务器端即接收端需要绑定端口，等待客户端的数据的到来。后续便可以进行数据的收发（recvfrom/sendto）工作。</p>
<p>前面提到了UDP保留了报文的边界，下面我们来谈谈TCP和UDP中报文的边界问题。在默认的阻塞模式下，TCP无边界，UDP有边界。</p>
<p>对于TCP协议，客户端连续发送数据，只要服务端的这个函数的缓冲区足够大，会一次性接收过来，即客户端是分好几次发过来，是有边界的，而服务端却一次性接收过来，所以证明是无边界的；</p>
<p>而对于UDP协议，客户端连续发送数据，即使服务端的这个函数的缓冲区足够大，也只会一次一次的接收，发送多少次接收多少次，即客户端分几次发送过来，服务端就必须按几次接收，从而证明，这种UDP的通讯模式是有边界的。</p>
<h2 id="TCP-与-UDP-的应用场景"><a href="#TCP-与-UDP-的应用场景" class="headerlink" title="TCP 与 UDP 的应用场景"></a>TCP 与 UDP 的应用场景</h2><p><img src="images/19090810.jpg" alt><br><img src="images/19090811.jpg" alt><br>从特点上我们已经知道，TCP 是可靠的但传输速度慢 ，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。</p>
<p>若通信数据完整性需让位与通信实时性，则应该选用 TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。</p>
<h3 id="什么时候应该使用TCP"><a href="#什么时候应该使用TCP" class="headerlink" title="什么时候应该使用TCP"></a>什么时候应该使用TCP</h3><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。</p>
<p>在日常生活中，常见使用TCP协议的应用如下：</p>
<ul>
<li>浏览器，用的HTTP</li>
<li>FlashFXP，用的FTP</li>
<li>Outlook，用的POP、SMTP</li>
<li>Putty，用的Telnet、SSH</li>
<li>QQ文件传输</li>
</ul>
<h3 id="什么时候应该使用UDP"><a href="#什么时候应该使用UDP" class="headerlink" title="什么时候应该使用UDP"></a>什么时候应该使用UDP</h3><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。<br>比如，日常生活中，常见使用UDP协议的应用如下：</p>
<ul>
<li>QQ语音</li>
<li>QQ视频</li>
<li>TFTP</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="什么是面向连接，什么是面向无连接"><a href="#什么是面向连接，什么是面向无连接" class="headerlink" title="什么是面向连接，什么是面向无连接"></a>什么是面向连接，什么是面向无连接</h3><p>在互通之前，面向连接的协议会先建立连接，如 TCP 有三次握手，而 UDP 不会</p>
<h3 id="TCP-为什么是可靠连接"><a href="#TCP-为什么是可靠连接" class="headerlink" title="TCP 为什么是可靠连接"></a>TCP 为什么是可靠连接</h3><ul>
<li>通过 TCP 连接传输的数据无差错，不丢失，不重复，且按顺序到达。</li>
<li>TCP 报文头里面的序号能使 TCP 的数据按序到达</li>
<li>报文头里面的确认序号能保证不丢包，累计确认及超时重传机制</li>
<li>TCP 拥有流量控制及拥塞控制的机制<br>TCP 的顺序问题，丢包问题，流量控制都是通过滑动窗口来解决的<br>拥塞控制时通过拥塞窗口来解决的</li>
</ul>
<p>两种协议都是传输层协议，为应用层提供信息载体。TCP协议是基于连接的可靠协议，有流量控制和差错控制，也正因为有可靠性的保证和控制手段，所以传输效率比UDP低；UDP协议是基于无连接的不可靠协议，没有控制手段，仅仅是将数据发送给对方，因此效率比TCP要高。</p>
<p>基于上述特性，不难得到结论，TCP协议适用于对效率要求相对低，但对准确性要求相对高的场景下，或者是有一种连接概念的场景下；而UDP协议适用于对效率要求相对高，对准确性要求相对低的场景。</p>
<p>几个应用的例子。TCP一般用于文件传输（FTP HTTP 对数据准确性要求高，速度可以相对慢），发送或接收邮件（POP IMAP SMTP 对数据准确性要求高，非紧急应用），远程登录（TELNET SSH 对数据准确性有一定要求，有连接的概念）等等；UDP一般用于即时通信（QQ聊天 对数据准确性和丢包要求比较低，但速度必须快），在线视频（RTSP 速度一定要快，保证视频连续，但是偶尔花了一个图像帧，人们还是能接受的），网络语音电话（VoIP 语音数据包一般比较小，需要高速发送，偶尔断音或串音也没有问题）等等。<br>一些其他应用。比如，TCP可以用于网络数据库，分布式高精度计算系统的数据传输；UDP可以用于服务系统内部之间的数据传输，因为数据可能比较多，内部系统局域网内的丢包错包率又很低，即便丢包，顶多是操作无效，这种情况下，UDP经常被使用。</p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhishui0501.github.io/CDN.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="Keep Learning">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/CDN.html" class="post-title-link" itemprop="url">CDN</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-07 22:59:05 / Modified: 23:11:31" itemprop="dateCreated datePublished" datetime="2019-09-07T22:59:05+08:00">2019-09-07</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机网络/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CDN(Content Delivery Network)是指内容分发网络，也称为内容传送网络，这个概念始于1996年，是美国麻省理工学院的一个研究小组为改善互联网的服务质量而提出的。为了能在传统IP网上发布丰富的宽带媒体内容，他们提出在现有互联网基础上建立一个内容分发平台专门为网站提供服务，并于1999年成立了专门的CDN服务公司，为Yahoo提供专业服务。由于CDN是为加快网络访问速度而被优化的网络覆盖层，因此被形象地称为“网络加速器”。 </p>
<p>CDN网络的诞生大大地改善了互联网的服务质量，因此传统的大型网络运营商纷纷开始建设自己的CDN网络，如AT&amp;T、德国电信、中国电信等。随着市场需求的不断增加，甚至出现了纯粹的CDN网络运营商，美国的Akamai就是其中最大的一个，拥有分布在世界各地的1000多个节点。我国第一家纯粹的CDN网络服务公司是北京蓝汛公司，已从2000年开始建立了一个专门的CDN服务网络一ChinaCache。目前CDN网络已经突破50个节点，覆盖中国六大骨干网络一中国电信、中国网通、中国移动、中国联通、中国铁通网络以及中国教育网，带宽资源储备超过35G，服务的客户数量达到300多家。</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>CDN网络中包含的功能实体包括内容缓存设备、内容交换机、内容路由器、CDN内容管理系统等组成。<br>内容缓存为CDN网络节点，位于用户接入点，是面向最终用户的内容提供设备，可缓存静态Web内容和流媒体内容，实现内容的边缘传播和存储，以便用户的就近访问。<br>内容交换机处于用户接入集中点，可以均衡单点多个内容缓存设备的负载，并对内容进行缓存负载平衡及访问控制。<br>内容路由器负责将用户的请求调度到适当的设备上。内容路由通常通过负载均衡系统来实现，动态均衡各个内容缓存站点的载荷分配，为用户的请求选择最佳的访问站点，同时提高网站的可用性。内容路由器可根据多种因素制定路由，包括站点与用户的临近度、内容的可用性、网络负载、设备状况等。负载均衡系统是整个CDN的核心。负载均衡的准确性和效率直接决定了整个CDN的效率和性能。<br>内容管理系统负责整个CDN的管理，是可选部件，作用是进行内容管理，如内容的注入和发布、内容的分发、内容的审核、内容的服务等。</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol>
<li>节省骨干网带宽，减少带宽需求量；</li>
<li>提供服务器端加速，解决由于用户访问量大造成的服务器过载问题</li>
<li>服务商能使用Web Cache技术在本地缓存用户访问过的Web页面和对象，实现相同对象的访问无须占用主干的出口带宽，并提高用户访问因特网页面的相应时间的需求；</li>
<li>能克服网站分布不均的问题，并且能降低网站自身建设和维护成本；</li>
<li>降低“通信风暴”的影响，提高网络访问的稳定性。</li>
</ol>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</p>
<p>CDN的基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</p>
<h2 id="服务模式"><a href="#服务模式" class="headerlink" title="服务模式"></a>服务模式</h2><p>内容分发网络（CDN）是一种新型网络构建方式，它是为能在传统的IP网发布宽带丰富媒体而特别优化的网络覆盖层；而从广义的角度，CDN代表了一种基于质量与秩序的网络服务模式。<br>简单地说，内容分发网络（CDN）是一个经策略性部署的整体系统，包括分布式存储、负载均衡、网络请求的重定向和内容管理4个要件，而内容管理和全局的网络流量管理（Traffic Management）是CDN的核心所在。通过用户就近性和服务器负载的判断，CDN确保内容以一种极为高效的方式为用户的请求提供服务。<br>总的来说，内容服务基于缓存服务器，也称作代理缓存（Surrogate），它位于网络的边缘，距用户仅有”一跳”（Single Hop）之遥。同时，代理缓存是内容提供商源服务器（通常位于CDN服务提供商的数据中心）的一个透明镜像。这样的架构使得CDN服务提供商能够代表他们客户，即内容供应商，向最终用户提供尽可能好的体验，而这些用户是不能容忍请求响应时间有任何延迟的。   </p>
<h2 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h2><ol>
<li>本地Cache加速：提高了企业站点（尤其含有大量图片和静态页面站点）的访问速度，并大大提高以上性质站点的稳定性。    </li>
<li>镜像服务：消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。    </li>
<li>远程加速：远程访问用户根据DNS负载均衡技术智能自动选择Cache服务器，选择最快的Cache服务器，加快远程访问的速度。    </li>
<li>带宽优化：自动生成服务器的远程Mirror（镜像）cache服务器，远程用户访问时从cache服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点WEB服务器负载等功能。    </li>
<li>集群抗攻击：广泛分布的CDN节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种D.D.o.S攻击对网站的影响，同时保证较好的服务质量 。</li>
</ol>
<h2 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h2><h3 id="内容发布"><a href="#内容发布" class="headerlink" title="内容发布"></a>内容发布</h3><p>它借助于建立索引、缓存、流分裂、组播（Multicast）等技术，将内容发布或投递到距离用户最近的远程服务点（POP）处。<br>内容分发包含从内容源到CDN边缘的Cache的过程。从实现上，有两种主流的内容分发技术：PUSH和PULL。<br>PUSH是一种主动分发的技术。通常，PUSH由内容管理系统发起，将内容从源或者中心媒体资源库分发到各边缘的 Cache节点。分发的协议可以采用 Http/ftp等。通过PUSH分发的内容一般是比较热点的内容，这些内容通过PUSH方式预分发（ Preload）到边缘Cache，可以实现有针对的内容提供。对于PUSH分发需要考虑的主要问题是分发策略，即在什么时候分发什么内容。一般来说，内容分发可以由CP（内容提供商）或者CDN内容管理员人工确定，也可以通过智能的方式决定，即所谓的智能分发，它根据用户访问的统计信息，以及预定义的内容分发的规则，确定内容分发的过程PULL是一种被动的分发技术，PULL分发通常由用户请求驱动。当用户请求的内容在本地的边缘 Cache上不存在（未命中）时， Cache启动PUL方法从内容源或者其他CDN节点实时获取内容。在PULL方式下，内容的分发是按需的。</p>
<h3 id="内容路由"><a href="#内容路由" class="headerlink" title="内容路由"></a>内容路由</h3><p>它是整体性的网络负载均衡技术，通过内容路由器中的重定向（DNS）机制，在多个远程POP上均衡用户的请求，以使用户请求得到最近内容源的响应。</p>
<p>CDN负载均衡系统实现CDN的内容路由功能。它的作用是将用户的请求导向整个CDN网络中的最佳节点。最佳节点的选定可以根据多种策略，例如距离最近、节点负载最轻等。负载均衡系统是整个CDN的核心，负载均衡的准确性和效率直接决定了整个CDN的效率和性能。通常负载均衡可以分为两个层次:全局负载均衡（GSLB）和本地负载均衡（SLB）。全局负载均衡主要的目的是在整个网络范围内将用户的请求定向到最近的节点（或者区域）。因此，就近性判断是全局负载均衡的主要功能。本地负载均衡一般局限于一定的区域范围内，其目标是在特定的区域范围内寻找一台最适合的节点提供服务，因此，CDN节点的健康性、负载情况、支持的媒体格式等运行状态是本地负载均衡进行决策的主要依据。</p>
<h3 id="内容存储"><a href="#内容存储" class="headerlink" title="内容存储"></a>内容存储</h3><p>对于CDN系统而言，需要考虑两个方面的内容存储问题。一个是内容源的存储，一个是内容在 Cache节点中的存储。<br>对于内容源的存储，由于内容的规模比较大（通常可以达到几个甚至几十个TB），而且内容的吞吐量较大，因此，通常采用海量存储架构，如NAS和SON。对于在 Cache节点中的存储，是 Cache设计的一个关键问题。需要考虑的因素包括功能和性能两个方面:功能上包括对各种内容格式的支持，对部分缓存的支持;在性能上包括支持的容量、多文件吞吐率、可靠性、稳定性。<br>其中，多种内容格式的支持要求存储系统根据不同文件格式的读写特点进行优化，以提高文件内容读写的效率。特别是对针对流媒体文件的读写。部分缓存能力指流媒体内容可以以不完整的方式存储和读取。部分缓存的需求来自用户访问行为的随机性，因为许多用户并不会完整地收看整个流媒体节目。事实上，许多用户访问单个流媒体节目的时间不超过10分钟。因此，部分缓存能力能够大大提高存储空间的利用率，并有效提高用户请求的响应时间。但是部分缓存可能导致内容的碎片问题，需要进行良好的设计和控制。<br>Cache存储的另一个重要因素是存储的可靠性，目前，多数存储系统都采用了独立磁盘冗余阵列（RAID）技术进行可靠存储。但是不同设备使用的RAID方式各有不同。</p>
<h3 id="内容管理"><a href="#内容管理" class="headerlink" title="内容管理"></a>内容管理</h3><p>它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能（如包丢失、延时、平均带宽、启动时间、帧速率等），保证网络处于最佳的运行状态。<br>内容管理在广义上涵盖了从内容的发布、注入、分发、调整、传递等一系列过程。在这里，内容管理重点强调内容进人 Cache点后的内容管理，称其为本地内容管理。本地内容管理主要针对一个ODN节点（有多个 CDN Cache设备和一个SLB设备构成）进行。本地内容管理的主要目标是提高内容服务的效率，提高本地节点的存储利用率。通过本地内容管理，可以在CDN节点实现基于内容感知的调度，通过内容感知的调度，可以避免将用户重定向到没有该内容的 Cache设备上，从而提高负载均衡的效率。通过本地内容管理还可以有效实现在ODN节点内容的存储共享，提高存储空间的利用率。</p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhishui0501.github.io/abstract抽象类和interface接口有什么区别.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="Keep Learning">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/abstract抽象类和interface接口有什么区别.html" class="post-title-link" itemprop="url">abstract class抽象类和interface接口有什么区别</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-04 15:58:53 / Modified: 18:24:57" itemprop="dateCreated datePublished" datetime="2019-09-04T15:58:53+08:00">2019-09-04</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>含有 abstract 修饰符 class 即为抽象类，抽象类不能创建实际对象，含有抽象方法的抽象类必须定义为 abstract class。</p>
<p>接口可以说成是一种特殊的抽象类，接口中的所有方法都必须是抽象的，接口中的方法定义默认为 public abstract 类型，接口中的成员产量类型默认为 public static final。<br>两者的区别:</p>
<ol>
<li><p>抽象类可以有构造方法，接口中不能有构造方法。</p>
</li>
<li><p>抽象类中可以有普通成员变量，接口中没有普通成员变量。</p>
</li>
<li><p>抽象类中可以包含非抽象普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的方法。</p>
</li>
<li><p>抽象类中的抽象方法的访问权限可以是 public、protected 和(默认类型，虽然 eclipse 不报错，但也不能用，默认类型子类不能继承)，接口中的抽象方法只能是 public 类型的，并且默认即为 public abstract 类型。</p>
</li>
<li><p>抽象类中可以包含静态方法，在 JDK1.8 之前接口中不能不包含静态方法，JDK1.8 以后可以包含。</p>
</li>
<li><p>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问权限可以是任意的，但接口中定义的变量只能是 public static final 类型的，并且默认即为 public static final 类型。</p>
</li>
<li><p>一个类可以实现多个接口，用逗号隔开，但只能继承一个抽象类，接口不可以实现接口，但可以继承接口，并且可以继承多个接口，用逗号隔开。</p>
</li>
</ol>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhishui0501.github.io/Java中ArrayList与LinkedList的区别.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="Keep Learning">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/Java中ArrayList与LinkedList的区别.html" class="post-title-link" itemprop="url">Java中ArrayList与LinkedList的区别</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-03 22:33:02 / Modified: 22:52:10" itemprop="dateCreated datePublished" datetime="2019-09-03T22:33:02+08:00">2019-09-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol>
<li><p>ArrayList的实现是基于数组，LinkedList的实现是基于双向链表。 </p>
</li>
<li><p>对于随机访问，ArrayList优于LinkedList</p>
</li>
<li><p>对于插入和删除操作，LinkedList优于ArrayList</p>
</li>
<li><p>LinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</p>
<h2 id="在时间复杂度上的区别"><a href="#在时间复杂度上的区别" class="headerlink" title="在时间复杂度上的区别"></a>在时间复杂度上的区别</h2><p>假设我们有两个很大的列表，它们里面的元素已经排好序了，这两个列表分别是ArrayList类型和LinkedList类型的，现在我们对这两个列表来进行二分查找(binary search)，比较它们的查找速度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> 1 package com.demo;</span><br><span class="line"> 2 </span><br><span class="line"> 3 import java.util.ArrayList;</span><br><span class="line"> 4 import java.util.Collections;</span><br><span class="line"> 5 import java.util.LinkedList;</span><br><span class="line"> 6 import java.util.List;</span><br><span class="line"> 7 </span><br><span class="line"> 8 public class Demo1 &#123;</span><br><span class="line"> 9     static List&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;();</span><br><span class="line">10     static List&lt;Integer&gt; linked = new LinkedList&lt;Integer&gt;();</span><br><span class="line">11 </span><br><span class="line">12     public static void main(String[] args) &#123;</span><br><span class="line">13 </span><br><span class="line">14         for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">15             array.add(i);</span><br><span class="line">16             linked.add(i);</span><br><span class="line">17         &#125;</span><br><span class="line">18         System.out.println(&quot;ArrayList访问消耗的时间：&quot; + getTime(array));</span><br><span class="line">19         System.out.println(&quot;LinkedList访问消耗的时间：&quot; + getTime(linked));</span><br><span class="line">20     &#125;</span><br><span class="line">21 </span><br><span class="line">22     public static long getTime(List list) &#123;</span><br><span class="line">23         long time = System.currentTimeMillis();</span><br><span class="line">24         for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">25             int index = Collections.binarySearch(list, list.get(i));</span><br><span class="line">26             if (index != i) &#123;</span><br><span class="line">27                 System.out.println(&quot;ERROR!&quot;);</span><br><span class="line">28             &#125;</span><br><span class="line">29         &#125;</span><br><span class="line">30         return System.currentTimeMillis() - time;</span><br><span class="line">31     &#125;</span><br><span class="line">32 </span><br><span class="line">33 &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList访问消耗的时间：10</span><br><span class="line">LinkedList访问消耗的时间：383</span><br></pre></td></tr></table></figure>

<p>可以看出，对于随机访问，ArrayList的访问速度更快。 </p>
<p>ArrayList和LinkedList的插入数据耗时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> 1 package com.demo;</span><br><span class="line"> 2 </span><br><span class="line"> 3 import java.util.ArrayList; </span><br><span class="line"> 4 import java.util.LinkedList;</span><br><span class="line"> 5 import java.util.List;</span><br><span class="line"> 6 </span><br><span class="line"> 7 public class Demo2 &#123;</span><br><span class="line"> 8     static List&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;();</span><br><span class="line"> 9     static List&lt;Integer&gt; linked = new LinkedList&lt;Integer&gt;();</span><br><span class="line">10 </span><br><span class="line">11     public static void main(String[] args) &#123;</span><br><span class="line">12 </span><br><span class="line">13         for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">14             array.add(i);</span><br><span class="line">15             linked.add(i);</span><br><span class="line">16         &#125;</span><br><span class="line">17         System.out.println(&quot;ArrayList插入消耗的时间：&quot; + insertTime(array));</span><br><span class="line">18         System.out.println(&quot;LinkedList插入消耗的时间：&quot; + insertTime(linked));</span><br><span class="line">19     &#125;</span><br><span class="line">20 </span><br><span class="line">21     public static long insertTime(List list) &#123;</span><br><span class="line">22         long time = System.currentTimeMillis();</span><br><span class="line">23         for (int i = 100; i &lt; 10000; i++) &#123;</span><br><span class="line">24             list.add(10, i); // 在索引为10的位置插入i</span><br><span class="line">25         &#125;</span><br><span class="line">26         return System.currentTimeMillis() - time;</span><br><span class="line">27     &#125;</span><br><span class="line">28 &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList插入消耗的时间：31</span><br><span class="line">LinkedList插入消耗的时间：4</span><br></pre></td></tr></table></figure>

<p>可以看出，对于插入操作，LinkedList 的速度更快</p>
<h2 id="在空间复杂度上的区别"><a href="#在空间复杂度上的区别" class="headerlink" title="在空间复杂度上的区别"></a>在空间复杂度上的区别</h2><p>在LinkedList中有一个私有的内部类，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static class Entry &#123;   </span><br><span class="line">         Object element;   </span><br><span class="line">         Entry next;   </span><br><span class="line">         Entry previous;   </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>LinkedList中的每一个元素中还存储了它的前一个元素的索引和后一个元素的索引。</p>
<p>ArrayList使用一个内置的数组来存储元素，这个数组的起始容量是10，当数组需要增长时，新的容量按如下公式获得：新容量 = 旧容量*1.5 + 1，也就是说每一次容量大概会增长50% </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>ArrayList的实现是基于数组，LinkedList的实现是基于双向链表。 </p>
</li>
<li><p>对于随机访问，ArrayList优于LinkedList，ArrayList可以根据下标以O(1)时间复杂度对元素进行随机访问。而LinkedList的每一个元素都依靠地址指针和它后一个元素连接在一起，在这种情况下，查找某个元素的时间复杂度是O(n) </p>
</li>
<li><p>对于插入和删除操作，LinkedList优于ArrayList，因为当元素被添加到LinkedList任意位置的时候，不需要像ArrayList那样重新计算大小或者是更新索引。 </p>
</li>
<li><p>LinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</p>
</li>
</ol>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhishui0501.github.io/数据结构.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="Keep Learning">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/数据结构.html" class="post-title-link" itemprop="url">数据结构</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-02 20:48:33 / Modified: 21:05:43" itemprop="dateCreated datePublished" datetime="2019-09-02T20:48:33+08:00">2019-09-02</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的逻辑结构和数据的物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构。</p>
<p>数据的逻辑结构和物理结构是数据结构的两个密切相关的方面，同一逻辑结构可以对应不同的存储结构。算法的设计取决于数据的逻辑结构，而算法的实现依赖于指定的存储结构。</p>
<p>数据结构的研究内容是构造复杂软件系统的基础，它的核心技术是分解与抽象。通过分解可以划分出数据的3个层次；再通过抽象，舍弃数据元素的具体内容，就得到逻辑结构。类似地，通过分解将处理要求划分成各种功能，再通过抽象舍弃实现细节，就得到运算的定义。上述两个方面的结合可以将问题变换为数据结构。这是一个从具体（即具体问题）到抽象（即数据结构）的过程。然后，通过增加对实现细节的考虑进一步得到存储结构和实现运算，从而完成设计任务。这是一个从抽象（即数据结构）到具体（即具体实现）的过程。</p>
<h2 id="常用的数据结构"><a href="#常用的数据结构" class="headerlink" title="常用的数据结构"></a>常用的数据结构</h2><p>数组(Array)<br>数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。数组可以说是最基本的数据结构，在各种编程语言中都有对应。一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等。数组还可以有一维、二维以及多维等表现形式。   </p>
<p>栈( Stack)<br>栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。栈按照后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。   </p>
<p>队列(Queue)<br>队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列。   </p>
<p>链表( Linked List)<br>链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。   </p>
<p>树( Tree)<br>树是典型的非线性结构，它是包括，2个结点的有穷集合K。在树结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有聊个后继结点，m≥0。   </p>
<p>图(Graph)<br>图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。   </p>
<p>堆(Heap)<br>堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构。   </p>
<p>散列表(Hash)<br>散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。   </p>
<h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><p>数据结构研究的内容：就是如何按一定的逻辑结构，把数据组织起来，并选择适当的存储表示方法把逻辑结构组织好的数据存储到计算机的存储器里。研究的目的是为了更有效的处理数据，提高数据运算效率。数据的运算是定义在数据的逻辑结构上，但运算的具体实现要在存储结构上进行。一般有以下几种常用运算：<br>(1)检索。检索就是在数据结构里查找满足一定条件的节点。一般是给定一个某字段的值，找具有该字段值的节点。<br>(2)插入。往数据结构晕增加新的节点。<br>(3)删除。把指定的结点从数据结构中去掉。<br>(4)更新。改变指定节点的一个或多个字段的值。<br>(5)排序。把节点按某种指定的顺序重新排列。例如递增或递减。</p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhishui0501.github.io/活活气死的一个晚上.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="Keep Learning">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/活活气死的一个晚上.html" class="post-title-link" itemprop="url">活活气死的一个晚上</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-01 10:10:08 / Modified: 11:10:26" itemprop="dateCreated datePublished" datetime="2019-09-01T10:10:08+08:00">2019-09-01</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/HEXO/" itemprop="url" rel="index"><span itemprop="name">HEXO</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>本来今天高高兴兴，网站成功被谷歌收录了，别人可以搜到我了<br>结果一打开发现图片挂掉了<br><img src="images/%E6%B0%94%E6%AD%BB.PNG" alt><br>投一次见这么诡异的bug，图片地址莫名其妙多了html后缀，而且。。为啥只有htm<br>?????????????????????????????????????<br>百度谷歌都搜不出来的bug<br>我l被吃了?????????????????????????????????</p>
<h2 id="原本通过相对路径"><a href="#原本通过相对路径" class="headerlink" title="原本通过相对路径"></a>原本通过相对路径</h2><p>通过配置博客根目录下的_config.yml来生成。<br><code>post_asset_folder: true</code><br>在hexo的目录下执行<code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code><br>将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。_posts/post_name/image.jpg这张照片可以用以下方式访问：<br><code>![](image.jpg)</code></p>
<blockquote>
<p>本来没有问题，突然就挂掉了</p>
</blockquote>
<p>上述markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。</p>
<blockquote>
<p>都不能显示</p>
</blockquote>
<p>如果希望图片在文章和首页中同时显示，可以使用标签插件语法。_posts/post_name/image.jpg这张照片可以用以下方式访问：<br><code>{% asset_img image.jpg This is an image %}</code></p>
<blockquote>
<p>这里又出了新bug{}里的内容无法显示，转义也不行，应该是hexo解析问题，通过使用{% raw %}{% endraw %}解决</p>
</blockquote>
<blockquote>
<p>官网说：通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo3的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。</p>
<ol>
<li>但是使用{}这种方式也并没有解决我的问题</li>
<li>修改hexo—assert-images插件也没有任何作用，我都不觉得这东西有什么用</li>
<li>我甚至直接修改对应html文件，竟然都没用(改动github对应html倒是可以，但总不能部署一次改一次吧??)</li>
</ol>
</blockquote>
<h2 id="问题解决-绝对路径"><a href="#问题解决-绝对路径" class="headerlink" title="问题解决 绝对路径"></a>问题解决 绝对路径</h2><p>当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。对于source/images/image.jpg这张图片可以用以下语法访问到<br><code>![](/images/image.jpg)</code><br>图片既可以在首页内容中访问到，也可以在文章正文中访问到</p>
<blockquote>
<p>成功</p>
</blockquote>
<h2 id="CDN引用"><a href="#CDN引用" class="headerlink" title="CDN引用"></a>CDN引用</h2><p>除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。因国内访问github速度较慢，所以将突破放到国内图床上，然后引用外链是常用的方法。<br>常用图床总结：<a href="https://sspai.com/post/40499" rel="external nofollow noopener noreferrer" target="_blank">https://sspai.com/post/40499</a></p>
<p>图床，也就是专门提供存储图片的地方，我们只要通过图床提供的 API 接口，把图片上传上去，就可以通过外链访问了，根本不用操心图片是怎么存的，硬盘空间不够了，硬盘坏了，访问速度比较慢等等问题，这些图床都会帮我们搞定，他们会用各种技术帮我们做图片相关的优化和服务，比如多机互备、CDN 加速、图片处理、图片鉴黄、文本识别等等。</p>
<p>当然，图床也是有缺点的，当所有人都把图片存在同一个图床上，万一有一天图床真挂了，那所有图片就都无法访问了，虽然这种情况的概率很低，但并不等于不会发生</p>
<p>目前图床可以分为两种，一种是公共图床，一种是自建图床。公共图床也就是利用公共服务的图片上传接口，来提供图片外链的服务，比如新浪微博。自建图床，也就是利用各大云服务商提供的存储空间或者自己在 VPS 上使用开源软件来搭建图床，存储图片，生成外链提供访问，比如七牛、Lychee 开源自建图床方案。</p>
<p>微博图床（Chrome浏览器有个“新浪微博图床”插件，可以自动生成markdown链接）简单方便<br>七牛：测试域名30天，哭<br>腾讯云等云存储服务，需要先将照片放到云盘，然后找到超链接，然后粘贴到文章。太麻烦，放弃。<br>【强烈推荐！！！】ipic 工具，具体用法请谷歌，支持监控剪贴板，一键上传到微博图床，免费版默认是微博图床，支持七牛云等，下载地址: <a href="https://itunes.apple.com/cn/app/id1101244278?mt=12" rel="external nofollow noopener noreferrer" target="_blank">https://itunes.apple.com/cn/app/id1101244278?mt=12</a></p>
<h2 id="使用GitHub"><a href="#使用GitHub" class="headerlink" title="使用GitHub"></a>使用GitHub</h2><p>使用github存储博客图片</p>
<ol>
<li>创建一个空的repo</li>
<li>然后将图片push到repo中</li>
<li>点击图片进去，有个download，右键复制链接</li>
<li>将链接插入文章<br><code>![logo](https://github.com/xxxx/xx.jpg)</code></li>
</ol>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhishui0501.github.io/泛型的意义和作用.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="Keep Learning">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/泛型的意义和作用.html" class="post-title-link" itemprop="url">泛型的意义和作用</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-31 20:12:48 / Modified: 21:00:28" itemprop="dateCreated datePublished" datetime="2019-08-31T20:12:48+08:00">2019-08-31</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="意义和作用："><a href="#意义和作用：" class="headerlink" title="意义和作用："></a>意义和作用：</h2><p>类型的参数化，就是可以把类型像方法的参数那样传递。这一点意义非凡。<br>泛型使编译器可以在编译期间对类型进行检查以提高类型安全，减少运行时由于对象类型不匹配引发的异常。<br>　　<br>想要理解为什么引入泛型，就要知道没有泛型的麻烦。<br>我们知道现在的程序开发都是面向对象了，所以程序里会有很多各种类型的对象，对象多了肯定需要有某种类型的容器来装。所以就有了一些容器类型，比如数组、ArrayList、HashMap、TreeSet等。<br>对于数组，我们知道需要在使用时指定数组装的对象类型，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal animal[];</span><br><span class="line"> </span><br><span class="line">Dog dog[];</span><br></pre></td></tr></table></figure>

<p>而对于集合类型容器如ArrayList、HashMap、TreeSet等，它们不但是容器，还提供了一些方法对容器内对象的操作方法，如get，set，sort。这个时候就需要知道容器内放的是什么类型的对象，才能return或set。</p>
<p>正因为程序开发人员可能把任何类型的对象放进集合容器，所以这些容器在设计的时候只能默认设计成装Object类型对象。因为Java里Object是根类。<br>所以容器就成了类似这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ListContainer &#123;</span><br><span class="line">    private Object obj;</span><br><span class="line"> </span><br><span class="line">    public Object getObj() &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setObj(Object obj) &#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，根据多态，容器就能装任何类型的对象了。不过，取出对象时则需求进行强制类型转换，转换成实际的类型。但这样会有很多类型不安全问题，为什么呢？因为编译器没法帮忙做类型检查，导致代码在运行时易于出现ClassCastException异常。因此，类型安全问题只能由程序员自己来把关了，记住各种类型，避免类型转换错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListContainer myContainer = new ListContainer();</span><br><span class="line">	 </span><br><span class="line">myContainer.setObj(&quot;123&quot;);</span><br><span class="line">	 </span><br><span class="line">   ArrayList objectList = new ArrayList();</span><br><span class="line">	 </span><br><span class="line">objectList.add(myContainer);</span><br><span class="line">	 </span><br><span class="line">//下面这句编译时无异常，运行时会ClassCastException异常</span><br><span class="line">	 </span><br><span class="line">Integer myStr = (Integer) (objectList.get(0)).getObj();</span><br><span class="line">	 </span><br><span class="line">//下面这句ok</span><br><span class="line">	 </span><br><span class="line">String myStr1 = (String) (objectList.get(0)).getObj();</span><br><span class="line">	</span><br><span class="line">System.out.println(myStr1);</span><br></pre></td></tr></table></figure>

<h2 id="泛型出场：类型的参数化"><a href="#泛型出场：类型的参数化" class="headerlink" title="泛型出场：类型的参数化"></a>泛型出场：类型的参数化</h2><p>利用泛型，重新设计：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ListContainer&lt;T&gt; &#123;</span><br><span class="line">    private T t;</span><br><span class="line"> </span><br><span class="line">    public T getObj() &#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setObj(T t) &#123;</span><br><span class="line">        this.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<t>的T的类型的参数，具体T指代什么类型，是String还是Animal还是Dog类型此处不管，而在程序员开发时使用到ListContainer时再指定，如：<br><code>ListContainer&lt;Dog&gt; myCon=new ListContainer&lt;Dog&gt;();</code><br>这种环境下，编译器就知道ListContainer容器是放Dog类型对象的。并进行类型安全检查。</t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myCon.setObj(new Dog())//ok</span><br><span class="line"> </span><br><span class="line">myCon.setObj(“123”);//编译时提醒类型错误</span><br></pre></td></tr></table></figure>

<p>这样设计的容器在使用时编译器就可以帮忙做很大一部分的类型安全检查工作了，这就避免了很多运行时的ClassCastException异常，程序员也无需记住各种对象的类型和担心类型匹配问题了。同时大部分情况下也不用做类型强制转换工作了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ListContainer&lt;String&gt; myContainer = new ListContainer&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">myContainer.setObj(&quot;123&quot;);</span><br><span class="line"> </span><br><span class="line">myContainer.setObj(new Dog());//编译器就提醒类型异常</span><br><span class="line"> </span><br><span class="line">ArrayList objectList&lt;ListContainer&gt; = new ArrayList&lt;ListContainer&gt;();</span><br><span class="line"> </span><br><span class="line">objectList.add(myContainer);</span><br><span class="line"> </span><br><span class="line">Integer myStr = (objectList.get(0)).getObj(); //编译时提醒类型异常</span><br><span class="line"> </span><br><span class="line">String myStr = (objectList.get(0)).getObj();</span><br></pre></td></tr></table></figure>

<p>当然泛型的&lt;&gt;里也可以放多个参数，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MultiContainer&lt;T,S&gt; &#123;</span><br><span class="line"> </span><br><span class="line">private T t;</span><br><span class="line"> </span><br><span class="line">private S s;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">MultiContainer&lt;String,Dog&gt; multicon=new MultiContainer&lt;String,Dog&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="有界泛型"><a href="#有界泛型" class="headerlink" title="有界泛型"></a>有界泛型</h2><p>看看这个泛型和多态的问题,Dog,Cat是Animal的子类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void killAll(ArrayList&lt;Animal&gt; animals)&#123;...&#125;;//Animal容器</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">ArrayList&lt;Animal&gt; animals=new ArrayList&lt;Animal&gt;();</span><br><span class="line"> </span><br><span class="line">animals.add(new Dog());</span><br><span class="line"> </span><br><span class="line">animals.add(new Cat());</span><br><span class="line"> </span><br><span class="line">killAll(animals);//这里ok</span><br><span class="line"> </span><br><span class="line">ArrayList&lt;Dog&gt; dogs=new ArrayList&lt;Dog&gt;();//Dog是Animal的子类</span><br><span class="line"> </span><br><span class="line">dogs.add(new Dog());</span><br><span class="line"> </span><br><span class="line">dogs.add(new Dog());</span><br><span class="line"> </span><br><span class="line">killAll(dogs);//这里编译不通过</span><br></pre></td></tr></table></figure>

<p>在这里看上去似乎多态不行了。<br>这里就要用到有界泛型：<br>在使用泛型时，我们会有这种需求：需要指定泛型的类型范围。有界类型就是在类型参数部分指定extends或super关键字，这里的extends也含有implements的功能，分别用上限或下限来限制类型范围，从而限制泛型的类型边界。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends Animal&gt;//限定T是Animal的子类</span><br><span class="line"> </span><br><span class="line">&lt;T super Dog &gt;//限定T是Dog的超类</span><br></pre></td></tr></table></figure>

<p>那么上面那个多态问题就变成：<br><code>public void killAll(ArrayList&lt;T extends Animal&gt; animals){...};</code><br>解决了<br><code>&lt;T extends Object&amp;Comparable&amp;Serializable&gt;</code><br>多个限定时我们可以使用&amp;来进行分割，这时关键词只能使用extends。与多重继承类似，这里只有一个类其他都是接口。</p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>有时，我们设计的方法可能其参数类型是不限定的。这种场景如果用重载方法的方式来做的话，算法重复，不是最好的方案。此时泛型方法就可以解决此类问题。<br>如Calculator的add方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static &lt; N extends Number &gt; double add( N a, N b )&#123;</span><br><span class="line">	double sum = 0;</span><br><span class="line"> </span><br><span class="line">	sum = a.doubleValue() + b.doubleValue();</span><br><span class="line"> </span><br><span class="line">	return(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用重载来做的话，要很多重复代码了。</p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhishui0501.github.io/Navicat连接Mysql报错.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="Keep Learning">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/Navicat连接Mysql报错.html" class="post-title-link" itemprop="url">Navicat连接Mysql报错</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-29 22:45:12 / Modified: 22:55:19" itemprop="dateCreated datePublished" datetime="2019-08-29T22:45:12+08:00">2019-08-29</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>Client does not support authentication protocol requested by server；<br>解决办法，登入MySQL的命令行界面，然后输入：<br><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;;</code><br>其中password需要改成你自己的密码，大概原因是MySQL8.0的加密方式改变了，但是比较老版本的navicate没有来得及支持，因此需要将mysql设置为支持传统的那种密码加密，如果用比较低版本的MySQL，比如MySQL57应该就不会出现这种问题。<br>最后再输入下面一句进行刷新<br><code>FLUSH PRIVILEGES;</code><br>问题解决</p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhishui0501.github.io/对jQuery对象的理解.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="Keep Learning">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/对jQuery对象的理解.html" class="post-title-link" itemprop="url">对jQuery对象的理解</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-27 21:44:23 / Modified: 21:48:27" itemprop="dateCreated datePublished" datetime="2019-08-27T21:44:23+08:00">2019-08-27</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="什么是jQuery对象？"><a href="#什么是jQuery对象？" class="headerlink" title="什么是jQuery对象？"></a>什么是jQuery对象？</h2><p>jQuery对象是通过jQuery包装DOM对象后产生的对象。</p>
<p>这里首先要理解DOM文档对象模型：</p>
<p>（1）DOM解析XML文档时，DOM为XML文档在逻辑上建立一个树模型；</p>
<p>（2）DOM把XML文档作为树结构来查看，XML文档的树形结构节点就是XML文档上的元素、文本和属性。</p>
<p>还要理解HTML页面为什么与DOM对象联系在一起？</p>
<p>因为HTML页面中的元素都表现为类似XML文档的树形结构：存在元素节点、属性节点和文本节点，所以用</p>
<p>DOM对象也可以解析HTML页面中的元素（这也是形成jQuery选择器的原因）。</p>
<p>再者，还要理解DOM对象如何转化为jQuery对象？</p>
<p>HTML DOM 定义了多种查找HTML页面元素的方法，除了 getElementById() 之外，</p>
<p>还有 getElementsByName() 和 getElementsByTagName()。找到的这个页面元素就是一个DOM对象。</p>
<p>用jQuery构造这个DOM对象，就获得一个jQuery对象。示例：</p>
<p>var domObj = document.getElementById(“element”);</p>
<p>var $obj=jQuery(domObj);</p>
<h2 id="jQuery对象的表示："><a href="#jQuery对象的表示：" class="headerlink" title="jQuery对象的表示："></a>jQuery对象的表示：</h2><p>在jQuery库中，$是jQuery的一个简写形式，所以一个节点元素的jQuery对象可以写成：</p>
<p>$(nodeString)</p>
<p>其中，nodeString是：Html标签的id、class、或者标签名等。</p>
<h2 id="jQuery中DOM的操作"><a href="#jQuery中DOM的操作" class="headerlink" title="jQuery中DOM的操作"></a>jQuery中DOM的操作</h2><p>DOM是一种与浏览器、语言无关的接口，利用该接口可以方便地访问HTML页面中的标准组件。jQuery提供了一系列方法对DOM进行各种操作，从而通过DOM实现对HTML页面中各种元素的操作。</p>
<p>每一个HTML页面都可以使用DOM表示，在使用jQuery进行DOM操作之前，HTML页面首先被看作一棵DOM树。</p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhishui0501.github.io/数据的逻辑结构和存储结构.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="Keep Learning">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/数据的逻辑结构和存储结构.html" class="post-title-link" itemprop="url">数据的逻辑结构和存储结构</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-26 21:42:12" itemprop="dateCreated datePublished" datetime="2019-08-26T21:42:12+08:00">2019-08-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-02 20:49:42" itemprop="dateModified" datetime="2019-09-02T20:49:42+08:00">2019-09-02</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p><img src="images/1908261.png" alt><br>我们从上可以发现：上面这三种逻辑结构之间的节点与节点之间的关系是不一样的，对于线性结构来说，节点之间的关系是一对一的；树形结构的节点是一对多；图形结构的节点是多对多的关系。</p>
<ol>
<li><p>线性结构：开始节点和终端节点都是唯一的，我们可以把第一个节点认为是开始节点，第四个节点认为是终端节点。除了开始节点和终端节点以外，其余节点都有且仅有一个前驱节点，有且仅有一个后继节点。对于第二个节点来说，它的前驱节点就是第一个节点，它的后继节点是第三个节点。</p>
</li>
<li><p>树形结构：开始节点唯一，终端节点不唯一，开始节点就是指的根节点，终端节点就是指的最下面的节点。除终端节点以外，每个节点有一个或多个后继节点，在根节点的左节点中有三个后继节点，右节点有两个后继节点，除开始节点外（根节点没有前驱节点），每个节点有且仅有一个前驱节点。</p>
</li>
<li><p>图形结构：没有开始节点和终端节点，所有节点都可能有多个前驱节点和多个后继节点，也就是说形成了一个多对多的图形结构，我们在图形结构中也看到了，节点之间是相互连接的。<br>下面这张图是数据逻辑结构的层次组织关系<br><img src="images/1908262.png" alt><br>数据逻辑结构主要分为线性结构和非线性结构，在非线性结构中又包括了之前讲过的树和图两种结构，在树结构中又分为一般树和二叉树，图结构又分为有向图和无向图；在线性结构中包括了一般的线性表，受限线性表，线性表推广等，在受线性表中分为栈和队列。因此我们应该根据数据逻辑结构把所有的数据结构中的内容通过上图的方式组织起来，起码做到对这张图有个印象，这将会指导后面的学习。</p>
</li>
</ol>
<p>另外，我们在学习掌握数据的逻辑结构时，还应该掌握逻辑结构的二元组表示方法。对于线性结构，树形结构，图形结构都可以通过这种二元组来表示.</p>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>数据的存储方式可分为线性表、树和图三种存储结构，而每种存储结构又可细分为顺序存储结构和链式存储结构。数据存储方式如此之多，针对不同类型的数据选择合适的存储方式是至关重要的。<br>那么，到底如何选择呢？数据存储结构的选择取决于两方面，即数据的逻辑结构和存储结构（又称物理结构）。</p>
<h3 id="逻辑结构-1"><a href="#逻辑结构-1" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>数据的逻辑结构，简单地理解，就是指的数据之间的逻辑关系。<br><img src="images/1908263.gif" alt><br>例如，图 1 显示是一张家庭的成员关系图，从图中可以看到，张平、张华和张群是兄弟，他们的父亲是张亮，其中张平有两个儿子，分别是张晶和张磊。</p>
<p>以上所说，父子、兄弟等这些关系都指的是数据间的逻辑关系，假设我们要存储这样一张家庭成员关系图，不仅要存储张平、张华等数据，还要存储它们之间的关系，两者缺一不可。</p>
<p>一组数据成功存储到计算机的衡量标准是要能将其完整的复原。例如图 1 所示的成员关系图，如果所存储的数据能将此成员关系图彻底复原，则说明数据存储成功。</p>
<ol>
<li>线性表用于存储具有“一对一”逻辑关系的数据；</li>
<li>树结构用于存储具有“一对多”关系的数据；</li>
<li>图结构用于存储具有“多对多”关系的数据；</li>
</ol>
<p>由此，我们可以通过分析数据之间的逻辑关系来决定使用哪种存储结构，但具体使用顺序存储还是链式存储，还要通过数据的物理结构来决定。</p>
<h3 id="存储结构（物理结构）"><a href="#存储结构（物理结构）" class="headerlink" title="存储结构（物理结构）"></a>存储结构（物理结构）</h3><p>数据的存储结构，也就是物理结构，指的是数据在物理存储空间上选择集中存放还是分散存放。假设要存储大小为 10G 的数据，则集中存放就如图 3a) 所示，分散存放就如图 3b）所示。<br><img src="images/1908264.gif" alt><br>如果选择集中存储，就使用顺序存储结构；反之，就使用链式存储。至于如何选择，主要取决于存储设备的状态以及数据的用途。</p>
<p>我们知道，集中存储（底层实现使用的是数组）需要使用一大块连续的物理空间，假设要存储大小为 1G 的数据，若存储设备上没有整块大小超过 1G 的空间，就无法使用顺序存储，此时就要选择链式存储，因为链式存储是随机存储数据，占用的都是存储设备中比较小的存储空间，因此有一定几率可以存储成功。</p>
<p>并且，数据的用途不同，选择的存储结构也不同。将数据进行集中存储有利于后期对数据进行遍历操作，而分散存储更有利于后期增加或删除数据。因此，如果后期需要对数据进行大量的检索（遍历），就选择集中存储；反之，若后期需要对数据做进一步更新（增加或删除），则选择分散存储。</p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" src="/images/touxiang.jpg" alt="Aaron">
  <p class="site-author-name" itemprop="name">Aaron</p>
  <div class="site-description motion-element" itemprop="description">Keep Learning</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/zhishui0501" title="GitHub &rarr; https://github.com/zhishui0501" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:876944049@qq.com" title="E-Mail &rarr; mailto:876944049@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Aaron</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="external nofollow noopener noreferrer" target="_blank">NexT.Gemini</a> v7.3.0</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="Total Visitors">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="Total Views">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>


  <script src="/js/affix.js?v=7.3.0"></script>
  <script src="/js/schemes/pisces.js?v=7.3.0"></script>



<script src="/js/next-boot.js?v=7.3.0"></script>




  




























  

  

  


  
</body>
</html>
